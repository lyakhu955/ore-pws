<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Ore PWS Group (Modern)</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="Applicazione per la gestione delle ore di lavoro - Ore PWS Group">
    <meta name="keywords" content="ore lavoro, timesheet, gestione tempo, PWS Group">
    <meta name="author" content="PWS Group">
    <meta name="robots" content="index, follow">

    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Ore PWS Group - Gestione Ore di Lavoro">
    <meta property="og:description" content="Applicazione moderna per la gestione delle ore di lavoro con sincronizzazione cloud">
    <meta property="og:type" content="website">
    <meta property="og:image" content="https://i.imgur.com/BnllByD.png">

    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Ore PWS Group - Gestione Ore di Lavoro">
    <meta name="twitter:description" content="Applicazione moderna per la gestione delle ore di lavoro">
    <meta name="twitter:image" content="https://i.imgur.com/BnllByD.png">

    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#006A6A">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Ore PWS">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Ore PWS">

    <!-- Apple Touch Icons -->
    <link rel="apple-touch-icon" sizes="180x180" href="./icons/icon-192x192.png">
    <link rel="apple-touch-icon" sizes="152x152" href="./icons/icon-152x152.png">
    <link rel="apple-touch-icon" sizes="144x144" href="./icons/icon-144x144.png">
    <link rel="apple-touch-icon" sizes="120x120" href="./icons/icon-128x128.png">
    <link rel="apple-touch-icon" sizes="114x114" href="./icons/icon-128x128.png">
    <link rel="apple-touch-icon" sizes="76x76" href="./icons/icon-96x96.png">
    <link rel="apple-touch-icon" sizes="72x72" href="./icons/icon-72x72.png">
    <link rel="apple-touch-icon" href="./icons/icon-192x192.png">

    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="32x32" href="./icons/icon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="./icons/icon-72x72.png">
    <link rel="shortcut icon" href="./icons/icon-96x96.png">

    <!-- Dynamic Canonical URL -->
    <script>
        // Set canonical URL dynamically based on current domain
        const canonicalUrl = window.location.origin + window.location.pathname;
        const canonicalLink = document.createElement('link');
        canonicalLink.rel = 'canonical';
        canonicalLink.href = canonicalUrl;
        document.head.appendChild(canonicalLink);

        // Set Open Graph URL dynamically
        const ogUrlMeta = document.createElement('meta');
        ogUrlMeta.property = 'og:url';
        ogUrlMeta.content = canonicalUrl;
        document.head.appendChild(ogUrlMeta);
    </script>
    <!-- Google Fonts: Roboto and Material Symbols Outlined -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <!-- Include Flatpickr CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <style>
        /* Material Design 3 Inspired Theme - Android 2025 */
        /* Fix iOS Safari Datepicker Issues */
@supports (-webkit-touch-callout: none) {
    /* iOS specific styles */
    .flatpickr-calendar {
        -webkit-transform: translateZ(0);
        transform: translateZ(0);
        -webkit-backface-visibility: hidden;
        backface-visibility: hidden;
        -webkit-perspective: 1000;
        perspective: 1000;
        touch-action: manipulation;
        /* Enhanced iOS stability */
        will-change: transform;
        position: fixed !important;
        z-index: 9999 !important;
    }
    
    .flatpickr-day {
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
        padding: 10px; /* Larger touch target */
        /* Enhanced iOS touch handling */
        -webkit-user-select: none;
        user-select: none;
        will-change: auto;
    }
    
    /* Prevent iOS zoom on focus */
    input.datepicker, input.datepicker-ferie {
        font-size: 16px !important;
        -webkit-transform: translateZ(0);
        transform: translateZ(0);
    }

    /* Enhanced iOS-safe date indicator */
    #dateIndicator {
        -webkit-tap-highlight-color: transparent;
        touch-action: manipulation;
        -webkit-user-select: none;
        user-select: none;
        will-change: auto;
    }

    .date-navigator button.date-arrow-btn {
        background: none;
        border: none;
        cursor: pointer;
        padding: 10px 21px;
        border-radius: 50%;
        transition: all 0.2s ease;
        color: var(--md-sys-color-primary, #006A6A);
        font-size: 2.4em;
        min-width: 62px;
        min-height: 62px;
        display: flex;
        align-items: center;
        justify-content: center;
        /* iOS-safe touch handling */
        -webkit-tap-highlight-color: transparent;
        touch-action: manipulation;
        -webkit-user-select: none;
        user-select: none;
        /* Enhanced visual feedback */
        position: relative;
        overflow: hidden;
    }
    
    .date-navigator button.date-arrow-btn::before {
        content: '';
        position: absolute;
        top: 50%;
        left: 50%;
        width: 0;
        height: 0;
        background: var(--md-sys-color-primary-container, #e0f7fa);
        border-radius: 50%;
        transform: translate(-50%, -50%);
        transition: width 0.3s ease, height 0.3s ease;
    }
    
    .date-navigator button.date-arrow-btn:hover::before,
    .date-navigator button.date-arrow-btn:active::before {
        width: 100%;
        height: 100%;
    }
    
    .date-navigator button.date-arrow-btn .material-symbols-outlined {
        font-size: 2em !important;
        line-height: 1;
        pointer-events: none;
        position: relative;
        z-index: 1;
    }
    
    .date-navigator button.date-arrow-btn:hover {
        background: var(--md-sys-color-primary-container, #e0f7fa);
        transform: scale(1.05);
    }
    
    .date-navigator button.date-arrow-btn:active {
        transform: scale(0.95);
        background: var(--md-sys-color-primary, #006A6A);
        color: var(--md-sys-color-on-primary, #FFFFFF);
    }
    
    /* iOS-specific: Frecce ridimensionate ottimali */
    @supports (-webkit-touch-callout: none) {
        .date-navigator button.date-arrow-btn {
            font-size: 1.44em !important; /* Era 1.2em, +20% = 1.44em */
            min-width: 37px !important; /* Era 31px, +20% = 37px */
            min-height: 37px !important; /* Era 31px, +20% = 37px */
            padding: 6px 12px !important; /* Era 5px 10px, +20% = 6px 12px */
        }
        
        .date-navigator button.date-arrow-btn .material-symbols-outlined {
            font-size: 1.2em !important; /* Era 1em, +20% = 1.2em */
        }
    }
    
    /* Fix for Google login keyboard issue */
    .cloud-login-btn {
        -webkit-user-select: text;
        user-select: text;
        touch-action: manipulation;
    }

    /* Enhanced date central click area */
    #dateIndicatorContent {
        cursor: pointer !important;
        padding: 8px 16px;
        border-radius: var(--border-radius-medium, 12px);
        transition: all 0.2s ease;
        -webkit-tap-highlight-color: transparent;
        touch-action: manipulation;
        -webkit-user-select: none;
        user-select: none;
        position: relative;
        overflow: hidden;
    }

    #dateIndicatorContent::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: var(--md-sys-color-primary-container, #e0f7fa);
        opacity: 0;
        border-radius: var(--border-radius-medium, 12px);
        transition: opacity 0.2s ease;
        z-index: -1;
    }

    #dateIndicatorContent:hover::before {
        opacity: 0.5;
    }

    #dateIndicatorContent:active::before {
        opacity: 0.8;
        background: var(--md-sys-color-primary, #006A6A);
    }

    #dateIndicatorContent:active {
        color: var(--md-sys-color-on-primary, #FFFFFF);
        transform: scale(0.98);
    }

    /* Day name indicator styles */
    #dayNameIndicator {
        text-align: center;
        font-weight: 600;
        font-size: 1.1em;
        color: var(--md-sys-color-primary, #006A6A);
        margin-bottom: 8px;
        padding: 4px 12px;
        border-radius: var(--border-radius-medium, 12px);
        background: var(--md-sys-color-primary-container, rgba(0, 106, 106, 0.1));
        transition: all 0.2s ease;
        letter-spacing: 0.5px;
        text-transform: capitalize;
        /* Nascosto su Android, visibile solo su iOS */
        display: none !important;
    }

    /* iOS-specific: Mostra nome giorno solo su iOS */
    @supports (-webkit-touch-callout: none) {
        #dayNameIndicator {
            display: block !important;
        }
    }

    /* Date navigator container improvements */
    .date-navigator {
        gap: 4px !important;
        align-items: center;
        padding: 4px;
        border-radius: var(--border-radius-large, 16px);
        background: var(--md-sys-color-surface-variant, #DAE5E4);
        box-shadow: var(--elevation-1);
        border: 1px solid var(--md-sys-color-outline-variant, #BFC9C8);
    }
}

/* iOS Safari Keyboard Fix */
.ios-keyboard-fix {
    position: fixed;
    top: 0;
    left: 0;
    height: 1px;
    width: 1px;
    opacity: 0.01;
    pointer-events: none;
}


        /* iOS Safari Compatibility Fixes */
        html {
            height: 100%;
            height: -webkit-fill-available;
        }

        body {
            min-height: 100vh;
            min-height: -webkit-fill-available;
        }

        /* Safe Area Support for iOS */
        @supports (padding: max(0px)) {
            body {
                padding-left: env(safe-area-inset-left, 0px);
                padding-right: env(safe-area-inset-right, 0px);
                padding-top: env(safe-area-inset-top, 0px);
            }

            header {
                padding-top: calc(0.75rem + env(safe-area-inset-top, 0px));
                padding-left: calc(1rem + env(safe-area-inset-left, 0px));
                padding-right: calc(1rem + env(safe-area-inset-right, 0px));
            }

            main {
                margin-top: calc(70px + env(safe-area-inset-top, 0px));
            }

            .bottom-nav {
                padding-bottom: calc(0.5rem + env(safe-area-inset-bottom, 0px));
                padding-left: env(safe-area-inset-left, 0px);
                padding-right: env(safe-area-inset-right, 0px);
            }


        }

        /* iOS Touch Optimization */
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }

        button, .btn, .button, [role="button"] {
            -webkit-tap-highlight-color: rgba(0, 0, 0, 0.1);
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }

        /* iOS Scroll Optimization */
        .scrollable, .modal-content, .calendar-container {
            -webkit-overflow-scrolling: touch;
        }

        /* Additional Webkit Prefixes for iOS Safari */
        .card, .modal, .bottom-nav {
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }

        input, select, textarea {
            -webkit-appearance: none;
            -webkit-border-radius: 0;
        }

        /* iOS Safari Animation Optimization */
        .fade-in {
            -webkit-animation: fadeIn 0.3s ease-out;
            animation: fadeIn 0.3s ease-out;
        }

        /* iOS Safari Scroll Bounce Fix */
        body {
            overscroll-behavior: none;
            -webkit-overflow-scrolling: touch;
        }

        /* iOS Safari Input Focus Fix */
        input, textarea, select {
            font-size: 16px; /* Prevents zoom on focus in iOS Safari */
        }

        @media screen and (max-width: 768px) {
            input, textarea, select {
                font-size: 16px !important; /* Force 16px on mobile to prevent zoom */
            }
        }

        /* Override existing body padding for safe area compatibility */
        body {
            padding-bottom: calc(80px + env(safe-area-inset-bottom, 0px)) !important;
        }

        :root {
            /* Light Theme Palette (Material You - Teal/Blue Base) */
            --md-sys-color-primary: #006A6A;
            --md-sys-color-on-primary: #FFFFFF;
            --md-sys-color-primary-container: #9DF2F1;
            --md-sys-color-on-primary-container: #002020;
            --md-sys-color-secondary: #4A6363;
            --md-sys-color-on-secondary: #FFFFFF;
            --md-sys-color-secondary-container: #CCE8E7;
            --md-sys-color-on-secondary-container: #051F1F;
            --md-sys-color-tertiary: #4B607C;
            --md-sys-color-on-tertiary: #FFFFFF;
            --md-sys-color-tertiary-container: #D3E4FF;
            --md-sys-color-on-tertiary-container: #041C35;
            --md-sys-color-error: #BA1A1A;
            --md-sys-color-on-error: #FFFFFF;
            --md-sys-color-error-container: #FFDAD6;
            --md-sys-color-on-error-container: #410002;
            --md-sys-color-background: #FAFDFC;
            --md-sys-color-on-background: #191C1C;
            --md-sys-color-surface: #FAFDFC;
            --md-sys-color-on-surface: #191C1C;
            --md-sys-color-surface-variant: #DAE5E4;
            --md-sys-color-on-surface-variant: #3F4948;
            --md-sys-color-outline: #6F7979;
            --md-sys-color-outline-variant: #BFC9C8;
            --md-sys-color-shadow: #000000;
            --md-sys-color-scrim: #000000;
            --body-font-family: 'Roboto', sans-serif;
            --base-font-size: 16px;
            --border-radius-small: 8px;
            --border-radius-medium: 12px;
            --border-radius-large: 16px;
            --border-radius-full: 999px;
            --elevation-1: 0px 1px 2px rgba(0, 0, 0, 0.3), 0px 1px 3px 1px rgba(0, 0, 0, 0.15);
            --elevation-2: 0px 1px 2px rgba(0, 0, 0, 0.3), 0px 2px 6px 2px rgba(0, 0, 0, 0.15);
            --elevation-3: 0px 4px 8px 3px rgba(0, 0, 0, 0.15), 0px 1px 3px rgba(0, 0, 0, 0.3);
            --elevation-4: 0px 6px 10px 4px rgba(0, 0, 0, 0.15), 0px 2px 3px rgba(0, 0, 0, 0.3);
            --elevation-5: 0px 8px 12px 6px rgba(0, 0, 0, 0.15), 0px 4px 4px rgba(0, 0, 0, 0.3);
        }

        /* Dark Theme Palette */
        .dark-theme {
            --md-sys-color-primary: #81D5D4;
            --md-sys-color-on-primary: #003737;
            --md-sys-color-primary-container: #00504F;
            --md-sys-color-on-primary-container: #9DF2F1;
            --md-sys-color-secondary: #B0CCCB;
            --md-sys-color-on-secondary: #1C3534;
            --md-sys-color-secondary-container: #334B4B;
            --md-sys-color-on-secondary-container: #CCE8E7;
            --md-sys-color-tertiary: #B3C8E8;
            --md-sys-color-on-tertiary: #1D314B;
            --md-sys-color-tertiary-container: #344863;
            --md-sys-color-on-tertiary-container: #D3E4FF;
            --md-sys-color-error: #FFB4AB;
            --md-sys-color-on-error: #690005;
            --md-sys-color-error-container: #93000A;
            --md-sys-color-on-error-container: #FFDAD6;
            --md-sys-color-background: #191C1C;
            --md-sys-color-on-background: #E0E3E2;
            --md-sys-color-surface: #191C1C;
            --md-sys-color-on-surface: #E0E3E2;
            --md-sys-color-surface-variant: #3F4948;
            --md-sys-color-on-surface-variant: #BFC9C8;
            --md-sys-color-outline: #899392;
            --md-sys-color-outline-variant: #3F4948;
            /* Shadow and Scrim remain black */
            --md-sys-color-inverse-surface: #E0E3E2;
            --md-sys-color-inverse-on-surface: #191C1C;
            --md-sys-color-inverse-primary: #006A6A;
        }

        /* Global Styles */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            font-size: var(--base-font-size);
        }

        body {
            font-family: var(--body-font-family);
            background-color: var(--md-sys-color-background);
            color: var(--md-sys-color-on-background);
            line-height: 1.5;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            padding-bottom: 80px; /* Space for bottom nav */
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
        }

        /* Header */
        header {
            background-color: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
            box-shadow: var(--elevation-1);
            padding: 0.75rem 1rem;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 1000;
            border-bottom: 1px solid var(--md-sys-color-outline-variant);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
        }

        .logo img {
            max-height: 40px; /* Adjusted logo size */
            width: auto;
            display: block;
        }

        /* Animazione logo rimbalzante */
        @keyframes bounce-horizontal {
            0%, 100% {
                transform: translateX(0) rotate(0deg);
                animation-timing-function: cubic-bezier(0.8, 0, 1, 1);
            }
            25% {
                transform: translateX(15px) rotate(5deg);
                animation-timing-function: cubic-bezier(0, 0, 0.2, 1);
            }
            50% {
                transform: translateX(0) rotate(0deg);
                animation-timing-function: cubic-bezier(0.8, 0, 1, 1);
            }
            75% {
                transform: translateX(-15px) rotate(-5deg);
                animation-timing-function: cubic-bezier(0, 0, 0.2, 1);
            }
        }

        .bouncing-logo {
            animation: bounce-horizontal 2s infinite;
            transform-origin: center;
            cursor: pointer;
            transition: filter 0.3s ease;
        }

        .bouncing-logo:hover {
            filter: drop-shadow(0 0 5px var(--md-sys-color-primary));
            animation-play-state: paused;
        }

        /* Animazione più vivace quando l'utente clicca sul logo */
        @keyframes bounce-excited {
            0%, 100% {
                transform: translateX(0) rotate(0deg) scale(1);
                animation-timing-function: cubic-bezier(0.8, 0, 1, 1);
            }
            10% {
                transform: translateX(20px) rotate(10deg) scale(1.2);
            }
            20% {
                transform: translateX(-20px) rotate(-15deg) scale(1.1);
            }
            30% {
                transform: translateX(15px) rotate(15deg) scale(1.15);
            }
            40% {
                transform: translateX(-15px) rotate(-10deg) scale(1.05);
            }
            50% {
                transform: translateY(-15px) rotate(5deg) scale(1.1);
            }
            60% {
                transform: translateY(10px) rotate(-5deg) scale(1.05);
            }
            70% {
                transform: translateX(20px) translateY(-5px) rotate(10deg) scale(1.1);
            }
            80% {
                transform: translateX(-20px) translateY(5px) rotate(-10deg) scale(1.05);
            }
            90% {
                transform: translateX(10px) translateY(-3px) rotate(5deg) scale(1.02);
            }
        }

        .bouncing-logo-excited {
            animation: bounce-excited 2s ease-in-out;
            transform-origin: center;
            cursor: pointer;
            filter: drop-shadow(0 0 8px var(--md-sys-color-primary));
        }

        /* Removed troll button styles */

        main {
            padding: 1rem;
            margin-top: 70px; /* Adjusted for header height */
        }

        /* Card */
        .card {
            background-color: var(--md-sys-color-surface-variant); /* Slightly different bg */
            color: var(--md-sys-color-on-surface-variant);
            border-radius: var(--border-radius-large);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: var(--elevation-1);
            border: 1px solid var(--md-sys-color-outline-variant);
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }

        .card h2, .card h3 {
            color: var(--md-sys-color-primary);
            margin-bottom: 1rem;
            font-weight: 500;
        }

        /* Forms */
        .form-group {
            margin-bottom: 1.25rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            font-size: 0.875rem;
            color: var(--md-sys-color-on-surface-variant);
        }

        input[type="text"],
        input[type="number"],
        input[type="email"],
        input[type="tel"],
        textarea,
        select {
            width: 100%;
            padding: 0.875rem 1rem;
            border: 1px solid var(--md-sys-color-outline);
            border-radius: var(--border-radius-small);
            font-size: 1rem;
            background-color: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            appearance: none; /* For select */
            -webkit-appearance: none;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--md-sys-color-primary);
            box-shadow: 0 0 0 2px var(--md-sys-color-primary-container);
        }

        select {
             /* Add arrow for select */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' height='24' viewBox='0 -960 960 960' width='24'%3E%3Cpath d='M480-345 240-585l56-56 184 184 184-184 56 56-240 240Z' fill='%23${(getComputedStyle(document.documentElement).getPropertyValue('--md-sys-color-on-surface').trim() || '#191C1C').substring(1)}'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 1rem center;
            background-size: 1.5em;
            padding-right: 3rem; /* Space for arrow */
        }
        .dark-theme select {
             background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' height='24' viewBox='0 -960 960 960' width='24'%3E%3Cpath d='M480-345 240-585l56-56 184 184 184-184 56 56-240 240Z' fill='%23${(getComputedStyle(document.documentElement).getPropertyValue('--md-sys-color-on-surface').trim() || '#E0E3E2').substring(1)}'/%3E%3C/svg%3E");
        }


        textarea {
            min-height: 100px;
            resize: vertical;
        }

        .form-row {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .form-group-inline {
            flex: 1;
            min-width: 120px;
        }

        /* Buttons */
        button, .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: var(--border-radius-full); /* Pill shape */
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            transition: background-color 0.2s ease, box-shadow 0.2s ease, transform 0.1s ease;
            box-shadow: var(--elevation-1);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        button:hover, .btn:hover {
            box-shadow: var(--elevation-2);
        }

        button:active, .btn:active {
            transform: scale(0.98);
            box-shadow: none;
        }

        /* Filled Button (Primary Action) */
        button[type="submit"], #submitBtn, #saveUserName, #addVehicle, #exportData, #importData, #saveFerieMalattie, .export-btn, .edit-all-btn, #addEntryBtn {
            background-color: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
        }
        button[type="submit"]:hover, #submitBtn:hover, #saveUserName:hover, #addVehicle:hover, #exportData:hover, #importData:hover, #saveFerieMalattie:hover, .export-btn:hover, .edit-all-btn:hover, #addEntryBtn:hover {
             /* Slightly darker/lighter on hover - generate this if needed */
            filter: brightness(90%);
        }
        .dark-theme button[type="submit"]:hover, .dark-theme #submitBtn:hover, .dark-theme #saveUserName:hover, .dark-theme #addVehicle:hover, .dark-theme #exportData:hover, .dark-theme #importData:hover, .dark-theme #saveFerieMalattie:hover, .dark-theme .export-btn:hover, .dark-theme .edit-all-btn:hover, .dark-theme #addEntryBtn:hover {
            filter: brightness(110%);
        }

        /* Error/Destructive Button */
        #clearData, .delete-btn, .delete-ferie-btn, .delete-vehicle-btn {
            background-color: var(--md-sys-color-error);
            color: var(--md-sys-color-on-error);
        }
         #clearData:hover, .delete-btn:hover, .delete-ferie-btn:hover, .delete-vehicle-btn:hover {
            filter: brightness(90%);
        }
        .dark-theme #clearData:hover, .dark-theme .delete-btn:hover, .dark-theme .delete-ferie-btn:hover, .dark-theme .delete-vehicle-btn:hover {
            filter: brightness(110%);
        }


        /* Text Button (e.g., Cancel) */
        .form-buttons button:last-child, .close-modal {
             background-color: transparent;
             color: var(--md-sys-color-primary);
             box-shadow: none;
        }
         .form-buttons button:last-child:hover, .close-modal:hover {
            background-color: var(--md-sys-color-primary-container);
         }
        .close-modal { /* Specific style for modal close */
             font-size: 1.75rem;
             padding: 0.5rem;
             border-radius: 50%;
             line-height: 1;
             color: var(--md-sys-color-on-surface-variant);
             font-weight: normal;
             border: none; /* Ensure no border */
        }
        .close-modal:hover {
            color: var(--md-sys-color-on-primary-container);
        }


        /* Small Action Buttons (Edit/Delete in lists) */
        .edit-btn, .delete-btn {
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            min-width: 36px;
            min-height: 36px;
            box-shadow: none;
            border-radius: var(--border-radius-small);
            text-transform: none;
            letter-spacing: normal;
            border: 1px solid transparent; /* Base border */
        }
        .edit-btn { /* Make edit look like an Outlined Button */
            background-color: transparent;
            color: var(--md-sys-color-primary);
            border-color: var(--md-sys-color-outline);
        }
        .edit-btn:hover {
             background-color: var(--md-sys-color-primary-container);
             border-color: var(--md-sys-color-primary-container);
        }
        .delete-btn {
            background-color: var(--md-sys-color-error-container);
            color: var(--md-sys-color-on-error-container);
        }
        .delete-btn:hover {
            filter: brightness(95%);
            background-color: var(--md-sys-color-error-container); /* Keep bg */
        }
         .dark-theme .delete-btn:hover {
            filter: brightness(110%);
         }

        /* Material Symbols */
        .material-symbols-outlined {
          font-variation-settings:
          'FILL' 0,
          'wght' 400,
          'GRAD' 0,
          'opsz' 24;
          vertical-align: middle; /* Align icons better with text */
          font-size: 1.25em; /* Slightly larger default size */
          line-height: 1; /* Prevent extra space */
        }

        /* Bottom Navigation */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: var(--md-sys-color-surface-variant); /* Navigation Rail style */
            box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
            padding: 0.5rem 0;
            display: flex;
            justify-content: space-around;
            align-items: stretch; /* Stretch items vertically */
            z-index: 1000;
            border-top: 1px solid var(--md-sys-color-outline-variant);
        }

        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* Center content vertically */
            text-decoration: none;
            color: var(--md-sys-color-on-surface-variant);
            font-size: 0.75rem; /* Smaller text */
            padding: 0.25rem 0.75rem;
            border-radius: var(--border-radius-medium);
            transition: all 0.3s ease;
            flex: 1; /* Distribute space */
            text-align: center;
            min-height: 56px; /* Standard height */
            position: relative; /* For indicator positioning */
             overflow: hidden; /* Hide overflow */
        }

        .nav-item .material-symbols-outlined {
            font-size: 1.75rem; /* Larger icon */
            margin-bottom: 2px;
            transition: font-variation-settings 0.3s ease;
        }
         .nav-item span { /* Label */
             display: block;
             line-height: 1.2;
             white-space: nowrap; /* Prevent label wrapping */
         }

        .nav-item.active {
            color: var(--md-sys-color-primary);
            font-weight: 500;
            transform: translateY(-4px); /* Solleva leggermente l'elemento attivo */
            transition: transform 0.3s ease, color 0.3s ease, font-weight 0.3s ease;
        }

        .nav-item {
            transition: transform 0.3s ease, color 0.3s ease, font-weight 0.3s ease;
        }

        .nav-item.active .material-symbols-outlined {
            font-variation-settings: 'FILL' 1, 'wght' 600; /* Fill active icon and make it bolder */
            font-size: 2rem; /* Icona più grande per l'elemento attivo */
            transition: font-variation-settings 0.3s ease, font-size 0.3s ease;
        }

        /* Indicatore per l'elemento attivo - sfondo più grande e visibile */
        .nav-item.active::before {
            content: '';
            display: block;
            width: 100%; /* Occupa tutta la larghezza dell'elemento */
            height: 32px; /* Più alto per maggiore visibilità */
            background-color: var(--md-sys-color-primary-container);
            border-radius: var(--border-radius-medium);
            position: absolute;
            top: 2px; /* Posizionato più in alto */
            left: 50%;
            transform: translateX(-50%);
            opacity: 0.9; /* Leggermente trasparente */
            transition: all 0.3s ease;
            z-index: -1;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Ombra leggera */
        }

        /* Bordo inferiore per l'elemento attivo */
        .nav-item.active::after {
            content: '';
            display: block;
            width: 60%;
            height: 3px;
            background-color: var(--md-sys-color-primary);
            border-radius: var(--border-radius-full);
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            transition: width 0.3s ease;
        }

        .nav-item::before { /* Hidden normally */
            content: '';
            display: block;
            width: 100%;
            height: 32px;
            background-color: var(--md-sys-color-primary-container);
            border-radius: var(--border-radius-medium);
            position: absolute;
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            z-index: -1;
            transition: all 0.3s ease;
        }

        /* Hover effect */
        .nav-item:hover::before {
            opacity: 0.3; /* Mostra leggermente lo sfondo in hover */
        }


        .nav-item:hover {
            color: var(--md-sys-color-on-surface);
        }


        /* Section Visibility with improved transitions */
        .section {
            display: none;
            animation: none;
        }
        .section.active {
            display: block;
            animation: fadeIn 0.5s ease forwards;
        }

        @keyframes fadeIn {
            0% { opacity: 0; transform: translateY(10px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        @keyframes fadeOut {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-10px); }
        }

        /* Aggiungiamo un indicatore di sezione nella parte superiore */
        .section.active::before {
            content: '';
            display: block;
            width: 50px;
            height: 4px;
            background-color: var(--md-sys-color-primary);
            border-radius: var(--border-radius-full);
            margin: -0.5rem auto 1rem auto;
        }

        /* Time Entries List */
        #timeEntries .time-entry {
            border-bottom: 1px solid var(--md-sys-color-outline-variant);
            padding: 1rem 0;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 1rem;
        }
        #timeEntries .time-entry:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        .time-entry-info {
            flex-grow: 1;
        }
        .time-entry-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.25rem;
        }
        .time-entry-date {
            font-weight: 500;
            color: var(--md-sys-color-primary);
        }
        .time-entry-hours {
            font-weight: 700;
            font-size: 1.1rem;
            color: var(--md-sys-color-secondary);
        }
        /* Codice duplicato rimosso */
        /* Material Design 3 Inspired Theme - Android 2025 */

        :root {
            /* Light Theme Palette (Material You - Teal/Blue Base) */
            --md-sys-color-primary: #006A6A;
            --md-sys-color-on-primary: #FFFFFF;
            --md-sys-color-primary-container: #9DF2F1;
            --md-sys-color-on-primary-container: #002020;
            --md-sys-color-secondary: #4A6363;
            --md-sys-color-on-secondary: #FFFFFF;
            --md-sys-color-secondary-container: #CCE8E7;
            --md-sys-color-on-secondary-container: #051F1F;
            --md-sys-color-tertiary: #4B607C;
            --md-sys-color-on-tertiary: #FFFFFF;
            --md-sys-color-tertiary-container: #D3E4FF;
            --md-sys-color-on-tertiary-container: #041C35;
            --md-sys-color-error: #BA1A1A;
            --md-sys-color-on-error: #FFFFFF;
            --md-sys-color-error-container: #FFDAD6;
            --md-sys-color-on-error-container: #410002;
            --md-sys-color-background: #FAFDFC;
            --md-sys-color-on-background: #191C1C;
            --md-sys-color-surface: #FAFDFC;
            --md-sys-color-on-surface: #191C1C;
            --md-sys-color-surface-variant: #DAE5E4;
            --md-sys-color-on-surface-variant: #3F4948;
            --md-sys-color-outline: #6F7979;
            --md-sys-color-outline-variant: #BFC9C8;
            --md-sys-color-shadow: #000000;
            --md-sys-color-scrim: #000000;
            --body-font-family: 'Roboto', sans-serif;
            --base-font-size: 16px;
            --border-radius-small: 8px;
            --border-radius-medium: 12px;
            --border-radius-large: 16px;
            --border-radius-full: 999px;
            --elevation-1: 0px 1px 2px rgba(0, 0, 0, 0.3), 0px 1px 3px 1px rgba(0, 0, 0, 0.15);
            --elevation-2: 0px 1px 2px rgba(0, 0, 0, 0.3), 0px 2px 6px 2px rgba(0, 0, 0, 0.15);
            --elevation-3: 0px 4px 8px 3px rgba(0, 0, 0, 0.15), 0px 1px 3px rgba(0, 0, 0, 0.3);
            --elevation-4: 0px 6px 10px 4px rgba(0, 0, 0, 0.15), 0px 2px 3px rgba(0, 0, 0, 0.3);
            --elevation-5: 0px 8px 12px 6px rgba(0, 0, 0, 0.15), 0px 4px 4px rgba(0, 0, 0, 0.3);
        }

        /* Dark Theme Palette */
        .dark-theme {
            --md-sys-color-primary: #81D5D4;
            --md-sys-color-on-primary: #003737;
            --md-sys-color-primary-container: #00504F;
            --md-sys-color-on-primary-container: #9DF2F1;
            --md-sys-color-secondary: #B0CCCB;
            --md-sys-color-on-secondary: #1C3534;
            --md-sys-color-secondary-container: #334B4B;
            --md-sys-color-on-secondary-container: #CCE8E7;
            --md-sys-color-tertiary: #B3C8E8;
            --md-sys-color-on-tertiary: #1D314B;
            --md-sys-color-tertiary-container: #344863;
            --md-sys-color-on-tertiary-container: #D3E4FF;
            --md-sys-color-error: #FFB4AB;
            --md-sys-color-on-error: #690005;
            --md-sys-color-error-container: #93000A;
            --md-sys-color-on-error-container: #FFDAD6;
            --md-sys-color-background: #191C1C;
            --md-sys-color-on-background: #E0E3E2;
            --md-sys-color-surface: #191C1C;
            --md-sys-color-on-surface: #E0E3E2;
            --md-sys-color-surface-variant: #3F4948;
            --md-sys-color-on-surface-variant: #BFC9C8;
            --md-sys-color-outline: #899392;
            --md-sys-color-outline-variant: #3F4948;
            /* Shadow and Scrim remain black */
            --md-sys-color-inverse-surface: #E0E3E2;
            --md-sys-color-inverse-on-surface: #191C1C;
            --md-sys-color-inverse-primary: #006A6A;
        }

        /* Global Styles */
        *, *::before, *::after {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            font-size: var(--base-font-size);
        }

        body {
            font-family: var(--body-font-family);
            background-color: var(--md-sys-color-background);
            color: var(--md-sys-color-on-background);
            line-height: 1.5;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            padding-bottom: 80px; /* Space for bottom nav */
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
        }

        /* Header */
        header {
            background-color: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
            box-shadow: var(--elevation-1);
            padding: 0.75rem 1rem;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 1000;
            border-bottom: 1px solid var(--md-sys-color-outline-variant);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
        }

        .logo img {
            max-height: 40px; /* Adjusted logo size */
            width: auto;
            display: block;
        }

        /* Animazione logo rimbalzante */
        @keyframes bounce-horizontal {
            0%, 100% {
                transform: translateX(0) rotate(0deg);
                animation-timing-function: cubic-bezier(0.8, 0, 1, 1);
            }
            25% {
                transform: translateX(15px) rotate(5deg);
                animation-timing-function: cubic-bezier(0, 0, 0.2, 1);
            }
            50% {
                transform: translateX(0) rotate(0deg);
                animation-timing-function: cubic-bezier(0.8, 0, 1, 1);
            }
            75% {
                transform: translateX(-15px) rotate(-5deg);
                animation-timing-function: cubic-bezier(0, 0, 0.2, 1);
            }
        }

        .bouncing-logo {
            animation: bounce-horizontal 2s infinite;
            transform-origin: center;
            cursor: pointer;
            transition: filter 0.3s ease;
        }

        .bouncing-logo:hover {
            filter: drop-shadow(0 0 5px var(--md-sys-color-primary));
            animation-play-state: paused;
        }

        /* Animazione più vivace quando l'utente clicca sul logo */
        @keyframes bounce-excited {
            0%, 100% {
                transform: translateX(0) rotate(0deg) scale(1);
                animation-timing-function: cubic-bezier(0.8, 0, 1, 1);
            }
            10% {
                transform: translateX(20px) rotate(10deg) scale(1.2);
            }
            20% {
                transform: translateX(-20px) rotate(-15deg) scale(1.1);
            }
            30% {
                transform: translateX(15px) rotate(15deg) scale(1.15);
            }
            40% {
                transform: translateX(-15px) rotate(-10deg) scale(1.05);
            }
            50% {
                transform: translateY(-15px) rotate(5deg) scale(1.1);
            }
            60% {
                transform: translateY(10px) rotate(-5deg) scale(1.05);
            }
            70% {
                transform: translateX(20px) translateY(-5px) rotate(10deg) scale(1.1);
            }
            80% {
                transform: translateX(-20px) translateY(5px) rotate(-10deg) scale(1.05);
            }
            90% {
                transform: translateX(10px) translateY(-3px) rotate(5deg) scale(1.02);
            }
        }

        .bouncing-logo-excited {
            animation: bounce-excited 2s ease-in-out;
            transform-origin: center;
            cursor: pointer;
            filter: drop-shadow(0 0 8px var(--md-sys-color-primary));
        }

        /* Stili per l'overlay della GIF del supereroe - Rimossi per ottimizzazione */

        .superhero-gif {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Riempie l'intero contenitore */
            object-position: center;
            display: block;
            margin: 0;
            border-radius: 0;
            box-shadow: none;
        }

        /* Stile specifico per desktop */
        @media (min-width: 1024px) {
            .superhero-container {
                width: 90%;
                max-width: 1200px;
                height: auto;
                max-height: 90vh;
            }

            .superhero-gif {
                object-fit: contain;
                border-radius: var(--border-radius-large);
                box-shadow: var(--elevation-5);
            }
        }

        .close-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background-color: var(--md-sys-color-error);
            color: var(--md-sys-color-on-error);
            border: none;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            box-shadow: var(--elevation-5);
            z-index: 10000;
            transition: all 0.3s ease;
            animation: pulse-animation 1.5s infinite;
            font-size: 1.5rem;
        }

        .close-btn .material-symbols-outlined {
            font-size: 30px;
            font-weight: bold;
        }

        .close-btn:hover, .close-btn:active {
            background-color: #d32f2f;
            transform: scale(1.1);
            animation-play-state: paused;
        }

        /* Stile per il messaggio RIP */
        .rip-message {
            position: fixed;
            top: 0;
            left: 50%; /* Posizionato al centro */
            transform: translateX(-50%) translateY(-100%); /* Inizialmente fuori dallo schermo */
            background-color: #000000;
            color: #ffffff;
            padding: 10px 15px;
            border-radius: 0 0 var(--border-radius-medium) var(--border-radius-medium);
            box-shadow: var(--elevation-3);
            z-index: 1001; /* Sopra l'header ma sotto il pulsante di chiusura */
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: transform 0.5s ease;
            font-weight: bold;
            min-width: 200px;
            text-align: center;
        }

        .rip-message.visible {
            transform: translateX(-50%) translateY(0); /* Scende dall'alto */
        }

        .rip-message::before {
            content: "☠️";
            font-size: 1.2rem;
        }

        .rip-message::after {
            content: "☠️";
            font-size: 1.2rem;
        }

        /* Animazione principale per il pulsante che scappa - stile cartoon */
        @keyframes escape-animation {
            0% { transform: translate(0, 0) scale(1) rotate(0deg); filter: brightness(1); }
            10% { transform: translate(-40px, -30px) scale(1.3) rotate(-15deg); filter: brightness(1.2); }
            20% { transform: translate(35px, 45px) scale(0.7) rotate(20deg); filter: brightness(0.9); }
            30% { transform: translate(50px, 60px) scale(1.4) rotate(-25deg); filter: brightness(1.3); }
            40% { transform: translate(-45px, -55px) scale(0.6) rotate(30deg); filter: brightness(0.8); }
            50% { transform: translate(60px, 20px) scale(1.2) rotate(-35deg); filter: brightness(1.4); }
            60% { transform: translate(-55px, 50px) scale(0.8) rotate(40deg); filter: brightness(0.7); }
            70% { transform: translate(40px, -40px) scale(1.5) rotate(-45deg); filter: brightness(1.5); }
            80% { transform: translate(-60px, -25px) scale(0.7) rotate(50deg); filter: brightness(0.9); }
            90% { transform: translate(50px, 55px) scale(1.3) rotate(-55deg); filter: brightness(1.3); }
            100% { transform: translate(0, 0) scale(1) rotate(0deg); filter: brightness(1); }
        }

        /* Animazione per l'effetto di squash e stretch */
        @keyframes squash-stretch {
            0%, 100% { transform: scale(1, 1); }
            25% { transform: scale(1.3, 0.7); }
            50% { transform: scale(0.7, 1.3); }
            75% { transform: scale(1.1, 0.9); }
        }

        /* Animazione per l'effetto di vibrazione */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px) rotate(-2deg); }
            20%, 40%, 60%, 80% { transform: translateX(5px) rotate(2deg); }
        }

        /* Classe per il pulsante che scappa */
        .escaping {
            animation: escape-animation 0.4s infinite;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.7);
            transition: all 0.1s ease;
            z-index: 10000;
            position: fixed !important;
        }

        /* Effetto hover sul pulsante che scappa */
        .escaping:hover {
            animation-duration: 0.2s !important;
            filter: hue-rotate(180deg) brightness(1.5);
        }

        /* Animazione di morte per il pulsante */
        @keyframes button-death {
            0% { transform: scale(1) rotate(0deg); opacity: 1; filter: brightness(1); box-shadow: 0 0 20px red; }
            10% { transform: scale(1.5) rotate(10deg); opacity: 0.9; filter: brightness(1.5) hue-rotate(30deg); box-shadow: 0 0 30px orange; }
            20% { transform: scale(0.8) rotate(-15deg); opacity: 0.8; filter: brightness(0.8) hue-rotate(60deg); box-shadow: 0 0 40px yellow; }
            30% { transform: scale(1.3) rotate(20deg); opacity: 0.7; filter: brightness(1.3) hue-rotate(90deg); box-shadow: 0 0 50px green; }
            40% { transform: scale(0.7) rotate(-25deg); opacity: 0.6; filter: brightness(0.7) hue-rotate(120deg); box-shadow: 0 0 60px blue; }
            50% { transform: scale(1.2) rotate(30deg); opacity: 0.5; filter: brightness(1.2) hue-rotate(150deg); box-shadow: 0 0 70px indigo; }
            60% { transform: scale(0.6) rotate(-35deg); opacity: 0.4; filter: brightness(0.6) hue-rotate(180deg); box-shadow: 0 0 80px violet; }
            70% { transform: scale(1.1) rotate(40deg); opacity: 0.3; filter: brightness(1.1) hue-rotate(210deg); box-shadow: 0 0 90px red; }
            80% { transform: scale(0.5) rotate(-45deg); opacity: 0.2; filter: brightness(0.5) hue-rotate(240deg); box-shadow: 0 0 100px orange; }
            90% { transform: scale(0.3) rotate(50deg); opacity: 0.1; filter: brightness(0.3) hue-rotate(270deg); box-shadow: 0 0 110px yellow; }
            100% { transform: scale(0) rotate(360deg); opacity: 0; filter: brightness(0) hue-rotate(360deg); box-shadow: 0 0 120px white; }
        }

        .dying-button {
            animation: button-death 2s forwards !important;
            position: fixed !important;
            z-index: 10000 !important;
            pointer-events: none !important;
            /* Assicurati che non ci siano altre animazioni in esecuzione */
            transform-origin: center !important;
            will-change: transform, opacity, filter, box-shadow !important;
        }

        /* Stile per evidenziare il pulsante di login */
        @keyframes highlight-pulse {
            0% { box-shadow: 0 0 0 0 rgba(0, 106, 106, 0.7); transform: scale(1); }
            50% { box-shadow: 0 0 0 10px rgba(0, 106, 106, 0); transform: scale(1.05); }
            100% { box-shadow: 0 0 0 0 rgba(0, 106, 106, 0); transform: scale(1); }
        }

        .highlight-button {
            animation: highlight-pulse 1.5s infinite;
            box-shadow: 0 0 10px var(--md-sys-color-primary);
            position: relative;
            z-index: 100;
        }

        @keyframes pulse-animation {
            0% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(255, 82, 82, 0.7);
            }
            70% {
                transform: scale(1.1);
                box-shadow: 0 0 0 10px rgba(255, 82, 82, 0);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(255, 82, 82, 0);
            }
        }

        /* Stili per dispositivi mobili */
        @media (max-width: 768px) {
            .close-btn {
                top: 15px;
                right: 15px;
                width: 45px;
                height: 45px;
            }

            .close-btn .material-symbols-outlined {
                font-size: 24px;
            }
        }
        /* Removed troll-related JavaScript functionality */
        /* Removed troll-related event listeners and functions */

        main {
            padding: 1rem;
            margin-top: 70px; /* Adjusted for header height */
        }

        /* Card */
        .card {
            background-color: var(--md-sys-color-surface-variant); /* Slightly different bg */
            color: var(--md-sys-color-on-surface-variant);
            border-radius: var(--border-radius-large);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: var(--elevation-1);
            border: 1px solid var(--md-sys-color-outline-variant);
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
        }

        .card h2, .card h3 {
            color: var(--md-sys-color-primary);
            margin-bottom: 1rem;
            font-weight: 500;
        }

        /* Forms */
        .form-group {
            margin-bottom: 1.25rem;
        }

        label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            font-size: 0.875rem;
            color: var(--md-sys-color-on-surface-variant);
        }

        input[type="text"],
        input[type="number"],
        input[type="email"],
        input[type="tel"],
        textarea,
        select {
            width: 100%;
            padding: 0.875rem 1rem;
            border: 1px solid var(--md-sys-color-outline);
            border-radius: var(--border-radius-small);
            font-size: 1rem;
            background-color: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            appearance: none; /* For select */
            -webkit-appearance: none;
        }

        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--md-sys-color-primary);
            box-shadow: 0 0 0 2px var(--md-sys-color-primary-container);
        }

        select {
             /* Add arrow for select */
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' height='24' viewBox='0 -960 960 960' width='24'%3E%3Cpath d='M480-345 240-585l56-56 184 184 184-184 56 56-240 240Z' fill='%23${(getComputedStyle(document.documentElement).getPropertyValue('--md-sys-color-on-surface').trim() || '#191C1C').substring(1)}'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 1rem center;
            background-size: 1.5em;
            padding-right: 3rem; /* Space for arrow */
        }
        .dark-theme select {
             background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' height='24' viewBox='0 -960 960 960' width='24'%3E%3Cpath d='M480-345 240-585l56-56 184 184 184-184 56 56-240 240Z' fill='%23${(getComputedStyle(document.documentElement).getPropertyValue('--md-sys-color-on-surface').trim() || '#E0E3E2').substring(1)}'/%3E%3C/svg%3E");
        }


        textarea {
            min-height: 100px;
            resize: vertical;
        }

        .form-row {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .form-group-inline {
            flex: 1;
            min-width: 120px;
        }

        /* Buttons */
        button, .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: var(--border-radius-full); /* Pill shape */
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            transition: background-color 0.2s ease, box-shadow 0.2s ease, transform 0.1s ease;
            box-shadow: var(--elevation-1);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        button:hover, .btn:hover {
            box-shadow: var(--elevation-2);
        }

        button:active, .btn:active {
            transform: scale(0.98);
            box-shadow: none;
        }

        /* Filled Button (Primary Action) */
        button[type="submit"], #submitBtn, #saveUserName, #addVehicle, #exportData, #importData, #saveFerieMalattie, .export-btn, .edit-all-btn, #addEntryBtn {
            background-color: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
        }
        button[type="submit"]:hover, #submitBtn:hover, #saveUserName:hover, #addVehicle:hover, #exportData:hover, #importData:hover, #saveFerieMalattie:hover, .export-btn:hover, .edit-all-btn:hover, #addEntryBtn:hover {
             /* Slightly darker/lighter on hover - generate this if needed */
            filter: brightness(90%);
        }
        .dark-theme button[type="submit"]:hover, .dark-theme #submitBtn:hover, .dark-theme #saveUserName:hover, .dark-theme #addVehicle:hover, .dark-theme #exportData:hover, .dark-theme #importData:hover, .dark-theme #saveFerieMalattie:hover, .dark-theme .export-btn:hover, .dark-theme .edit-all-btn:hover, .dark-theme #addEntryBtn:hover {
            filter: brightness(110%);
        }

        /* Error/Destructive Button */
        #clearData, .delete-btn, .delete-ferie-btn, .delete-vehicle-btn {
            background-color: var(--md-sys-color-error);
            color: var(--md-sys-color-on-error);
        }
         #clearData:hover, .delete-btn:hover, .delete-ferie-btn:hover, .delete-vehicle-btn:hover {
            filter: brightness(90%);
        }
        .dark-theme #clearData:hover, .dark-theme .delete-btn:hover, .dark-theme .delete-ferie-btn:hover, .dark-theme .delete-vehicle-btn:hover {
            filter: brightness(110%);
        }


        /* Text Button (e.g., Cancel) */
        .form-buttons button:last-child, .close-modal {
             background-color: transparent;
             color: var(--md-sys-color-primary);
             box-shadow: none;
        }
         .form-buttons button:last-child:hover, .close-modal:hover {
            background-color: var(--md-sys-color-primary-container);
         }
        .close-modal { /* Specific style for modal close */
             font-size: 1.75rem;
             padding: 0.5rem;
             border-radius: 50%;
             line-height: 1;
             color: var(--md-sys-color-on-surface-variant);
             font-weight: normal;
             border: none; /* Ensure no border */
        }
        .close-modal:hover {
            color: var(--md-sys-color-on-primary-container);
        }


        /* Small Action Buttons (Edit/Delete in lists) */
        .edit-btn, .delete-btn {
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            min-width: 36px;
            min-height: 36px;
            box-shadow: none;
            border-radius: var(--border-radius-small);
            text-transform: none;
            letter-spacing: normal;
            border: 1px solid transparent; /* Base border */
        }
        .edit-btn { /* Make edit look like an Outlined Button */
            background-color: transparent;
            color: var(--md-sys-color-primary);
            border-color: var(--md-sys-color-outline);
        }
        .edit-btn:hover {
             background-color: var(--md-sys-color-primary-container);
             border-color: var(--md-sys-color-primary-container);
        }
        .delete-btn {
            background-color: var(--md-sys-color-error-container);
            color: var(--md-sys-color-on-error-container);
        }
        .delete-btn:hover {
            filter: brightness(95%);
            background-color: var(--md-sys-color-error-container); /* Keep bg */
        }
         .dark-theme .delete-btn:hover {
            filter: brightness(110%);
         }

        /* Material Symbols */
        .material-symbols-outlined {
          font-variation-settings:
          'FILL' 0,
          'wght' 400,
          'GRAD' 0,
          'opsz' 24;
          vertical-align: middle; /* Align icons better with text */
          font-size: 1.25em; /* Slightly larger default size */
          line-height: 1; /* Prevent extra space */
        }

        /* Bottom Navigation */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: var(--md-sys-color-surface-variant); /* Navigation Rail style */
            box-shadow: 0 -2px 5px rgba(0,0,0,0.1);
            padding: 0.5rem 0;
            display: flex;
            justify-content: space-around;
            align-items: stretch; /* Stretch items vertically */
            z-index: 1000;
            border-top: 1px solid var(--md-sys-color-outline-variant);
        }

        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* Center content vertically */
            text-decoration: none;
            color: var(--md-sys-color-on-surface-variant);
            font-size: 0.75rem; /* Smaller text */
            padding: 0.25rem 0.75rem;
            border-radius: var(--border-radius-medium);
            transition: all 0.3s ease;
            flex: 1; /* Distribute space */
            text-align: center;
            min-height: 56px; /* Standard height */
            position: relative; /* For indicator positioning */
             overflow: hidden; /* Hide overflow */
        }

        .nav-item .material-symbols-outlined {
            font-size: 1.75rem; /* Larger icon */
            margin-bottom: 2px;
            transition: font-variation-settings 0.3s ease;
        }
         .nav-item span { /* Label */
             display: block;
             line-height: 1.2;
             white-space: nowrap; /* Prevent label wrapping */
         }

        .nav-item.active {
            color: var(--md-sys-color-primary);
            font-weight: 500;
            transform: translateY(-4px); /* Solleva leggermente l'elemento attivo */
            transition: transform 0.3s ease, color 0.3s ease, font-weight 0.3s ease;
        }

        .nav-item {
            transition: transform 0.3s ease, color 0.3s ease, font-weight 0.3s ease;
        }

        .nav-item.active .material-symbols-outlined {
            font-variation-settings: 'FILL' 1, 'wght' 600; /* Fill active icon and make it bolder */
            font-size: 2rem; /* Icona più grande per l'elemento attivo */
            transition: font-variation-settings 0.3s ease, font-size 0.3s ease;
        }

        /* Indicatore per l'elemento attivo - sfondo più grande e visibile */
        .nav-item.active::before {
            content: '';
            display: block;
            width: 100%; /* Occupa tutta la larghezza dell'elemento */
            height: 32px; /* Più alto per maggiore visibilità */
            background-color: var(--md-sys-color-primary-container);
            border-radius: var(--border-radius-medium);
            position: absolute;
            top: 2px; /* Posizionato più in alto */
            left: 50%;
            transform: translateX(-50%);
            opacity: 0.9; /* Leggermente trasparente */
            transition: all 0.3s ease;
            z-index: -1;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); /* Ombra leggera */
        }

        /* Bordo inferiore per l'elemento attivo */
        .nav-item.active::after {
            content: '';
            display: block;
            width: 60%;
            height: 3px;
            background-color: var(--md-sys-color-primary);
            border-radius: var(--border-radius-full);
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            transition: width 0.3s ease;
        }

        .nav-item::before { /* Hidden normally */
            content: '';
            display: block;
            width: 100%;
            height: 32px;
            background-color: var(--md-sys-color-primary-container);
            border-radius: var(--border-radius-medium);
            position: absolute;
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            z-index: -1;
            transition: all 0.3s ease;
        }

        /* Hover effect */
        .nav-item:hover::before {
            opacity: 0.3; /* Mostra leggermente lo sfondo in hover */
        }


        .nav-item:hover {
            color: var(--md-sys-color-on-surface);
        }


        /* Section Visibility with improved transitions */
        .section {
            display: none;
            animation: none;
        }
        .section.active {
            display: block;
            animation: fadeIn 0.5s ease forwards;
        }

        @keyframes fadeIn {
            0% { opacity: 0; transform: translateY(10px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        @keyframes fadeOut {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-10px); }
        }

        /* Aggiungiamo un indicatore di sezione nella parte superiore */
        .section.active::before {
            content: '';
            display: block;
            width: 50px;
            height: 4px;
            background-color: var(--md-sys-color-primary);
            border-radius: var(--border-radius-full);
            margin: -0.5rem auto 1rem auto;
        }

        /* Time Entries List */
        #timeEntries .time-entry {
            border-bottom: 1px solid var(--md-sys-color-outline-variant);
            padding: 1rem 0;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 1rem;
        }
        #timeEntries .time-entry:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        .time-entry-info {
            flex-grow: 1;
        }
        .time-entry-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.25rem;
        }
        .time-entry-date {
            font-weight: 500;
            color: var(--md-sys-color-primary);
        }
        .time-entry-hours {
            font-weight: 700;
            font-size: 1.1rem;
            color: var(--md-sys-color-secondary);
        }
        .time-entry-details {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            margin: 0.25rem 0;
            font-size: 0.8rem;
            color: var(--md-sys-color-on-surface-variant);
        }
        .time-entry-details span {
            background-color: var(--md-sys-color-surface);
            padding: 2px 8px;
            border-radius: var(--border-radius-small);
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        .time-entry-details .material-symbols-outlined {
            font-size: 1em;
            color: var(--md-sys-color-secondary);
        }
        .time-entry-description {
            font-size: 0.9rem;
            color: var(--md-sys-color-on-surface-variant);
            margin-top: 0.25rem;
        }

        /* Stili per le righe di lavoro multiple */
        #work-descriptions-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 8px;
        }

        .work-description-row {
            display: flex;
            align-items: center;
        }

        .work-description-input {
            flex: 1;
        }

        .btn-remove-work {
            background: none;
            border: none;
            color: var(--md-sys-color-error);
            cursor: pointer;
            padding: 4px;
            margin-left: 8px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-remove-work:hover {
            background-color: rgba(186, 26, 26, 0.1);
        }

        .btn-add-work {
            background-color: var(--md-sys-color-surface-variant);
            color: var(--md-sys-color-primary);
            border: 1px dashed var(--md-sys-color-outline);
            padding: 8px 16px;
            border-radius: var(--border-radius-small);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            margin-top: 8px;
            font-size: 0.9rem;
        }

        .btn-add-work:hover {
            background-color: var(--md-sys-color-primary-container);
        }
        .entry-buttons {
            display: flex;
            gap: 0.5rem;
            flex-shrink: 0; /* Prevent buttons from shrinking */
        }


        /* Settings */
        .settings-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background-color: var(--md-sys-color-surface);
            border: 1px solid var(--md-sys-color-outline-variant);
            border-radius: var(--border-radius-medium);
            flex-wrap: wrap; /* Wrap for smaller screens if needed */
        }
        .setting-label {
            font-weight: 500;
             margin-right: 1rem;
             margin-bottom: 0.5rem; /* Add space when wrapping */
             flex-shrink: 0;
        }
        .settings-input {
            flex-grow: 1;
            min-width: 150px; /* Prevent input becoming too small */
             margin-right: 0.5rem; /* Space before button */
        }
        .setting-item > button {
            flex-shrink: 0; /* Prevent button shrinking */
        }
        .setting-item .vehicles-manager { /* Full width for vehicle manager */
            width: 100%;
            margin-top: 0.5rem; /* Space when it's below label */
        }

        /* Stili per il controllo delle particelle */
        .toggle-button {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            background-color: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
            border-radius: var(--border-radius-full);
            padding: 0.5rem 1rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .toggle-button:hover {
            background-color: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
        }

        .particle-control-panel {
            width: 100%;
            margin-top: 1rem;
            padding: 1.5rem;
            background-color: var(--md-sys-color-surface);
            border: 1px solid var(--md-sys-color-outline-variant);
            border-radius: var(--border-radius-medium);
            box-shadow: var(--elevation-1);
        }

        .particle-control-group {
            margin-bottom: 1.5rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--md-sys-color-outline-variant);
        }

        .particle-control-group:last-of-type {
            border-bottom: none;
            padding-bottom: 0;
        }

        .particle-control-group h3 {
            margin-bottom: 1rem;
            color: var(--md-sys-color-primary);
            font-size: 1.1rem;
            font-weight: 500;
        }

        .particle-control-item {
            margin-bottom: 1rem;
        }

        .particle-control-item label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            font-size: 0.9rem;
        }

        .particle-control-item input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: var(--md-sys-color-surface-variant);
            border-radius: var(--border-radius-full);
            outline: none;
        }

        .particle-control-item input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--md-sys-color-primary);
            cursor: pointer;
            box-shadow: var(--elevation-1);
        }

        .particle-control-item input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--md-sys-color-primary);
            cursor: pointer;
            box-shadow: var(--elevation-1);
            border: none;
        }

        .particle-control-item select {
            width: 100%;
            padding: 0.5rem;
            border-radius: var(--border-radius-small);
            border: 1px solid var(--md-sys-color-outline-variant);
            background-color: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
        }

        .color-picker-container {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-wrap: wrap;
        }

        .color-picker-container input[type="color"] {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: var(--border-radius-small);
            cursor: pointer;
            padding: 0;
            background: none;
        }

        .small-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--md-sys-color-surface-variant);
            color: var(--md-sys-color-on-surface-variant);
            cursor: pointer;
            border: 1px solid var(--md-sys-color-outline-variant);
            padding: 0;
        }

        .small-btn:hover {
            background-color: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
        }

        .particle-control-actions {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
            margin-top: 1rem;
        }

        .secondary-btn {
            background-color: var(--md-sys-color-surface-variant);
            color: var(--md-sys-color-on-surface-variant);
        }

        .primary-btn {
            background-color: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
        }


        /* Toggle Switch (Material Style) */
        .toggle-switch {
            --switch-width: 52px;
            --switch-height: 32px;
            --thumb-size: 24px;
            --track-padding: 4px;

            position: relative;
            display: inline-block;
            width: var(--switch-width);
            height: var(--switch-height);
            flex-shrink: 0;
        }

        /* Stili per i controlli di tempo con frecce */
        .time-input-container {
            display: flex;
            align-items: center;
            width: 100%;
        }

        .time-control-btn {
            background-color: var(--md-sys-color-surface-variant);
            color: var(--md-sys-color-on-surface-variant);
            border: 1px solid var(--md-sys-color-outline-variant);
            border-radius: var(--border-radius-small);
            width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease;
            flex-shrink: 0;
        }

        .time-control-btn:hover {
            background-color: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
        }

        .time-control-btn:active {
            transform: scale(0.95);
        }

        .time-input-container input {
            flex: 1;
            margin: 0 5px;
            text-align: center;
        }


        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--md-sys-color-surface-variant);
            border: 2px solid var(--md-sys-color-outline);
            transition: all .3s ease;
            border-radius: var(--switch-height); /* Fully rounded */
        }
        .toggle-slider:before { /* The Thumb */
            position: absolute;
            content: "";
            height: var(--thumb-size);
            width: var(--thumb-size);
            left: var(--track-padding);
            bottom: var(--track-padding);
            background-color: var(--md-sys-color-outline);
            transition: all .3s ease;
            border-radius: 50%;
            box-shadow: var(--elevation-1);
        }
        input:checked + .toggle-slider {
            background-color: var(--md-sys-color-primary);
            border-color: var(--md-sys-color-primary);
        }
        input:checked + .toggle-slider:before {
            background-color: var(--md-sys-color-on-primary);
            transform: translateX(calc(var(--switch-width) - var(--thumb-size) - 2 * var(--track-padding) - 4px)); /* Adjust 4px for border */
        }


        /* Calendar Styles */
        .calendar-container {
            margin-top: 1rem;
        }
        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            background-color: rgba(0, 0, 0, 0.2) !important;
            color: white;
            padding: 0.75rem 1rem;
            border-radius: var(--border-radius-medium) var(--border-radius-medium) 0 0;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .dark-theme .calendar-header {
            background-color: rgba(255, 255, 255, 0.1) !important;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        .calendar-header button {
            background: none;
            border: none;
            font-size: 1.5rem; /* Icon size */
            cursor: pointer;
            color: white !important;
            padding: 0.5rem;
            border-radius: 50%;
            line-height: 1;
            display: inline-flex; /* Align icon */
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        .calendar-header button:hover {
            background-color: rgba(255,255,255,0.2);
            transform: scale(1.1);
        }
         .dark-theme .calendar-header button:hover {
              background-color: rgba(255,255,255,0.2);
              transform: scale(1.1);
         }

        .calendar-title {
            display: flex;
            align-items: baseline;
            gap: 0.5rem;
            font-weight: 500;
            text-align: center;
            flex-grow: 1;
            justify-content: center;
        }
        .calendar-month {
            font-size: 1.25rem;
            color: white !important;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        .calendar-year {
            font-size: 1rem;
            opacity: 0.9;
            color: white !important;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }
        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 1px; /* Thin lines between days */
            background-color: var(--md-sys-color-outline-variant); /* Grid lines */
            border: 1px solid var(--md-sys-color-outline-variant);
            border-radius: 0 0 var(--border-radius-medium) var(--border-radius-medium);
            overflow: hidden;
        }
        .calendar-weekday {
            text-align: center;
            font-weight: 500;
            padding: 0.75rem 0.25rem;
            background-color: var(--md-sys-color-surface-variant);
            color: var(--md-sys-color-on-surface-variant);
            font-size: 0.8rem;
            text-transform: uppercase;
        }
        .calendar-day {
            min-height: 90px;
            padding: 8px;
            position: relative;
            cursor: pointer;
            transition: background-color 0.2s;
            background-color: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            text-align: center;
        }
        .calendar-day:hover {
            background-color: var(--md-sys-color-inverse-surface); /* Use inverse for hover */
            color: var(--md-sys-color-inverse-on-surface);
        }
        .calendar-day.empty {
            background-color: var(--md-sys-color-surface-variant);
            opacity: 0.5;
            cursor: default;
        }
        .calendar-day.empty:hover {
            background-color: var(--md-sys-color-surface-variant);
        }
        .calendar-day.today {
             /* Use outline instead of border */
             outline: 2px solid var(--md-sys-color-primary);
             outline-offset: -2px;
        }
        /* Style day with entries */
        .calendar-day.has-entries .calendar-day-number {
             font-weight: 700;
             color: var(--md-sys-color-primary);
        }
        .calendar-day-number {
            font-weight: 500;
            font-size: 0.875rem;
            width: 24px;
            height: 24px;
            line-height: 24px;
            border-radius: 50%;
            position: absolute;
            top: 4px;
            left: 4px;
            text-align: center;
             z-index: 1; /* Above content */
        }
        .calendar-day.today .calendar-day-number {
            background-color: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
        }
        .calendar-day-content {
            margin-top: 28px; /* Space below number */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            width: 100%;
        }
        .calendar-hours {
            font-size: 1rem;
            font-weight: 700;
            color: var(--md-sys-color-primary);
        }
        .calendar-icons {
            display: flex;
            justify-content: center;
             flex-wrap: wrap; /* Wrap icons if needed */
            gap: 4px;
            font-size: 1rem;
            line-height: 1; /* Prevent extra spacing */
        }
        .calendar-icons .material-symbols-outlined {
             font-size: 1.1em;
             color: var(--md-sys-color-secondary);
        }

        /* Stile per l'icona info */
        .info-icon {
            display: inline-block;
            width: 24px;
            height: 24px;
            line-height: 24px;
            text-align: center;
            border-radius: 50%;
            background-color: var(--md-sys-color-tertiary);
            color: var(--md-sys-color-on-tertiary);
            font-weight: bold;
            font-style: italic;
            font-size: 1rem;
            margin-bottom: 0.25rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            animation: pulse-info 2s infinite;
        }

        @keyframes pulse-info {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        .calendar-holiday-name {
            font-size: 0.75rem;
            color: var(--md-sys-color-error);
            font-weight: 500;
            margin-top: auto; /* Push to bottom */
            padding-top: 4px;
             width: 100%; /* Take full width */
        }
         .calendar-day.holiday {
             background-color: var(--md-sys-color-error-container);
             color: var(--md-sys-color-on-error-container);
             outline: none; /* Remove today outline if holiday */
         }
         .calendar-day.holiday .calendar-day-number {
            background-color: var(--md-sys-color-error);
            color: var(--md-sys-color-on-error);
         }
         .calendar-day.holiday .calendar-holiday-name {
             color: var(--md-sys-color-on-error-container); /* Match text color */
         }

          .calendar-day.ferie {
             background-color: var(--md-sys-color-tertiary-container);
             color: var(--md-sys-color-on-tertiary-container);
             outline: none;
          }
           .calendar-day.ferie .calendar-icons .material-symbols-outlined {
               color: var(--md-sys-color-on-tertiary-container);
           }
            .calendar-day.ferie .calendar-holiday-name {
               color: var(--md-sys-color-on-tertiary-container);
           }

          .calendar-day.malattia {
             background-color: var(--md-sys-color-secondary-container);
             color: var(--md-sys-color-on-secondary-container);
             outline: none;
          }
            .calendar-day.malattia .calendar-icons .material-symbols-outlined {
               color: var(--md-sys-color-on-secondary-container);
           }
             .calendar-day.malattia .calendar-holiday-name {
               color: var(--md-sys-color-on-secondary-container);
           }
                   /* Calendar Share Styles */
        .calendar-share-container {
            margin-bottom: 1rem;
            display: flex;
            justify-content: center;
        }

        .calendar-share-btn {
            background-color: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: var(--border-radius-full);
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.2s ease;
            box-shadow: var(--elevation-2);
            min-width: 120px;
            justify-content: center;
        }

        .calendar-share-btn:hover {
            background-color: var(--md-sys-color-primary);
            transform: translateY(-1px);
            box-shadow: var(--elevation-3);
        }

        .calendar-share-btn.success {
            background-color: #4CAF50;
            color: white;
        }

        .calendar-share-btn.success:hover {
            background-color: #45a049;
        }

        /* Calendar Paste Button */
        .calendar-buttons-container {
            margin-bottom: 1rem;
            display: flex;
            justify-content: center;
            gap: 0.75rem;
            flex-wrap: wrap;
        }

        .calendar-paste-btn {
            background-color: var(--md-sys-color-secondary);
            color: var(--md-sys-color-on-secondary);
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: var(--border-radius-large);
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.3s ease;
            box-shadow: var(--elevation-1);
            min-width: 120px;
            justify-content: center;
        }

        .calendar-paste-btn:hover {
            background-color: var(--md-sys-color-secondary-container);
            color: var(--md-sys-color-on-secondary-container);
            box-shadow: var(--elevation-2);
            transform: translateY(-1px);
        }

        .calendar-paste-btn:active {
            transform: translateY(0);
            box-shadow: var(--elevation-1);
        }

        .calendar-paste-btn.processing {
            background-color: #FF9800;
            color: white;
        }

        .calendar-paste-btn.processing:hover {
            background-color: #F57C00;
        }

        .calendar-paste-btn.success {
            background-color: #4CAF50;
            color: white;
        }

        .calendar-paste-btn.success:hover {
            background-color: #45a049;
        }

        .calendar-paste-btn.error {
            background-color: var(--md-sys-color-error);
            color: var(--md-sys-color-on-error);
        }

        .calendar-paste-btn.error:hover {
            background-color: var(--md-sys-color-error-container);
            color: var(--md-sys-color-on-error-container);
        }

        /* Import Preview Modal */
        .import-preview-modal {
            display: none;
            position: fixed;
            z-index: 1100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.5);
            animation: fadeIn 0.3s ease;
        }

        .import-preview-content {
            background-color: var(--md-sys-color-surface);
            margin: 5% auto;
            padding: 1.5rem;
            border-radius: var(--border-radius-large);
            box-shadow: var(--elevation-5);
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .import-preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--md-sys-color-outline-variant);
        }

        .import-preview-title {
            color: var(--md-sys-color-on-surface);
            font-size: 1.25rem;
            font-weight: 500;
            margin: 0;
        }

        .import-close-btn {
            background: none;
            border: none;
            color: var(--md-sys-color-on-surface);
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .import-close-btn:hover {
            background-color: var(--md-sys-color-surface-variant);
        }

        .import-preview-body {
            margin-bottom: 1.5rem;
        }

        .import-summary {
            background-color: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
            padding: 1rem;
            border-radius: var(--border-radius-medium);
            margin-bottom: 1rem;
        }

        .import-entries-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--md-sys-color-outline-variant);
            border-radius: var(--border-radius-medium);
            padding: 0.5rem;
        }

        .import-entry-item {
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            background-color: var(--md-sys-color-surface-variant);
            border-radius: var(--border-radius-small);
            border-left: 4px solid var(--md-sys-color-primary);
        }

        .import-entry-date {
            font-weight: 500;
            color: var(--md-sys-color-primary);
            margin-bottom: 0.25rem;
        }

        .import-entry-details {
            font-size: 0.875rem;
            color: var(--md-sys-color-on-surface-variant);
        }

        .import-preview-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
            flex-wrap: wrap;
        }

        .import-action-btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: var(--border-radius-medium);
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            min-width: 100px;
        }

        .import-btn-cancel {
            background-color: var(--md-sys-color-surface-variant);
            color: var(--md-sys-color-on-surface-variant);
        }

        .import-btn-cancel:hover {
            background-color: var(--md-sys-color-outline-variant);
        }

        .import-btn-replace {
            background-color: var(--md-sys-color-error);
            color: var(--md-sys-color-on-error);
        }

        .import-btn-replace:hover {
            background-color: var(--md-sys-color-error-container);
            color: var(--md-sys-color-on-error-container);
        }

        .import-btn-merge {
            background-color: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
        }

        .import-btn-merge:hover {
            background-color: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
        }

        .calendar-day-checkbox {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 20px;
            height: 20px;
            cursor: pointer;
            display: none;
        }

        .calendar-day-checkbox input[type="checkbox"] {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            height: 0;
            width: 0;
        }

        .calendar-day-checkbox .checkmark {
            position: absolute;
            top: 0;
            left: 0;
            height: 20px;
            width: 20px;
            background-color: rgba(255, 255, 255, 0.9);
            border: 2px solid var(--md-sys-color-outline);
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .calendar-day-checkbox input:checked ~ .checkmark {
            background-color: var(--md-sys-color-primary);
            border-color: var(--md-sys-color-primary);
        }

        .calendar-day-checkbox .checkmark::after {
            content: "";
            position: absolute;
            display: none;
        }

        .calendar-day-checkbox input:checked ~ .checkmark::after {
            display: block;
        }

        .calendar-day-checkbox .checkmark::after {
            left: 6px;
            top: 2px;
            width: 4px;
            height: 8px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }

        .calendar-day.selectable {
            position: relative;
            cursor: pointer;
        }

        .calendar-day.selectable:hover .calendar-day-checkbox {
            display: block;
        }

        .calendar-day.selected {
            background-color: var(--md-sys-color-primary-container);
            border: 2px solid var(--md-sys-color-primary);
        }

        .calendar-day.selected .calendar-day-checkbox {
            display: block;
        }

        .calendar-selection-mode .calendar-day.selectable .calendar-day-checkbox {
            display: block;
        }

        .calendar-selection-mode .calendar-day.selectable {
            cursor: pointer;
        }

        .calendar-selection-mode .calendar-day:not(.selectable) {
            opacity: 0.5;
        }


        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1050; /* Above nav */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: var(--md-sys-color-scrim); /* Scrim */
            background-color: rgba(0, 0, 0, 0.5); /* Fallback */
            animation: fadeIn 0.3s ease;
            padding: 1rem; /* Padding for scroll */
            visibility: visible; /* Assicura che il modale sia visibile quando display è 'block' */
        }
        .modal-content {
            background-color: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
            margin: 5vh auto; /* Vertically centered */
            padding: 1.5rem;
            border: none;
            width: 95%;
            max-width: 600px;
            border-radius: var(--border-radius-large);
            box-shadow: var(--elevation-4);
            animation: slideIn 0.3s ease-out;
        }
        @keyframes slideIn {
            from { transform: translateY(-30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
        }
        .modal-title {
            font-size: 1.5rem;
            font-weight: 500;
            color: var(--md-sys-color-primary);
        }
        .modal-body {
            margin-bottom: 1.5rem;
        }
        .modal-footer {
            text-align: right;
            padding-top: 1rem;
            border-top: 1px solid var(--md-sys-color-outline-variant);
        }
         .modal-footer button {
             margin-left: 0.5rem;
         }

        /* Day Details Modal Specifics */
        .day-summary {
            display: grid; /* Use grid for better alignment */
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 1rem;
            text-align: center;
            margin-bottom: 1.5rem;
            padding: 1rem;
            background-color: var(--md-sys-color-primary-container);
            border-radius: var(--border-radius-medium);
            color: var(--md-sys-color-on-primary-container);
        }
        .day-summary-value {
            font-size: 1.75rem;
            font-weight: 700;
            color: var(--md-sys-color-primary);
            display: block;
             line-height: 1.1;
        }
        .day-summary-label {
            font-size: 0.8rem;
            color: var(--md-sys-color-on-primary-container);
            opacity: 0.8;
            text-transform: uppercase;
             margin-top: 0.25rem;
             display: block;
        }
        .day-entries {
            max-height: 300px;
            overflow-y: auto;
            padding-right: 5px; /* Space for scrollbar */
             margin-top: 1rem; /* Space after summary/actions */
        }
        /* Style day entries like time entries */
        .day-entry {
             border-bottom: 1px solid var(--md-sys-color-outline-variant);
             padding: 1rem 0;
             margin-bottom: 0.5rem;
             display: flex; /* Use flex for button alignment */
             justify-content: space-between;
             align-items: flex-start;
             gap: 1rem;
        }
        .day-entry:last-child { border-bottom: none; margin-bottom: 0; }
        .day-entry-info { flex-grow: 1; }
        .day-entry-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.25rem; }
        .day-entry-hours { font-weight: bold; color: var(--md-sys-color-primary); }
        .day-entry-details { display: flex; flex-wrap: wrap; gap: 0.75rem; margin: 0.25rem 0; font-size: 0.8rem; color: var(--md-sys-color-on-surface-variant); }
         .day-entry-details span {
             background-color: var(--md-sys-color-surface);
             padding: 2px 8px;
             border-radius: var(--border-radius-small);
             display: inline-flex;
             align-items: center;
             gap: 4px;
         }
        .day-entry-description { margin-top: 0.25rem; font-size: 0.9rem; color: var(--md-sys-color-on-surface-variant); }
        .day-entry-vehicle {
            font-size: 0.8rem;
            color: var(--md-sys-color-on-surface-variant);
            margin-top: 4px;
            padding-left: 8px;
            border-left: 2px solid var(--md-sys-color-outline);
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        .day-entry-vehicle .material-symbols-outlined { font-size: 1em; }
         .day-entry .entry-buttons { flex-shrink: 0; } /* Prevent buttons shrinking */
        .modal-actions {
             text-align: right;
             margin-bottom: 1rem;
        }

        /* Monthly Summary / Stats */
        .monthly-summary, .stats-container, .monthly-report-stats {
            display: grid; /* Use grid for better spacing */
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            justify-content: space-around; /* Center items */
            margin-top: 1.5rem;
            padding: 1rem;
            background-color: var(--md-sys-color-secondary-container);
            color: var(--md-sys-color-on-secondary-container);
            border-radius: var(--border-radius-medium);
        }
        .monthly-summary h3 {
            grid-column: 1 / -1; /* Span full width */
            text-align: center;
            margin-bottom: 0.5rem;
            color: var(--md-sys-color-secondary);
            font-weight: 500;
        }
        .monthly-stat-item, .stat-card {
            text-align: center;
            padding: 0.75rem;
            background-color: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
            border-radius: var(--border-radius-medium);
            box-shadow: var(--elevation-1);
        }
        .monthly-stat-value, .stat-value {
            font-size: 1.75rem;
            font-weight: 700;
            color: var(--md-sys-color-secondary);
            margin: 5px 0;
            display: block;
             line-height: 1.1;
        }
        .monthly-stat-label, .stat-label {
            font-size: 0.8rem;
            color: var(--md-sys-color-on-surface-variant);
            text-transform: uppercase;
             display: block;
             margin-top: 0.25rem;
        }

        /* Contacts Section */
        .contacts-container { display: flex; flex-direction: column; gap: 1.5rem; }
        .contact-address {
            padding: 1rem;
            background-color: var(--md-sys-color-tertiary-container);
            color: var(--md-sys-color-on-tertiary-container);
            border-radius: var(--border-radius-medium);
            margin-bottom: 1rem;
        }
        .contact-address .contact-item, .contact-info .contact-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.5rem;
            font-size: 1rem;
        }
        .contact-address .contact-item .material-symbols-outlined,
        .contact-info .contact-item .material-symbols-outlined {
            color: var(--md-sys-color-tertiary);
            font-size: 1.25rem;
             width: 24px; /* Fixed width for alignment */
             text-align: center;
             flex-shrink: 0;
        }
        .dark-theme .contact-address .contact-item .material-symbols-outlined,
        .dark-theme .contact-info .contact-item .material-symbols-outlined {
            color: var(--md-sys-color-tertiary); /* Keep same color */
        }
        .contact-group h3 {
            color: var(--md-sys-color-secondary);
            margin-bottom: 0.75rem;
            font-size: 1.1rem;
            font-weight: 500;
            border-bottom: 1px solid var(--md-sys-color-outline-variant);
            padding-bottom: 0.5rem;
        }

        /* Stili per l'aggiunta di contatti */
        .add-contact-container {
            display: flex;
            justify-content: center;
            margin-top: 1.5rem;
        }

        #addContactBtn {
            background-color: var(--md-sys-color-secondary);
            color: var(--md-sys-color-on-secondary);
            transition: all 0.3s ease;
        }

        #addContactBtn:hover {
            background-color: var(--md-sys-color-secondary-container);
            color: var(--md-sys-color-on-secondary-container);
            transform: translateY(-2px);
        }

        /* Stili per il modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1050;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .modal.show {
            display: block;
            opacity: 1;
        }

        .modal-content {
            background-color: var(--md-sys-color-surface);
            margin: 10% auto;
            width: 90%;
            max-width: 500px;
            border-radius: var(--border-radius-large);
            box-shadow: var(--elevation-3);
            transform: translateY(-20px);
            transition: transform 0.3s ease;
            border: 1px solid var(--md-sys-color-outline-variant);
        }

        .modal.show .modal-content {
            transform: translateY(0);
        }

        .modal-header {
            padding: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--md-sys-color-outline-variant);
        }

        .modal-header h3 {
            color: var(--md-sys-color-primary);
            margin: 0;
        }

        .close-modal {
            color: var(--md-sys-color-on-surface-variant);
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s ease;
        }

        .close-modal:hover {
            color: var(--md-sys-color-error);
        }

        .modal-body {
            padding: 1rem;
        }

        .form-actions {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .btn-secondary {
            background-color: var(--md-sys-color-surface-variant);
            color: var(--md-sys-color-on-surface-variant);
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: var(--border-radius-full);
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            transition: background-color 0.2s ease;
        }

        .btn-secondary:hover {
            background-color: var(--md-sys-color-outline);
        }
        .contact-card {
            background-color: var(--md-sys-color-surface);
            border-radius: var(--border-radius-medium);
            padding: 1rem;
            box-shadow: var(--elevation-1);
            margin-bottom: 1rem;
            border: 1px solid var(--md-sys-color-outline-variant);
        }
        .contact-name {
            font-weight: 500;
            font-size: 1.1rem;
            margin-bottom: 0.75rem;
            color: var(--md-sys-color-on-surface);
        }
        .contact-info { display: flex; flex-direction: column; gap: 0.5rem; }
        .contact-item a {
            color: var(--md-sys-color-primary);
            text-decoration: none;
            transition: color 0.2s;
            word-break: break-all; /* Prevent long emails breaking layout */
        }
        .contact-item a:hover {
            text-decoration: underline;
             filter: brightness(80%);
        }
         .dark-theme .contact-item a:hover {
            filter: brightness(120%);
         }

        /* QR Code */
        .qr-code-container {
            margin-top: 1.5rem;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }

        /* --- Modern Flatpickr Styling (2025 Inspired) --- */

        /* Stili per il calendario */

        /* Stili specifici per il modale del calendario */
        #dayModal {
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        #dayModal.visible {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            pointer-events: auto !important;
        }
        .flatpickr-calendar {
            background: var(--md-sys-color-surface) !important;
        }
        .flatpickr-months,
        .flatpickr-month,
        .flatpickr-weekdays,
        .flatpickr-weekdaycontainer,
        .dayContainer,
        .flatpickr-days,
        .flatpickr-innerContainer,
        .flatpickr-rContainer,
        .flatpickr-time {
            background: var(--md-sys-color-surface) !important;
        }

        /* Stile per l'header del calendario - con alta specificità */
        html body .flatpickr-calendar .flatpickr-months .flatpickr-month {
            background-color: var(--md-sys-color-primary-container) !important;
            color: var(--md-sys-color-on-primary-container) !important;
            fill: var(--md-sys-color-on-primary-container) !important;
        }

        /* Stile per i pulsanti di navigazione - con alta specificità */
        html body .flatpickr-calendar .flatpickr-months .flatpickr-prev-month,
        html body .flatpickr-calendar .flatpickr-months .flatpickr-next-month {
            background-color: var(--md-sys-color-primary-container) !important;
            fill: var(--md-sys-color-on-primary-container) !important;
            position: relative !important;
            padding: 8px !important;
            height: auto !important;
            width: auto !important;
            border-radius: var(--border-radius-small) !important;
            margin: 0 5px !important;
            top: 0 !important;
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
            cursor: pointer !important;
        }

        html body .flatpickr-calendar .flatpickr-months .flatpickr-prev-month:hover,
        html body .flatpickr-calendar .flatpickr-months .flatpickr-next-month:hover {
            background-color: rgba(255, 255, 255, 0.2) !important;
        }

        html body .flatpickr-calendar .flatpickr-months .flatpickr-prev-month svg,
        html body .flatpickr-calendar .flatpickr-months .flatpickr-next-month svg {
            width: 20px !important;
            height: 20px !important;
            fill: var(--md-sys-color-on-primary-container) !important;
        }

        /* Stile per i dropdown e gli input - con alta specificità */
        html body .flatpickr-calendar .flatpickr-months .flatpickr-current-month .flatpickr-monthDropdown-months,
        html body .flatpickr-calendar .flatpickr-months .flatpickr-current-month input.cur-year {
            background-color: var(--md-sys-color-primary-container) !important;
            color: var(--md-sys-color-on-primary-container) !important;
        }

        /* Stile per i giorni della settimana - con alta specificità */
        html body .flatpickr-calendar .flatpickr-weekdays {
            background: var(--md-sys-color-surface-variant) !important;
        }

        html body .flatpickr-calendar .flatpickr-weekday {
            background: var(--md-sys-color-surface-variant) !important;
            color: var(--md-sys-color-on-surface-variant) !important;
        }

        /* Stile per il dropdown dei mesi con alta specificità */
        html body .flatpickr-calendar .flatpickr-months .flatpickr-monthDropdown-month {
            background-color: var(--md-sys-color-primary-container) !important;
            color: var(--md-sys-color-on-primary-container) !important;
            font-size: 1em !important;
            padding: 8px 12px !important;
        }

        /* Stile per il tema scuro */
        html body.dark-theme .flatpickr-calendar .flatpickr-months .flatpickr-month,
        html body.dark-theme .flatpickr-calendar .flatpickr-months .flatpickr-prev-month,
        html body.dark-theme .flatpickr-calendar .flatpickr-months .flatpickr-next-month,
        html body.dark-theme .flatpickr-calendar .flatpickr-months .flatpickr-current-month .flatpickr-monthDropdown-months,
        html body.dark-theme .flatpickr-calendar .flatpickr-months .flatpickr-current-month input.cur-year,
        html body.dark-theme .flatpickr-calendar .flatpickr-weekday {
            color: var(--md-sys-color-on-surface) !important;
            fill: var(--md-sys-color-on-surface) !important;
        }

        /* Stile per l'input dell'anno */
        .numInput,
        .cur-year {
            background: transparent !important;
            color: var(--md-sys-color-on-surface) !important;
        }

        /* Stile per il contenitore del tempo */
        .flatpickr-time,
        .flatpickr-time input,
        .flatpickr-time .numInputWrapper,
        .flatpickr-time .flatpickr-am-pm {
            background: var(--md-sys-color-surface) !important;
            color: var(--md-sys-color-on-surface) !important;
        }

        /* Stile per i separatori */
        .flatpickr-time .flatpickr-time-separator {
            color: var(--md-sys-color-on-surface) !important;
        }

        .flatpickr-calendar {
            background: var(--md-sys-color-surface) !important; /* Sfondo solido */
            border-radius: var(--border-radius-large); /* More pronounced rounding */
            box-shadow: var(--elevation-3);
            border: 1px solid var(--md-sys-color-outline-variant);
            padding: 10px; /* Overall padding */
            width: 320px; /* Slightly wider */
            color: var(--md-sys-color-on-surface);
            font-family: 'Roboto', sans-serif;
        }

        /* Header (Month/Year/Arrows) */
        .flatpickr-months {
            background: var(--md-sys-color-primary-container) !important;
            padding: 10px;
            border-radius: var(--border-radius-medium) var(--border-radius-medium) 0 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
        }

        .flatpickr-current-month {
            color: var(--md-sys-color-on-primary-container);
            font-size: 1.1em;
            font-weight: 500;
            position: relative;
            flex-grow: 1; /* Allow month name to take space */
            text-align: center;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .flatpickr-current-month .flatpickr-monthDropdown-months {
            border: none;
            background: transparent;
            color: inherit;
            font-size: 1.1em;
            font-weight: 500;
            padding: 5px 15px;
            border-radius: var(--border-radius-small);
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .flatpickr-current-month .flatpickr-monthDropdown-months:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        /* Nascondi completamente il selettore dell'anno */
        .flatpickr-current-month .numInputWrapper {
            display: none;
        }

        /* Weekdays (Mo, Tu...) */
        .flatpickr-weekdays {
            background: transparent;
            padding: 5px 0;
            display: flex;
            justify-content: space-around;
        }
        span.flatpickr-weekday {
            color: var(--md-sys-color-on-surface-variant);
            font-size: 0.8em;
            font-weight: 500;
            text-align: center;
            flex: 1; /* Distribute space evenly */
        }

        /* Day Container */
        .dayContainer {
            padding: 5px 0 0 0; /* Add some space above days */
            display: grid; /* Use grid */
            grid-template-columns: repeat(7, 1fr); /* 7 equal columns */
            gap: 2px; /* Small gap between days */
        }

        /* Individual Days */
        .flatpickr-day {
            background: transparent;
            border: none;
            color: var(--md-sys-color-on-surface);
            font-size: 0.9em;
            width: 36px; /* Fixed width */
            height: 36px; /* Fixed height */
            line-height: 36px; /* Center text vertically */
            text-align: center;
            border-radius: 50%; /* Circular shape */
            margin: 0; /* Remove default margins */
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            justify-self: center; /* Center horizontally in grid cell */
            align-self: center; /* Center vertically in grid cell */
        }

        /* Giorni festivi (sabato e domenica) in rosso */
        .flatpickr-day.flatpickr-weekend {
            color: #E53935 !important; /* Rosso */
            font-weight: 500;
        }

        .flatpickr-day:hover {
             background-color: var(--md-sys-color-surface-container-highest);
        }

        .flatpickr-day.disabled,
        .flatpickr-day.disabled:hover {
            background: transparent;
            color: var(--md-sys-color-on-surface-variant);
            opacity: 0.5;
            cursor: default;
        }

        .flatpickr-day.prevMonthDay,
        .flatpickr-day.nextMonthDay {
            color: var(--md-sys-color-on-surface-variant);
            opacity: 0.7;
        }
        .flatpickr-day.prevMonthDay:hover,
        .flatpickr-day.nextMonthDay:hover {
             background-color: var(--md-sys-color-surface-container-highest);
        }

        /* Today Style */
        .flatpickr-day.today {
            /* Dotted outline style */
            border: 2px dotted var(--md-sys-color-outline);
            color: inherit; /* Use default text color */
            font-weight: normal; /* Reset font weight */
            background: transparent !important; /* Ensure no background */
        }
        .flatpickr-day.today:hover {
             background-color: var(--md-sys-color-surface-container-highest);
             color: var(--md-sys-color-on-surface);
        }

        /* Selected Day Style */
        .flatpickr-day.selected {
            position: relative;
            background-color: transparent !important;
            color: var(--md-sys-color-on-surface) !important;
            border: none !important;
            font-weight: 700 !important;
            z-index: 1;
        }

        /* Animazione per il bordo tratteggiato */
        @keyframes dash-animation {
            0% {
                stroke-dashoffset: 0;
            }
            100% {
                stroke-dashoffset: 100;
            }
        }

        /* Cerchio tratteggiato attorno al giorno selezionato */
        .flatpickr-day.selected::before {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 3px dashed var(--md-sys-color-primary);
            z-index: -1;
            background-color: rgba(0, 106, 106, 0.1); /* Colore primario con opacità */
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            animation: pulse-selected 2s infinite ease-in-out;
        }

        /* Animazione di pulsazione per il giorno selezionato */
        @keyframes pulse-selected {
            0% {
                box-shadow: 0 0 0 0 rgba(0, 106, 106, 0.4);
            }
            70% {
                box-shadow: 0 0 0 6px rgba(0, 106, 106, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(0, 106, 106, 0);
            }
        }

        /* Hover sul giorno selezionato */
        .flatpickr-day.selected:hover {
            background-color: var(--md-sys-color-surface-container-highest) !important;
        }

        .flatpickr-day.selected:hover::before {
            border-width: 3px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
        }

        /* Today and Selected Style */
        .flatpickr-day.today.selected {
            position: relative;
            background-color: var(--md-sys-color-primary) !important;
            color: var(--md-sys-color-on-primary) !important;
            border: none !important;
            font-weight: 500 !important;
            z-index: 1;
        }

        /* Dark Theme Overrides */
        @media (prefers-color-scheme: dark) {
            .flatpickr-calendar {
                background: var(--md-sys-color-surface-container-high-dark);
                border: 1px solid var(--md-sys-color-outline-variant-dark);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                color: var(--md-sys-color-on-surface-dark);
            }
            .flatpickr-current-month {
                 color: var(--md-sys-color-on-surface-dark);
            }
             .flatpickr-current-month input.cur-year:hover {
                 background: var(--md-sys-color-surface-container-highest-dark);
            }
            .flatpickr-prev-month,
            .flatpickr-next-month {
                color: var(--md-sys-color-on-surface-variant-dark);
            }
            .flatpickr-prev-month:hover,
            .flatpickr-next-month:hover {
                background-color: var(--md-sys-color-surface-container-highest-dark);
                color: var(--md-sys-color-primary-dark);
            }
            span.flatpickr-weekday {
                color: var(--md-sys-color-on-surface-variant-dark);
            }
            .flatpickr-day {
                color: var(--md-sys-color-on-surface-dark);
            }

            /* Giorni festivi (sabato e domenica) in rosso per tema scuro */
            .flatpickr-day.flatpickr-weekend {
                color: #FF5252 !important; /* Rosso più chiaro per tema scuro */
                font-weight: 500;
            }
            .flatpickr-day:hover {
                background-color: var(--md-sys-color-surface-container-highest-dark);
            }
            .flatpickr-day.disabled,
            .flatpickr-day.disabled:hover {
                color: var(--md-sys-color-on-surface-variant-dark);
            }
            .flatpickr-day.prevMonthDay,
            .flatpickr-day.nextMonthDay {
                color: var(--md-sys-color-on-surface-variant-dark);
            }
             .flatpickr-day.prevMonthDay:hover,
             .flatpickr-day.nextMonthDay:hover {
                background-color: var(--md-sys-color-surface-container-highest-dark);
             }
            .flatpickr-day.today {
                position: relative;
                border: none;
                color: var(--md-sys-color-on-surface-dark);
                background-color: transparent !important;
                font-weight: 700;
                z-index: 1;
            }

            .flatpickr-day.today::before {
                content: "";
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 36px;
                height: 36px;
                border-radius: 50%;
                border: 3px solid var(--md-sys-color-primary-dark);
                background-color: rgba(129, 213, 212, 0.05); /* Colore primario dark con opacità bassa */
                z-index: -1;
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            }

            .flatpickr-day.today:hover {
                background-color: var(--md-sys-color-surface-container-highest-dark) !important;
                color: var(--md-sys-color-on-surface-dark);
            }

            .flatpickr-day.today:hover::before {
                border-color: var(--md-sys-color-primary-dark);
                border-width: 3px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
             }
            .flatpickr-day.selected {
                position: relative;
                background-color: transparent !important;
                color: var(--md-sys-color-on-surface-dark) !important;
                border: none !important;
                font-weight: 700 !important;
                z-index: 1;
            }

            /* Cerchio tratteggiato attorno al giorno selezionato - tema scuro */
            .flatpickr-day.selected::before {
                border: 3px dashed var(--md-sys-color-primary-dark);
                background-color: rgba(129, 213, 212, 0.1); /* Colore primario dark con opacità */
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
                animation: pulse-selected-dark 2s infinite ease-in-out;
            }

            /* Animazione di pulsazione per il giorno selezionato - tema scuro */
            @keyframes pulse-selected-dark {
                0% {
                    box-shadow: 0 0 0 0 rgba(129, 213, 212, 0.4);
                }
                70% {
                    box-shadow: 0 0 0 6px rgba(129, 213, 212, 0);
                }
                100% {
                    box-shadow: 0 0 0 0 rgba(129, 213, 212, 0);
                }
            }

            /* Hover sul giorno selezionato - tema scuro */
            .flatpickr-day.selected:hover {
                background-color: var(--md-sys-color-surface-container-highest-dark) !important;
            }

            .flatpickr-day.selected:hover::before {
                border-width: 3px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.25);
            }

            .flatpickr-day.today.selected {
                position: relative;
                background-color: transparent !important;
                color: var(--md-sys-color-on-surface-dark) !important;
                border: none !important;
                font-weight: 700 !important;
            }

            /* Cerchio speciale per giorno corrente selezionato - tema scuro */
            .flatpickr-day.today.selected::before {
                border: 4px solid var(--md-sys-color-primary-dark);
                background-color: rgba(129, 213, 212, 0.15); /* Colore primario dark con opacità media */
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.25);
            }

            /* Aggiunta di un secondo cerchio tratteggiato esterno - tema scuro */
            .flatpickr-day.today.selected::after {
                border: 2px dashed var(--md-sys-color-primary-dark);
                box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            }

            /* Hover sul giorno corrente selezionato - tema scuro */
            .flatpickr-day.today.selected:hover::before {
                border-width: 4px;
                box-shadow: 0 3px 5px rgba(0, 0, 0, 0.3);
            }
        }

        /* --- End Modern Flatpickr Styling --- */

        /* --- Calendar Summary Styles (Restored Here) --- */
        #monthlySummary {
            margin-top: 0; /* Remove top margin to attach to calendar grid */
            padding: 0; /* Keep padding 0 */
            width: 100%;
            box-sizing: border-box;
            display: block; /* Override any grid display on the container itself */
        }

        #monthlySummary .monthly-report-stats.card {
            width: 100%;
            padding: 0;
            margin: 0;
            background-color: transparent;
            box-shadow: none;
            border: none;
            display: grid; /* Use grid layout */
            grid-template-columns: 1fr 1fr; /* Create exactly two equal columns */
            gap: 0.5rem; /* Add spacing between grid items */
        }

        #monthlySummary .monthly-report-stats.card .monthly-stat-item {
            padding: 0.75rem 0.5rem;
            margin: 0;
            border-radius: var(--border-radius-medium);
            /* Ensure text alignment is centered or as desired */
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        /* --- End Calendar Summary Styles --- */

        /* Toast / Message - Material Design 3 Style */
        #toast-container {
            position: fixed;
            bottom: 90px; /* Above bottom nav */
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000; /* Aumentato per essere sopra l'overlay del supereroe */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            width: 90%;
            max-width: 400px;
            pointer-events: none; /* Permette di cliccare attraverso il container */
        }
        .message, .toast {
            padding: 14px 16px;
            border-radius: 4px;
            background-color: var(--md-sys-color-inverse-surface);
            color: var(--md-sys-color-inverse-on-surface);
            box-shadow: var(--elevation-3);
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1),
                        transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 0.875rem;
            font-weight: 400;
            line-height: 1.25rem;
            letter-spacing: 0.0178571429em;
            pointer-events: auto; /* Permette interazione con il toast */
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            min-height: 48px;
            box-sizing: border-box;
            border-left: 4px solid transparent;
            text-align: left;
        }
        .message.show, .toast.show {
            opacity: 1;
            transform: translateY(0);
        }
        .toast-message {
            flex: 1;
            padding-right: 8px;
        }
        .toast-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 4px;
        }
        .toast-action-button {
            text-transform: uppercase;
            font-weight: 500;
            font-size: 0.75rem;
            letter-spacing: 0.0892857143em;
            padding: 8px 12px;
            border-radius: 4px;
            border: none;
            background: transparent;
            color: var(--md-sys-color-primary);
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .toast-action-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .toast-close-button {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            color: var(--md-sys-color-inverse-on-surface);
            border: none;
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0;
            margin-left: 8px;
            transition: background-color 0.2s;
        }
        .toast-close-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        /* Toast types with left border */
        .message.success, .toast.success {
            border-left-color: var(--md-sys-color-tertiary);
        }
        .message.error, .toast.error {
            border-left-color: var(--md-sys-color-error);
        }
        .toast.warning {
            border-left-color: #FFA000;
            background-color: var(--md-sys-color-inverse-surface);
            color: var(--md-sys-color-inverse-on-surface);
        }
        .toast.info {
            border-left-color: var(--md-sys-color-primary);
            background-color: var(--md-sys-color-inverse-surface);
            color: var(--md-sys-color-inverse-on-surface);
        }

        /* Stili per la sezione Backup Cloud */
        .cloud-backup-container {
            margin-top: 1rem;
        }

        .provider-description {
            margin-bottom: 1rem;
            color: var(--md-sys-color-on-surface-variant);
            font-size: 0.9rem;
        }

        .provider-options {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .provider-option {
            display: flex;
            align-items: center;
            padding: 1rem;
            border-radius: var(--border-radius-medium);
            background-color: var(--md-sys-color-surface-variant);
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s, box-shadow 0.2s;
            position: relative;
        }

        .provider-option:hover {
            background-color: var(--md-sys-color-primary-container);
            transform: translateY(-2px);
            box-shadow: var(--elevation-2);
        }

        .provider-option.selected {
            background-color: var(--md-sys-color-primary-container);
            border: 2px solid var(--md-sys-color-primary);
        }

        .provider-logo {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 1rem;
            flex-shrink: 0;
            background-color: white;
            border-radius: 50%;
            padding: 5px;
        }

        .provider-logo img {
            max-width: 100%;
            max-height: 100%;
        }

        .provider-info {
            flex-grow: 1;
        }

        .provider-info h4 {
            margin: 0 0 0.25rem 0;
            color: var(--md-sys-color-on-surface);
            font-size: 1rem;
        }

        .provider-info p {
            margin: 0;
            font-size: 0.85rem;
            color: var(--md-sys-color-on-surface-variant);
        }

        .provider-status {
            margin-left: 1rem;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: var(--md-sys-color-outline);
        }

        .status-indicator.logged-in {
            background-color: #4CAF50; /* Verde */
        }

        .status-indicator.preferred {
            background-color: var(--md-sys-color-primary);
            box-shadow: 0 0 0 2px var(--md-sys-color-primary-container);
        }

        .cloud-account-section {
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--md-sys-color-outline-variant);
        }

        .cloud-account-info {
            margin-bottom: 1rem;
        }

        .user-profile {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
        }

        .user-avatar {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            margin-right: 1rem;
            object-fit: cover;
            border: 2px solid var(--md-sys-color-primary);
        }

        .user-avatar-icon {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            margin-right: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-primary);
            border: 2px solid var(--md-sys-color-primary);
        }

        .user-details {
            flex-grow: 1;
        }

        .user-name {
            font-weight: 500;
            color: var(--md-sys-color-on-surface);
        }

        .user-email {
            font-size: 0.85rem;
            color: var(--md-sys-color-on-surface-variant);
        }

        .user-provider {
            font-size: 0.8rem;
            color: var(--md-sys-color-on-surface-variant);
            margin-top: 0.25rem;
        }

        .login-buttons-container {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin-top: 1rem;
        }

        .cloud-login-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            padding: 0.75rem 1.5rem;
            border-radius: var(--border-radius-full);
            border: none;
            background-color: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            box-shadow: var(--elevation-1);
        }

        .cloud-login-btn:hover {
            box-shadow: var(--elevation-2);
        }

        .cloud-login-btn:active {
            transform: scale(0.98);
        }

        .cloud-login-btn img {
            width: 24px;
            height: 24px;
        }

        .cloud-login-btn.google-btn {
            background-color: #ffffff;
            color: #757575;
            border: 1px solid #dadce0;
        }

        .cloud-logout-btn {
            margin-top: 1rem;
            background-color: var(--md-sys-color-error-container);
            color: var(--md-sys-color-on-error-container);
        }

        .cloud-backup-controls {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid var(--md-sys-color-outline-variant);
        }

        .backup-status-container {
            display: flex;
            align-items: center;
            margin-bottom: 1rem;
            padding: 0.5rem;
            background-color: var(--md-sys-color-surface);
            border-radius: var(--border-radius-small);
        }

        .backup-status-label {
            font-weight: 500;
            margin-right: 0.5rem;
        }

        .backup-status-value {
            color: var(--md-sys-color-on-surface-variant);
        }

        .backup-actions {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .backup-btn {
            flex: 1;
            min-width: 120px;
        }

        .backup-settings {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .backup-setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .backup-setting-label {
            font-weight: 500;
        }

        .spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Monthly Report */
        .monthly-report-container { margin-top: 1.5rem; }
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--md-sys-color-outline-variant);
            flex-wrap: wrap; /* Wrap on small screens */
            gap: 1rem;
        }
        .section-header h2 { margin: 0; flex-grow: 1; } /* Allow title to grow */
        .section-controls { display: flex; align-items: center; gap: 0.75rem; flex-wrap: wrap;}
        .month-selector select { /* Using standard input style */
            min-width: 150px; /* Ensure dropdown is usable */
        }

        .export-btn.excel-btn {
            background-color: #1D6F42; /* Excel Green */
            color: white;
        }
        .export-btn.excel-btn:hover { background-color: #165231; }

        .export-btn.pdf-btn {
            background-color: #D93025; /* PDF Red */
            color: white;
        }
        .export-btn.pdf-btn:hover { background-color: #B3261E; }

        .monthly-report-content { max-height: 60vh; overflow-y: auto; }
        .monthly-report-item {
            padding: 1rem;
            border-bottom: 1px solid var(--md-sys-color-outline-variant);
            transition: background-color 0.2s;
        }
        .monthly-report-item:last-child { border-bottom: none; }
        .monthly-report-item:hover { background-color: var(--md-sys-color-surface-variant); }
        .monthly-report-date {
            font-weight: 500;
            font-size: 1.1rem;
            margin-bottom: 0.5rem;
            color: var(--md-sys-color-primary);
        }
        .monthly-report-details { display: flex; flex-wrap: wrap; gap: 0.75rem; margin-bottom: 0.5rem; }
        .monthly-report-detail {
            background-color: var(--md-sys-color-surface);
            padding: 3px 8px;
            border-radius: var(--border-radius-small);
            font-size: 0.8rem;
            color: var(--md-sys-color-on-surface-variant);
            display: inline-flex; /* Align icon and text */
            align-items: center;
            gap: 4px;
        }
        .monthly-report-detail .material-symbols-outlined { font-size: 1.1em; }

        .monthly-report-description, .monthly-report-vehicle {
            font-size: 0.9rem;
            color: var(--md-sys-color-on-surface-variant);
            margin-top: 0.25rem;
        }
        .monthly-report-vehicle {
             padding-left: 8px;
             border-left: 2px solid var(--md-sys-color-outline);
             display: inline-flex; /* Align icon */
             align-items: center;
             gap: 4px;
        }
         .monthly-report-vehicle .material-symbols-outlined { font-size: 1em; }
        .monthly-report-empty { text-align: center; padding: 2rem; color: var(--md-sys-color-on-surface-variant); }

        /* Stile per la sezione dei file Excel esportati */
        .excel-files-section {
            margin-bottom: 1.5rem;
            border: 1px solid var(--md-sys-color-outline-variant);
            border-radius: var(--border-radius-medium);
            overflow: hidden;
            background-color: var(--md-sys-color-surface);
        }

        .excel-files-header {
            width: 100%;
        }

        .toggle-excel-files {
            display: flex;
            align-items: center;
            width: 100%;
            padding: 0.75rem 1rem;
            background-color: var(--md-sys-color-surface-variant);
            border: none;
            cursor: pointer;
            text-align: left;
            transition: background-color 0.2s;
        }

        .toggle-excel-files:hover {
            background-color: rgba(0, 106, 106, 0.1);
        }

        .toggle-excel-files h3 {
            color: var(--md-sys-color-primary);
            margin: 0;
            font-size: 1.1rem;
            font-weight: 500;
        }

        .toggle-icon {
            margin-right: 0.5rem;
            transition: transform 0.3s ease;
            color: var(--md-sys-color-primary);
        }

        /* Rimuoviamo questa regola che potrebbe causare problemi */
        /* .toggle-excel-files[aria-expanded="true"] .toggle-icon {
            transform: rotate(180deg);
        } */

        .excel-files-container {
            max-height: 300px;
            overflow-y: auto;
            transition: max-height 0.3s ease, padding 0.3s ease, opacity 0.3s ease;
            padding: 1rem;
            opacity: 1;
        }

        .excel-files-container.collapsed {
            max-height: 0;
            padding: 0 1rem;
            overflow: hidden;
            opacity: 0;
        }

        .excel-files-list {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .excel-file-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            background-color: var(--md-sys-color-surface-variant);
            border-radius: var(--border-radius-medium);
            border: 1px solid var(--md-sys-color-outline-variant);
        }

        .excel-file-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .excel-file-icon {
            color: #165231; /* Verde Excel */
            font-size: 1.5rem;
        }

        .excel-file-details {
            display: flex;
            flex-direction: column;
        }

        .excel-file-name {
            font-weight: 500;
            color: var(--md-sys-color-on-surface);
        }

        .excel-file-date {
            font-size: 0.8rem;
            color: var(--md-sys-color-on-surface-variant);
        }

        .excel-file-actions {
            display: flex;
            gap: 0.5rem;
        }

        .excel-file-download, .excel-file-delete {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: var(--border-radius-small);
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--md-sys-color-on-surface-variant);
            transition: background-color 0.2s, color 0.2s;
        }

        .excel-file-download:hover {
            background-color: rgba(0, 106, 106, 0.1);
            color: var(--md-sys-color-primary);
        }

        .excel-file-delete:hover {
            background-color: rgba(186, 26, 26, 0.1);
            color: var(--md-sys-color-error);
        }

        .empty-list-message {
            padding: 1rem;
            text-align: center;
            color: var(--md-sys-color-on-surface-variant);
            font-style: italic;
        }

        /* Style Ferie/Malattia in report */
         .monthly-report-item.ferie-entry {
             background-color: var(--md-sys-color-tertiary-container);
             color: var(--md-sys-color-on-tertiary-container);
             border-left: 3px solid var(--md-sys-color-tertiary);
             padding-left: calc(1rem - 3px); /* Adjust padding */
         }
          .monthly-report-item.ferie-entry .monthly-report-date { color: var(--md-sys-color-tertiary); }
          .monthly-report-item.ferie-entry .monthly-report-detail { background-color: var(--md-sys-color-surface); color: var(--md-sys-color-on-surface-variant); } /* Reset detail color */
          .monthly-report-item.ferie-entry .monthly-report-description { color: var(--md-sys-color-on-tertiary-container); opacity: 0.9; }

         .monthly-report-item.malattia-entry {
             background-color: var(--md-sys-color-secondary-container);
             color: var(--md-sys-color-on-secondary-container);
             border-left: 3px solid var(--md-sys-color-secondary);
             padding-left: calc(1rem - 3px);
         }
         .monthly-report-item.malattia-entry .monthly-report-date { color: var(--md-sys-color-secondary); }
         .monthly-report-item.malattia-entry .monthly-report-detail { background-color: var(--md-sys-color-surface); color: var(--md-sys-color-on-surface-variant); }
         .monthly-report-item.malattia-entry .monthly-report-description { color: var(--md-sys-color-on-secondary-container); opacity: 0.9; }


         /* Ferie/Malattie Section */
        .ferie-malattie-content { display: flex; flex-direction: column; gap: 1.5rem; }
        .ferie-malattie-form, .ferie-malattie-list {
             background-color: var(--md-sys-color-surface);
             padding: 1.5rem;
             border-radius: var(--border-radius-medium);
             border: 1px solid var(--md-sys-color-outline-variant);
        }
         .ferie-malattie-list h3 {
             color: var(--md-sys-color-secondary);
             margin-bottom: 1rem;
             font-weight: 500;
         }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
             color: var(--md-sys-color-on-surface);
             margin-bottom: 1rem; /* Consistent margin */
             padding: 0.5rem 0; /* Make easier to tap */
        }
        .checkbox-label input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: var(--md-sys-color-primary); /* Style checkbox */
            margin: 0;
             flex-shrink: 0;
        }
         .checkbox-label span {
             line-height: 1.2;
         }

        .ferie-malattie-entry {
            padding: 1rem 0;
            border-bottom: 1px solid var(--md-sys-color-outline-variant);
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 1rem;
        }
         .ferie-malattie-entry:last-child { border-bottom: none; margin-bottom: 0; }
         .ferie-malattie-info { flex-grow: 1; }
         .ferie-malattie-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.25rem; flex-wrap: wrap; gap: 0.5rem; }
         .ferie-malattie-type { font-weight: 500; color: var(--md-sys-color-primary); display: inline-flex; align-items: center; gap: 0.25rem; }
         .ferie-malattie-type .material-symbols-outlined { font-size: 1.1em; vertical-align: bottom;}
         .ferie-malattie-date { color: var(--md-sys-color-on-surface-variant); font-size: 0.9rem; }
         .ferie-malattie-note { color: var(--md-sys-color-on-surface-variant); font-style: italic; font-size: 0.9rem; margin-top: 0.25rem; width: 100%; } /* Take full width below */
         .ferie-malattie-actions { flex-shrink: 0; }
         .delete-ferie-btn { /* Using standard delete button style */
             min-width: 40px;
             min-height: 40px;
             padding: 0; /* Remove padding if just icon */
             display: inline-flex; /* Center icon */
             align-items: center;
             justify-content: center;
         }
         .delete-ferie-btn .material-symbols-outlined { font-size: 1.5rem; }


        /* Vehicles Management */
         .vehicles-manager { margin-top: 1rem; }
         .vehicles-form { margin-bottom: 1rem; }
         .vehicles-form input { margin-bottom: 0; } /* Remove bottom margin if inside flex */
         .vehicles-list {
             border: 1px solid var(--md-sys-color-outline-variant);
             border-radius: var(--border-radius-medium);
             padding: 0.5rem;
             background-color: var(--md-sys-color-surface-variant);
             margin-top: 1rem;
             max-height: 200px;
             overflow-y: auto;
         }
         .vehicle-item {
             display: flex;
             justify-content: space-between;
             align-items: center;
             padding: 0.75rem 1rem;
             margin-bottom: 0.5rem;
             background-color: var(--md-sys-color-surface);
             border-radius: var(--border-radius-small);
             border: 1px solid var(--md-sys-color-outline-variant);
             gap: 1rem; /* Add gap */
         }
         .vehicle-item:last-child { margin-bottom: 0; }
         .vehicle-info { display: flex; flex-direction: column; flex-grow: 1; }
         .vehicle-name { font-weight: 500; color: var(--md-sys-color-on-surface); }
         .vehicle-plate { font-size: 0.8rem; color: var(--md-sys-color-on-surface-variant); }
         .delete-vehicle-btn { /* Using standard delete button style */
              min-width: 40px;
             min-height: 40px;
             padding: 0;
              display: inline-flex; /* Center icon */
             align-items: center;
             justify-content: center;
             flex-shrink: 0;
         }
          .delete-vehicle-btn .material-symbols-outlined { font-size: 1.5rem; }

        /* Date Picker (Flatpickr) Customization */
        .flatpickr-calendar {
            background-color: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
            border-radius: var(--border-radius-medium);
            box-shadow: var(--elevation-3);
            border: 1px solid var(--md-sys-color-outline-variant);
            width: auto; /* Adjust width */
             font-family: var(--body-font-family); /* Ensure correct font */
        }
        .flatpickr-months .flatpickr-month {
            background-color: transparent !important;
            color: var(--md-sys-color-on-surface);
            fill: var(--md-sys-color-on-surface);
            height: 56px; /* Taller header */
             border-radius: var(--border-radius-medium) var(--border-radius-medium) 0 0;
        }
        .flatpickr-months .flatpickr-prev-month, .flatpickr-months .flatpickr-next-month {
            fill: var(--md-sys-color-on-surface);
             top: 16px; /* Adjust icon position */
             padding: 4px; /* Hit area */
             border-radius: 50%;
             transition: background-color 0.2s ease;
             background-color: transparent !important;
        }
        .flatpickr-months .flatpickr-prev-month:hover, .flatpickr-months .flatpickr-next-month:hover {
            background-color: rgba(0, 0, 0, 0.1);
        }
        .dark-theme .flatpickr-months .flatpickr-prev-month:hover, .dark-theme .flatpickr-months .flatpickr-next-month:hover {
             background-color: rgba(255, 255, 255, 0.1);
        }
        .flatpickr-current-month {
            font-size: 1.1rem;
            font-weight: 500;
            padding-top: 16px;
             height: 56px;
             display: flex;
             align-items: center;
             justify-content: center;
        }
        .flatpickr-current-month .flatpickr-monthDropdown-months,
        .flatpickr-current-month input.cur-year {
            background-color: transparent !important;
            color: var(--md-sys-color-on-surface) !important;
            border: none;
            font-weight: 500;
             padding: 2px 4px;
             border-radius: var(--border-radius-small);
        }
         .flatpickr-current-month .flatpickr-monthDropdown-months:hover,
        .flatpickr-current-month input.cur-year:hover {
            background-color: rgba(0, 0, 0, 0.1);
        }
        .dark-theme .flatpickr-current-month .flatpickr-monthDropdown-months:hover,
        .dark-theme .flatpickr-current-month input.cur-year:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        span.flatpickr-weekday {
            background-color: var(--md-sys-color-surface-variant);
            color: var(--md-sys-color-on-surface-variant);
            font-weight: 500;
             font-size: 0.8em;
             text-transform: uppercase;
             height: 36px;
             line-height: 36px;
        }
        .flatpickr-day {
            color: var(--md-sys-color-on-surface);
            border: 1px solid transparent;
            border-radius: var(--border-radius-full); /* Circular days */
            line-height: 36px; /* Adjust for circle */
            max-width: 38px;
            height: 38px;
             margin: 1px auto; /* Center circle */
             font-weight: 400;
             transition: all 0.2s ease;
        }
        .flatpickr-day:hover, .flatpickr-day:focus {
            background-color: var(--md-sys-color-surface-variant);
            border-color: var(--md-sys-color-surface-variant);
             color: var(--md-sys-color-on-surface-variant);
        }
        .flatpickr-day.today {
             position: relative;
             border: none;
             color: var(--md-sys-color-on-surface);
             background-color: transparent;
             font-weight: 700;
             z-index: 1;
        }

        /* Cerchio attorno al giorno corrente */
        .flatpickr-day.today::before {
             content: "";
             position: absolute;
             top: 50%;
             left: 50%;
             transform: translate(-50%, -50%);
             width: 36px;
             height: 36px;
             border-radius: 50%;
             border: 3px solid var(--md-sys-color-primary);
             background-color: rgba(0, 106, 106, 0.05); /* Colore primario con opacità molto bassa */
             z-index: -1;
             box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        .flatpickr-day.selected, .flatpickr-day.startRange, .flatpickr-day.endRange,
        .flatpickr-day.selected:hover, .flatpickr-day.startRange:hover, .flatpickr-day.endRange:hover {
            background-color: var(--md-sys-color-primary);
            border-color: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
        }
        .flatpickr-day.inRange {
            background-color: var(--md-sys-color-primary-container);
            color: var(--md-sys-color-on-primary-container);
            box-shadow: none;
            border-color: var(--md-sys-color-primary-container);
            border-radius: 0; /* Square in-range */
        }
        .flatpickr-day.startRange, .flatpickr-day.endRange {
            border-radius: var(--border-radius-full); /* Ensure start/end are round */
        }
        .flatpickr-day.disabled, .flatpickr-day.disabled:hover {
            color: var(--md-sys-color-on-surface-variant);
            opacity: 0.5;
            background-color: transparent;
            border-color: transparent;
            cursor: default;
        }


         /* Date indicator styling */
        #dateIndicator div {
            background-color: var(--md-sys-color-primary-container) !important;
            color: var(--md-sys-color-on-primary-container) !important;
            padding: 10px 15px !important;
            border-radius: var(--border-radius-medium) !important;
            margin: 10px 0 !important;
            font-size: 1.1rem !important;
            text-align: center;
            font-weight: 500 !important;
            cursor: pointer;
            box-shadow: var(--elevation-1);
            transition: background-color 0.2s ease, filter 0.2s ease;
             display: flex; /* Align icon and text */
             align-items: center;
             justify-content: center;
             gap: 0.5rem;
        }
         #dateIndicator div:hover {
             filter: brightness(95%);
         }
          .dark-theme #dateIndicator div:hover {
             filter: brightness(110%);
         }

        #dateIndicator .material-symbols-outlined {
             font-size: 1.2em;
         }
         #dateIndicator span {
             vertical-align: middle;
         }

         /* Hide original date input and label */
         #date { display: none !important; }
         label[for='date'] { display: none !important; }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            html { font-size: 15px; }
            .container { padding: 0.75rem; }
            main { padding: 0.75rem; margin-top: 65px; }
            .card { padding: 1rem; margin-bottom: 1rem; }
            .bottom-nav { padding: 0.25rem 0; }
            .nav-item { font-size: 0.65rem; min-height: 52px; padding: 0.25rem 0.5rem; }
            .nav-item .material-symbols-outlined { font-size: 1.5rem; }
            .nav-item.active .material-symbols-outlined { font-size: 1.7rem; }
            /* Removed .nav-item.active::before as requested */
            .nav-item::before { display: none; }
            .nav-item.active::after { height: 2px; }
            .form-row { flex-direction: column; gap: 0; } /* Stack inline groups */
            .form-group-inline { margin-bottom: 1rem; }

            .modal-content { width: 95%; margin: 5vh auto; padding: 1rem; }
            .modal-title { font-size: 1.25rem; }
            .day-summary-value { font-size: 1.5rem; }

            .calendar-day { min-height: 60px; padding: 4px; }
            .calendar-day-number { font-size: 0.75rem; width: 20px; height: 20px; line-height: 20px; top: 2px; left: 2px;}
            .calendar-day-content { margin-top: 24px; }
            .calendar-hours { font-size: 0.8rem; }
            .calendar-icons { font-size: 0.8rem; }
            .calendar-icons .material-symbols-outlined { font-size: 1em; }
            .calendar-holiday-name { font-size: 0.65rem; }
            .calendar-weekday { font-size: 0.7rem; padding: 0.5rem 0.1rem; }

            .monthly-summary, .stats-container, .monthly-report-stats { gap: 0.5rem; padding: 0.75rem; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); }
            .monthly-stat-item, .stat-card { min-width: auto; padding: 0.5rem; }
            .monthly-stat-value, .stat-value { font-size: 1.25rem; }
            .monthly-stat-label, .stat-label { font-size: 0.7rem; }

            .section-header { flex-direction: column; align-items: stretch; }
            .section-controls { justify-content: center; width: 100%; }
             .section-controls .month-selector { flex-grow: 1; } /* Allow selector to grow */
             .section-controls button { width: 100%; margin-top: 0.5rem; } /* Stack button */

            .vehicles-form div { flex-direction: column; gap: 0.5rem; align-items: stretch; }
            .vehicles-form input { margin-right: 0; }
            .vehicles-form button { width: 100%; margin-top: 0.5rem; }

            .setting-item { flex-direction: column; align-items: stretch; }
             .setting-item .setting-label { margin-bottom: 0.5rem; }
             .setting-item > div { width: 100%; } /* Make input+button full width */
             .setting-item > button { margin-top: 0.5rem; width: 100%; }
             .setting-item .toggle-switch { align-self: flex-end; margin-top: 0.5rem; } /* Align toggle right */
        }

        @media (max-width: 480px) {
             html { font-size: 14px; }
            .container { padding: 0.5rem; }
             main { padding: 0.5rem; margin-top: 60px; }
             .card { padding: 0.75rem; }
             button, .btn { padding: 0.6rem 1.2rem; font-size: 0.8rem; }
             .nav-item { font-size: 0.6rem; }
             .nav-item .material-symbols-outlined { font-size: 1.4rem; }
             .nav-item.active .material-symbols-outlined { font-size: 1.6rem; }
             /* Removed .nav-item.active::before as requested */
             .nav-item::before { display: none; }
             .nav-item.active { transform: translateY(-3px); }
             .logo img { max-height: 35px; }
             header { padding: 0.5rem 1rem; }
             #dateIndicator div { font-size: 1rem !important; }

             /* Stack time inputs */
             .time-row { display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; } /* Keep side-by-side if possible */
             .time-row .form-group { margin-bottom: 0.5rem; }

             .day-summary { grid-template-columns: repeat(auto-fit, minmax(60px, 1fr)); gap: 0.5rem; padding: 0.5rem;}
             .day-summary-value { font-size: 1.2rem; }
             .day-summary-label { font-size: 0.7rem; }

             .monthly-summary, .stats-container, .monthly-report-stats { grid-template-columns: 1fr 1fr; } /* Two columns */
        }

        /* Specific styles for the monthly summary below the calendar */
        .monthly-summary {
            margin-top: 1rem; /* Add some space above the summary */
            padding: 1rem;
            background-color: var(--md-sys-color-surface-container-low);
            border-radius: var(--border-radius-large);
        }
        .monthly-summary h3 {
            text-align: center;
            margin-bottom: 1rem;
            font-weight: 500;
            color: var(--md-sys-color-on-surface);
        }
        .monthly-stats {
            display: grid; /* Ensure it's a grid container */
            grid-template-columns: 1fr 1fr; /* Create 2 columns */
            gap: 1rem; /* Add spacing between grid items */
        }
        .monthly-stat-item {
            background-color: var(--md-sys-color-surface-container);
            padding: 1rem;
            border-radius: var(--border-radius-medium);
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .monthly-stat-value {
            font-size: 1.8rem; /* Slightly larger value */
            font-weight: 500;
            color: var(--md-sys-color-primary);
            margin-bottom: 0.25rem;
        }
        .dark-theme .monthly-stat-value {
             color: var(--md-sys-color-primary-dark);
        }
        .monthly-stat-label {
            font-size: 0.8rem;
            color: var(--md-sys-color-on-surface-variant);
            text-transform: uppercase;
        }

        /* Remove .monthly-summary from the media query rule if it only applied grid there */
        @media (max-width: 600px) {
            /* ... other rules ... */
             .stats-container, .monthly-report-stats { grid-template-columns: 1fr 1fr; } /* Keep other relevant selectors */
            /* Remove or comment out the old rule applying grid to .monthly-summary here */
             /* .monthly-summary, .stats-container, .monthly-report-stats { grid-template-columns: 1fr 1fr; } */
        }

        /* Remove or adjust old .monthly-stats rules */
        /* .monthly-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        } */

        /* Ensure the rule for .monthly-report-stats exists and is correct */
        /* This might already exist from the report section styling */
        .monthly-report-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem; /* Further reduced gap */
             /* background-color, padding, margin-bottom etc. are now handled by inline styles or .card */
        }

        /* Ensure styles for items, values, labels are consistent */
        /* These might already exist */
        .monthly-stat-item {
            /* background-color is now mostly inline or inherited from .card */
            padding: 1rem;
            border-radius: var(--border-radius-medium);
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        .monthly-stat-value {
            font-size: 1.8rem;
            font-weight: 500;
            /* color is now mostly inline or inherited */
            margin-bottom: 0.25rem;
        }
        .monthly-stat-label {
            font-size: 0.8rem;
            /* color is now mostly inline or inherited */
            text-transform: uppercase;
        }

        /* Adjust media query if needed */
        @media (max-width: 600px) {
            /* Ensure this applies correctly */
            .monthly-report-stats, .stats-container /* Keep other relevant selectors */ {
                 grid-template-columns: 1fr 1fr; /* Or maybe 1fr for very small screens? */
                 gap: 0.25rem; /* Further reduce gap on small screens */
            }
            /* Remove old .monthly-stats rule */
             /* .stats-container, .monthly-report-stats { grid-template-columns: 1fr 1fr; } */
        }

        /* ... rest of css ... */

        #calendar-section .card {
            padding: 1rem; /* Maintain padding for the overall card */
        }

        #monthlySummary {
            margin-top: 0; /* Remove top margin to attach to calendar grid */
            padding: 0; /* Keep padding 0 */
            /* Ensure it spans the width of its container (.card) */
            width: 100%;
            box-sizing: border-box; /* Include padding/border in width calculation if any were added later */
        }

        /* Style the summary stats specifically when inside the calendar summary container */
        #monthlySummary .monthly-report-stats.card {
            width: 100%;
            padding: 0; /* Remove padding from the inner card */
            margin: 0; /* Remove margin from the inner card */
            background-color: transparent; /* Optional: make background transparent if parent sets it */
            box-shadow: none; /* Optional: remove shadow if parent has border */
            border: none; /* Optional: remove border if parent has border */
            /* Ensure the grid items inside also behave */
            display: grid; /* Use grid like the original */
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); /* Adjust columns as needed */
            gap: 0.5rem; /* Maintain gap between items */
        }

        #monthlySummary .monthly-report-stats.card .monthly-stat-item {
            /* Adjust padding/margin for individual items if needed */
            padding: 0.75rem 0.5rem;
            margin: 0;
            border-radius: var(--border-radius-medium);
            /* Background color is already set, keep it */
        }

        /* ... rest of css ... */

        /* --- Calendar Summary Styles (Moved Here) --- */
        #monthlySummary {
            margin-top: 0; /* Remove top margin to attach to calendar grid */
            padding: 0; /* Keep padding 0 */
            width: 100%;
            box-sizing: border-box;
            display: block; /* Override any grid display on the container itself */
        }

        #monthlySummary .monthly-report-stats.card {
            width: 100%;
            padding: 0;
            margin: 0;
            background-color: transparent;
            box-shadow: none;
            border: none;
            display: grid; /* Use grid layout */
            grid-template-columns: 1fr 1fr; /* Create exactly two equal columns */
            gap: 0.5rem; /* Add spacing between grid items */
        }

        #monthlySummary .monthly-report-stats.card .monthly-stat-item {
            padding: 0.75rem 0.5rem;
            margin: 0;
            border-radius: var(--border-radius-medium);
            /* Ensure text alignment is centered or as desired */
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        /* --- End Calendar Summary Styles --- */

        /* --- Gratta e Vinci Styles --- */
        .scratch-card-btn {
            background-color: #FF6B00; /* Arancione brillante */
            color: white;
            font-weight: bold;
            transition: all 0.3s ease;
            animation: pulse-slow 3s infinite;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            box-shadow: 0 0 10px rgba(255, 107, 0, 0.5);
            margin-right: 10px;
            font-size: 0.9rem;
        }

        .scratch-card-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px #FF6B00;
            background-color: #FF8C00;
        }

        @keyframes pulse-slow {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        #scratchCardOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        #scratchCardOverlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .scratch-card-container {
            position: relative;
            width: 300px;
            height: 200px;
            background-color: var(--md-sys-color-surface);
            border-radius: var(--border-radius-medium);
            box-shadow: var(--elevation-3);
            overflow: hidden;
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        #scratchCardOverlay.visible .scratch-card-container {
            transform: scale(1);
        }

        .scratch-card-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            text-align: center;
            color: var(--md-sys-color-on-surface);
            font-size: 1.2rem;
            font-weight: bold;
            z-index: 1;
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" viewBox="0 0 40 40"><text x="50%" y="50%" font-family="Arial" font-size="6" fill="%23cccccc" text-anchor="middle" dominant-baseline="middle">PWS</text></svg>');
            background-repeat: repeat;
        }

        .scratch-card-content p {
            background-color: var(--md-sys-color-surface);
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .scratch-card-content span {
            color: var(--md-sys-color-primary);
            font-size: 1.5rem;
            margin-top: 10px;
            background-color: var(--md-sys-color-surface);
            padding: 10px;
            border-radius: 8px;
        }

        #scratchCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><circle cx="16" cy="16" r="12" fill="%23ffffff" stroke="%23000000" stroke-width="1" opacity="0.7"/><circle cx="16" cy="16" r="4" fill="%23000000" opacity="0.5"/></svg>') 16 16, auto;
            border-radius: var(--border-radius-medium);
            transition: opacity 0.5s ease;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
        }

        .scratch-card-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            z-index: 3;
        }

        /* Fix per il menu contestuale su iOS */
        #pws-logo {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: manipulation;
        }

        #pws-logo img {
            pointer-events: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
    </style>
    <!-- Librerie esterne ottimizzate con attributi defer per migliorare il caricamento -->
    <script src="https://cdn.jsdelivr.net/npm/exceljs@4.3.0/dist/exceljs.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/flatpickr" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/l10n/it.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.1/jspdf.plugin.autotable.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" defer></script>

    <!-- Ottimizzazioni CSS per Safari iOS -->
    <style>
        /* Ottimizzazioni per Safari iOS e cross-browser */
        * {
            -webkit-tap-highlight-color: transparent !important;
            -webkit-overflow-scrolling: touch !important;
        }

        /* Forza hardware acceleration per animazioni fluide */
        .bouncing-logo,
        .nav-item.active,
        .modal,
        .bottom-nav,
        .card,
        button,
        .btn {
            -webkit-transform: translate3d(0, 0, 0);
            transform: translate3d(0, 0, 0);
        }

        /* Disabilita temporaneamente le animazioni durante lo scroll */
        .disable-animations * {
            -webkit-transition: none !important;
            transition: none !important;
            -webkit-animation: none !important;
            animation: none !important;
        }

        /* Ottimizzazioni per il rendering */
        .card,
        .modal-content,
        .bottom-nav,
        header {
            backface-visibility: hidden;
            perspective: 1000px;
        }

        /* Stili per la sezione Cash */
        .cash-settings-container {
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--md-sys-color-outline-variant);
        }

        .cash-results-container {
            margin-top: 1.5rem;
        }

        .cash-results {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin-top: 1rem;
        }

        .cash-result-item {
            display: grid;
            grid-template-columns: 1fr auto auto;
            gap: 1rem;
            padding: 0.75rem 1rem;
            background-color: var(--md-sys-color-surface);
            border-radius: var(--border-radius-medium);
            align-items: center;
            transition: background-color 0.2s ease;
        }

        .cash-result-item:hover {
            background-color: var(--md-sys-color-surface-variant);
        }

        .cash-result-label {
            font-weight: 500;
            color: var(--md-sys-color-on-surface);
        }

        .cash-result-hours {
            font-family: monospace;
            font-size: 0.9rem;
            color: var(--md-sys-color-on-surface-variant);
            text-align: right;
        }

        .cash-result-amount {
            font-family: monospace;
            font-weight: 700;
            font-size: 1.1rem;
            color: var(--md-sys-color-primary);
            text-align: right;
            min-width: 80px;
        }

        .cash-result-total {
            margin-top: 0.5rem;
            background-color: var(--md-sys-color-primary-container);
            border-left: 3px solid var(--md-sys-color-primary);
        }

        .cash-result-total .cash-result-label {
            font-weight: 700;
            font-size: 1.1rem;
            color: var(--md-sys-color-on-primary-container);
        }

        .cash-result-total .cash-result-amount {
            font-size: 1.3rem;
            color: var(--md-sys-color-on-primary-container);
        }

        @media (max-width: 600px) {
            .cash-result-item {
                padding: 0.5rem 0.75rem;
                gap: 0.5rem;
            }

            .cash-result-label {
                font-size: 0.9rem;
            }

            .cash-result-hours {
                font-size: 0.8rem;
            }

            .cash-result-amount {
                font-size: 1rem;
                min-width: 70px;
            }

            .cash-result-total .cash-result-label,
            .cash-result-total .cash-result-amount {
                font-size: 1.1rem;
            }
        }

        /* Ottimizzazioni per input e form */
        input,
        select,
        textarea {
            -webkit-appearance: none;
            appearance: none;
            border-radius: 0;
        }

        /* Previeni zoom involontario su input */
        input[type="text"],
        input[type="number"],
        input[type="email"],
        input[type="tel"],
        textarea,
        select {
            font-size: 16px !important;
        }

        /* Migliora la reattività dei pulsanti */
        button, .btn {
            touch-action: manipulation;
        }

        /* Ottimizzazioni per il rendering delle liste */
        .time-entries-list > div,
        .monthly-report-item,
        .vehicle-item {
            will-change: transform, opacity;
            transform: translateZ(0);
        }

        /* Ottimizzazioni per il calendario */
        .calendar-day {
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }

        /* Ottimizzazioni per le transizioni */
        .section.active {
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }

        /* Ottimizzazioni per il modal */
        .modal {
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }

        /* Ottimizzazioni per il toast */
        .toast {
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }

        /* Ottimizzazioni per le animazioni di fade */
        @media (-webkit-min-device-pixel-ratio: 2) {
            @keyframes fadeIn {
                0% { opacity: 0; transform: translateY(0); }
                100% { opacity: 1; transform: translateY(0); }
            }

            @keyframes fadeOut {
                0% { opacity: 1; transform: translateY(0); }
                100% { opacity: 0; transform: translateY(0); }
            }

            /* Semplifica le animazioni su dispositivi iOS */
            @keyframes bounce-horizontal {
                0%, 100% {
                    transform: translateX(0);
                }
                50% {
                    transform: translateX(10px);
                }
            }

            @keyframes bounce-excited {
                0%, 100% {
                    transform: scale(1);
                }
                50% {
                    transform: scale(1.2);
                }
            }

            .bouncing-logo {
                animation-duration: 3s !important;
            }

            .bouncing-logo-excited {
                animation-duration: 1.5s !important;
            }
        }
    </style>
    <!-- Custom Navigation Styles (inline) -->
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Create a style element
        const styleElement = document.createElement('style');

        // Add our new navigation styles
        styleElement.textContent = `
            /* Modern Bottom Navigation Redesign */
            .bottom-nav {
                position: fixed;
                bottom: 0;
                left: 0;
                width: 100%;
                background-color: var(--md-sys-color-surface);
                box-shadow: var(--elevation-2);
                padding: 0.75rem 0;
                display: flex;
                justify-content: space-around;
                align-items: center;
                z-index: 1000;
                border-top-left-radius: 16px;
                border-top-right-radius: 16px;
            }

            .nav-item {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                text-decoration: none;
                color: var(--md-sys-color-on-surface-variant);
                font-size: 0.75rem;
                padding: 0.5rem 0.75rem;
                border-radius: var(--border-radius-full);
                transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                flex: 1;
                text-align: center;
                min-height: 56px;
                position: relative;
                overflow: visible;
            }

            .nav-item .material-symbols-outlined {
                font-size: 1.75rem;
                margin-bottom: 4px;
                transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            }

            .nav-item span {
                display: block;
                line-height: 1.2;
                white-space: nowrap;
                transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                opacity: 0.9;
            }

            .nav-item.active {
                color: var(--md-sys-color-primary);
                font-weight: 500;
                transform: translateY(-8px);
            }

            .nav-item.active .material-symbols-outlined {
                font-variation-settings: 'FILL' 1, 'wght' 600;
                font-size: 2rem;
                filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
            }

            /* Remove the ::before element as requested */
            .nav-item.active::before {
                display: none !important;
            }

            .nav-item::before {
                display: none !important;
            }

            /* Bordo inferiore per l'elemento attivo */
            .nav-item.active::after {
                content: '';
                display: block;
                width: 50%;
                height: 4px;
                background-color: var(--md-sys-color-primary);
                border-radius: var(--border-radius-full);
                position: absolute;
                bottom: -8px;
                left: 50%;
                transform: translateX(-50%);
                transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            }

            /* Hover effect */
            .nav-item:hover {
                color: var(--md-sys-color-on-surface);
                background-color: rgba(0, 106, 106, 0.08);
                transform: translateY(-2px);
            }

            .nav-item:active {
                transform: scale(0.95);
            }

            /* Media queries for responsive design */
            @media (max-width: 768px) {
                .bottom-nav { padding: 0.25rem 0; }
                .nav-item { font-size: 0.65rem; min-height: 52px; padding: 0.25rem 0.5rem; }
                .nav-item .material-symbols-outlined { font-size: 1.5rem; }
                .nav-item.active .material-symbols-outlined { font-size: 1.7rem; }
                .nav-item.active::after { height: 3px; }
            }

            @media (max-width: 480px) {
                .nav-item { font-size: 0.6rem; }
                .nav-item .material-symbols-outlined { font-size: 1.4rem; }
                .nav-item.active .material-symbols-outlined { font-size: 1.6rem; }
                .nav-item.active { transform: translateY(-6px); }
            }
        `;

        // Add the style element to the head
        document.head.appendChild(styleElement);
    });
    </script>
</head>
<body>
    <header>
        <div class="header-content">
            <div class="logo bouncing-logo" id="pws-logo">
                <img src="https://i.imgur.com/BnllByD.png"
                     alt="PWS Logo"
                     draggable="false"
                     style="pointer-events: none; /* Impedisce che l'immagine riceva eventi touch/click */"
                     >
            </div>
            <div class="header-actions">
                <!-- Pulsante Gratta e Vinci -->
                <button id="scratchCardBtn" class="btn scratch-card-btn">
                    <span class="material-symbols-outlined">redeem</span>
                    Gratta e Vinci
                </button>
            </div>
        </div>
    </header>

    <main>
        <div class="container">
            <!-- Sezione Home -->
            <div id="home-section" class="section active">
                <div class="card">
                    <h2>Inserisci Ore</h2>
                    <div class="form-container">
                        <form id="timeEntryForm">
                            <div class="form-group">
                                <!-- Label hidden via CSS, Date indicator shown below -->
                                <label for="date">Data:</label>
                                <input type="text" id="date" class="form-control datepicker">
                                <!-- Nome giorno sopra il selettore -->
                                <div id="dayNameIndicator">
                                    Oggi
                                </div>
                                <div id="dateIndicator" title="Clicca per cambiare data">
                                    <!-- Indicator content set by JS -->
                                    <div>
                                        <span class="material-symbols-outlined">calendar_today</span>
                                        <span>Seleziona una data</span>
                                    </div>
                                </div>
                            </div>

                            <div class="form-group">
                                <label for="vehicleSelect">Mezzo:</label>
                                <select id="vehicleSelect" class="form-control">
                                    <option value="">-- Seleziona un mezzo --</option>
                                    <!-- Dynamic options -->
                                </select>
                            </div>

                            <div class="time-row">
                                <div class="form-group">
                                    <label for="startTime">Ora Inizio:</label>
                                    <div class="time-input-container">
                                        <button type="button" class="time-control-btn" data-action="decrease" data-target="startTime">
                                            <span class="material-symbols-outlined">arrow_left</span>
                                        </button>
                                        <input type="text" id="startTime" class="form-control time-input" placeholder="Es. 7" value="7">
                                        <button type="button" class="time-control-btn" data-action="increase" data-target="startTime">
                                            <span class="material-symbols-outlined">arrow_right</span>
                                        </button>
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label for="endTime">Ora Fine:</label>
                                    <div class="time-input-container">
                                        <button type="button" class="time-control-btn" data-action="decrease" data-target="endTime">
                                            <span class="material-symbols-outlined">arrow_left</span>
                                        </button>
                                        <input type="text" id="endTime" class="form-control time-input" placeholder="Es. 16.5" value="16.5">
                                        <button type="button" class="time-control-btn" data-action="increase" data-target="endTime">
                                            <span class="material-symbols-outlined">arrow_right</span>
                                        </button>
                                    </div>
                                </div>
                            </div>

                            <div class="form-group">
                                <label for="breakTime">Pausa (ore):</label>
                                <div class="time-input-container">
                                    <button type="button" class="time-control-btn" data-action="decrease" data-target="breakTime">
                                        <span class="material-symbols-outlined">arrow_left</span>
                                    </button>
                                    <input type="text" id="breakTime" class="form-control compact-input" value="0.5">
                                    <button type="button" class="time-control-btn" data-action="increase" data-target="breakTime">
                                        <span class="material-symbols-outlined">arrow_right</span>
                                    </button>
                                </div>
                            </div>

                            <div class="form-group">
                                <label for="notturne">Ore Notturne:</label>
                                <input type="number" id="notturne" class="form-control compact-input" step="0.5" min="0">
                            </div>

                            <div class="form-group">
                                <label for="transferta">Trasferta:</label>
                                <button type="button" id="transferta" class="trasferta-button">
                                    <span class="material-symbols-outlined">local_shipping</span>
                                    <span class="trasferta-text">Seleziona trasferta</span>
                                </button>
                            </div>

                            <div class="form-group">
                                <label for="totalHours">Ore Totali:</label>
                                <input type="number" id="totalHours" class="form-control compact-input" readonly>
                            </div>

                            <div class="form-group">
                                <label for="work-descriptions">Lavoro:</label>
                                <div id="work-descriptions-container">
                                    <div class="work-description-row">
                                        <input type="text" id="description" class="form-control work-description-input" placeholder="Inserisci un lavoro" data-row="0">
                                    </div>
                                </div>
                                <button type="button" id="add-work-row" class="btn-add-work">
                                    <span class="material-symbols-outlined">add</span> Aggiungi riga(oppure premi invio)
                                </button>
                            </div>

                            <div class="form-group" style="margin-top: 20px; text-align: right;">
                                <button type="submit" id="submitBtn">
                                    <span class="material-symbols-outlined">save</span> Salva
                                </button>
                            </div>
                        </form>
                        <!-- Istruzioni per iOS (inizialmente nascoste) -->
<div id="ios-instructions" class="ios-instructions" style="display: none;">
    <div class="alert alert-info">
        <h4><span class="material-symbols-outlined">info</span> Suggerimenti per utenti iOS</h4>
        <p>Se riscontri problemi con il calendario:</p>
        <ul>
            <li>Tocca una sola volta sul giorno desiderato</li>
            <li>Evita di cambiare mese e anno contemporaneamente</li>
            <li>Se il calendario si blocca, ricarica la pagina</li>
        </ul>
    </div>
</div>

                    </div>
                </div>

                <div class="card">
                    <h2>Ultime Entrate</h2>
                    <div id="timeEntries">
                        <!-- Dynamic content -->
                    </div>
                </div>
            </div>

            <!-- Sezione Calendario -->
            <div id="calendar-section" class="section">
                <div class="card">
                    <h2>Calendario</h2>
                    <div class="calendar-container" id="calendarEntries">
                         <!-- Calendar generated by JS -->
                    </div>
                    <!-- Container for the summary, content now generated by JS -->
                    <div class="monthly-summary" id="monthlySummary" style="margin-top: 1rem; padding: 0;">
                        <!-- Content will be injected by updateMonthlySummary -->
                        <!-- Ensure all previous inner divs like .monthly-report-stats are removed -->
                            </div>
                </div>
            </div>

            <!-- Sezione Impostazioni -->
            <div id="settings-section" class="section">
                <div class="card">
                    <h2>Impostazioni</h2>
                    <div class="settings-container">
                        <div class="setting-item">
                            <span class="setting-label">Tema Scuro</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="darkTheme">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                        <div class="setting-item">
                            <label for="userName" class="setting-label">Nome Utente</label>
                            <div style="display: flex; gap: 10px; flex-grow: 1;">
                                <input type="text" id="userName" class="settings-input" placeholder="Inserisci il tuo nome">
                                <button id="saveUserName">
                                    <span class="material-symbols-outlined">save</span> Salva
                                </button>
                            </div>
                        </div>
                        <div class="setting-item">
                            <span class="setting-label">Esporta Dati</span>
                            <button id="exportData">
                                <span class="material-symbols-outlined">download</span> Esporta Dati
                            </button>
                        </div>
                         <div class="setting-item">
                            <span class="setting-label">Importa Dati</span>
                            <button id="importData">
                                <span class="material-symbols-outlined">upload</span> Importa Dati
                            </button>
                        </div>

                        <div class="setting-item">
                            <span class="setting-label">Aggiorna App</span>
                            <button id="forceUpdate">
                                <span class="material-symbols-outlined">refresh</span> Forza Aggiornamento!
                            </button>
                        </div>

                        <div class="setting-item">
                            <span class="setting-label">PIN Admin</span>
                            <div style="display: flex; gap: 10px; flex-grow: 1;">
                                <input type="password" id="adminPin" class="settings-input" placeholder="Inserisci PIN Admin" maxlength="7">
                                <button id="unlockAdminFeatures">
                                    <span class="material-symbols-outlined">lock_open</span> Sblocca
                                </button>
                                <button id="lockAdminFeatures" style="display: none;">
                                    <span class="material-symbols-outlined">lock</span> Blocca
                                </button>
                            </div>
                        </div>

                        <div class="setting-item" style="flex-direction: column; align-items: stretch;">
                            <span class="setting-label">Installa App</span>

                            <!-- Pulsante per Android e desktop -->
                            <div style="display: flex; align-items: center; margin-bottom: 10px;">
                                <button id="installPwa" class="install-button" style="display: none; margin-right: 10px; background-color: var(--md-sys-color-primary); color: var(--md-sys-color-on-primary); font-weight: bold; padding: 12px 20px;">
                                    <span class="material-symbols-outlined">download_for_offline</span> Installa App
                                </button>
                                <span id="pwaStatus" style="font-size: 0.9rem; color: var(--md-sys-color-on-surface-variant);">
                                    Verifica disponibilità...
                                </span>
                            </div>

                            <!-- Pulsante di installazione alternativo (più visibile) -->
                            <div class="card" style="margin-top: 15px; background-color: var(--md-sys-color-primary-container); display: none;" id="installCardPrompt">
                                <div style="display: flex; align-items: center; justify-content: space-between;">
                                    <div>
                                        <h3 style="color: var(--md-sys-color-on-primary-container); margin-bottom: 5px;">Installa l'app Ore PWS</h3>
                                        <p style="color: var(--md-sys-color-on-primary-container); margin-bottom: 0;">Usa l'app anche offline e accedi più velocemente!</p>
                                    </div>
                                    <button class="install-button" style="background-color: var(--md-sys-color-primary); color: var(--md-sys-color-on-primary); font-weight: bold;">
                                        <span class="material-symbols-outlined">download_for_offline</span> Installa
                                    </button>
                                </div>
                            </div>

                            <!-- Istruzioni per iOS (inizialmente nascoste) -->
                            <div id="iosInstructions" style="display: none; margin-top: 10px; padding: 15px; background-color: var(--md-sys-color-surface-variant); border-radius: var(--border-radius-medium);">
                                <h3 style="margin-top: 0; color: var(--md-sys-color-primary); font-size: 1rem; margin-bottom: 10px;">
                                    Istruzioni per iOS:
                                </h3>
                                <ol style="margin: 0; padding-left: 20px; font-size: 0.9rem;">
                                    <li>Apri questa pagina in <strong>Safari</strong></li>
                                    <li>Tocca l'icona di condivisione <span style="display: inline-block; background-color: var(--md-sys-color-primary); color: white; width: 20px; height: 20px; text-align: center; border-radius: 4px; font-size: 14px;">↑</span></li>
                                    <li>Scorri verso il basso e tocca <strong>"Aggiungi alla schermata Home"</strong></li>
                                    <li>Conferma toccando <strong>"Aggiungi"</strong></li>
                                </ol>
                            </div>
                        </div>

                        <div class="setting-item" style="flex-direction: column; align-items: stretch;">
                             <span class="setting-label" style="margin-bottom: 1rem;">Gestione Mezzi</span>
                            <div class="vehicles-manager">
                                <div class="vehicles-form">
                                    <div style="display: flex; gap: 10px; width: 100%; margin-bottom: 10px; flex-wrap: wrap;">
                                        <input type="text" id="vehicleName" class="settings-input" placeholder="Nome mezzo" style="flex: 2 1 150px;">
                                        <input type="text" id="vehiclePlate" class="settings-input" placeholder="Targa (opzionale)" style="flex: 1 1 100px;">
                                        <button id="addVehicle" style="flex-shrink: 0;">
                                             <span class="material-symbols-outlined">add</span> Aggiungi
                                        </button>
                                    </div>
                                </div>
                                <div id="vehiclesList" class="vehicles-list" style="margin-top: 10px; max-height: 200px; overflow-y: auto;">
                                    <!-- Dynamic list -->
                                </div>
                                <div style="font-size: 0.8rem; color: var(--md-sys-color-on-surface-variant); margin-top: 5px;">
                                    Nota: è possibile inserire fino a un massimo di 10 mezzi.
                                </div>
                            </div>
                        </div>



                        <!-- Sezione Backup Cloud -->
                        <div class="setting-item" style="flex-direction: column; align-items: stretch;">
                            <span class="setting-label" style="margin-bottom: 1rem;">Backup Cloud</span>
                            <div class="cloud-backup-container">
                                <div class="cloud-provider-selection">
                                    <p class="provider-description">Seleziona il servizio cloud che desideri utilizzare per il backup dei tuoi dati.</p>

                                    <div class="provider-options">
                                        <!-- Google Drive -->
                                        <div class="provider-option" data-provider="google">
                                            <div class="provider-logo">
                                                <span class="material-symbols-outlined" style="color: #4285F4; font-size: 28px;">cloud</span>
                                            </div>
                                            <div class="provider-info">
                                                <h4>Google Drive</h4>
                                                <p>Backup su Google Drive utilizzando il tuo account Google</p>
                                            </div>
                                            <div class="provider-status">
                                                <span class="status-indicator" id="googleStatus"></span>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div id="cloudAccountSection" class="cloud-account-section">
                                    <div id="cloudAccountInfo" class="cloud-account-info">
                                        <p>Seleziona un provider e accedi per abilitare il backup su cloud</p>
                                    </div>

                                    <div id="loginButtonsContainer" class="login-buttons-container">
                                        <!-- I pulsanti di login verranno generati dinamicamente in base al provider selezionato -->
                                    </div>

                                    <button id="cloudLogoutBtn" class="cloud-logout-btn" style="display: none;">
                                        <span class="material-symbols-outlined">logout</span>
                                        Disconnetti
                                    </button>
                                </div>

                                <div id="cloudBackupControls" class="cloud-backup-controls" style="display: none;">
                                    <div class="backup-status-container">
                                        <span class="backup-status-label">Stato Backup:</span>
                                        <span id="lastBackupTime" class="backup-status-value">Mai eseguito</span>
                                    </div>

                                    <div class="backup-actions">
                                        <button id="manualBackupBtn" class="backup-btn" data-original-text="Backup Manuale">
                                            <span class="material-symbols-outlined">backup</span>
                                            Backup Manuale
                                        </button>
                                        <button id="restoreBackupBtn" class="backup-btn" data-original-text="Ripristina Backup">
                                            <span class="material-symbols-outlined">restore</span>
                                            Ripristina Backup
                                        </button>
                                    </div>

                                    <div class="backup-settings">
                                        <div class="backup-setting-item">
                                            <span class="backup-setting-label">Backup Automatico</span>
                                            <label class="toggle-switch">
                                                <input type="checkbox" id="autoBackupToggle" checked>
                                                <span class="toggle-slider"></span>
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="setting-item">
                            <span class="setting-label">Sfondo Animato PWS</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="pwsParticlesToggle">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>

                        <div class="setting-item" id="particleControlToggle">
                            <span class="setting-label">Controllo Particelle</span>
                            <button class="toggle-button" id="toggleParticleControls">
                                <span class="material-symbols-outlined">tune</span>
                                <span class="toggle-text">Configura</span>
                            </button>
                        </div>

                        <!-- Pannello di controllo particelle (nascosto di default) -->
                        <div id="particleControlPanel" class="particle-control-panel" style="display: none;">
                            <div class="particle-control-group">
                                <h3>Aspetto Particelle</h3>

                                <!-- Numero di particelle -->
                                <div class="particle-control-item">
                                    <label for="particleCount">Numero di particelle: <span id="particleCountValue">50</span></label>
                                    <input type="range" id="particleCount" min="10" max="200" step="5" value="50">
                                </div>

                                <!-- Forma delle particelle -->
                                <div class="particle-control-item">
                                    <label for="particleShape">Forma:</label>
                                    <select id="particleShape">
                                        <option value="circle">Cerchio</option>
                                        <option value="square">Quadrato</option>
                                        <option value="triangle">Triangolo</option>
                                        <option value="star">Stella</option>
                                        <option value="polygon">Poligono</option>
                                        <option value="image">Immagine</option>
                                    </select>
                                </div>

                                <!-- Immagine personalizzata (visibile solo se selezionata l'opzione immagine) -->
                                <div class="particle-control-item" id="particleImageContainer" style="display: none;">
                                    <label for="particleImage">Immagine personalizzata:</label>
                                    <input type="file" id="particleImage" accept="image/*">
                                    <div id="particleImagePreview" style="margin-top: 5px; max-width: 100px; max-height: 100px;"></div>
                                </div>

                                <!-- Colori delle particelle -->
                                <div class="particle-control-item">
                                    <label>Colori:</label>
                                    <div class="color-picker-container">
                                        <input type="color" id="particleColor1" value="#00ffff">
                                        <input type="color" id="particleColor2" value="#ff00ff">
                                        <button id="addColorBtn" class="small-btn">
                                            <span class="material-symbols-outlined">add</span>
                                        </button>
                                    </div>
                                    <div id="extraColorsContainer"></div>
                                </div>

                                <!-- Opacità delle particelle -->
                                <div class="particle-control-item">
                                    <label for="particleOpacity">Opacità: <span id="particleOpacityValue">0.8</span></label>
                                    <input type="range" id="particleOpacity" min="0.1" max="1" step="0.1" value="0.8">
                                </div>

                                <!-- Dimensione delle particelle -->
                                <div class="particle-control-item">
                                    <label>Dimensione (min/max):</label>
                                    <div style="display: flex; gap: 10px; align-items: center;">
                                        <input type="number" id="particleSizeMin" min="1" max="20" value="3" style="width: 60px;">
                                        <span>-</span>
                                        <input type="number" id="particleSizeMax" min="1" max="50" value="7" style="width: 60px;">
                                    </div>
                                </div>
                            </div>

                            <div class="particle-control-group">
                                <h3>Movimento e Connessioni</h3>

                                <!-- Velocità delle particelle -->
                                <div class="particle-control-item">
                                    <label for="particleSpeed">Velocità: <span id="particleSpeedValue">2</span></label>
                                    <input type="range" id="particleSpeed" min="0.1" max="10" step="0.1" value="2">
                                </div>

                                <!-- Distanza di collegamento -->
                                <div class="particle-control-item">
                                    <label for="linkDistance">Distanza collegamenti: <span id="linkDistanceValue">120</span>px</label>
                                    <input type="range" id="linkDistance" min="50" max="300" step="10" value="120">
                                </div>

                                <!-- Colore dei collegamenti -->
                                <div class="particle-control-item">
                                    <label for="linkColor">Colore collegamenti:</label>
                                    <input type="color" id="linkColor" value="#ffffff">
                                </div>

                                <!-- Opacità dei collegamenti -->
                                <div class="particle-control-item">
                                    <label for="linkOpacity">Opacità collegamenti: <span id="linkOpacityValue">0.3</span></label>
                                    <input type="range" id="linkOpacity" min="0.1" max="1" step="0.1" value="0.3">
                                </div>
                            </div>

                            <div class="particle-control-group">
                                <h3>Interattività</h3>

                                <!-- Nota per dispositivi mobili -->
                                <div class="particle-control-item mobile-note" style="display: none; margin-bottom: 15px; padding: 10px; background-color: var(--md-sys-color-primary-container); border-radius: var(--border-radius-small); color: var(--md-sys-color-on-primary-container);">
                                    <strong>Nota:</strong> Su dispositivi mobili, l'interazione avviene tramite tocco. Gli effetti al passaggio del mouse funzioneranno anche con il tocco.
                                </div>

                                <!-- Interazione al passaggio del mouse -->
                                <div class="particle-control-item">
                                    <label for="hoverEffect">Effetto al passaggio del mouse:</label>
                                    <select id="hoverEffect">
                                        <option value="none">Nessuno</option>
                                        <option value="grab" selected>Attrazione</option>
                                        <option value="bubble">Bolla</option>
                                        <option value="repulse">Repulsione</option>
                                        <option value="connect">Connessione</option>
                                    </select>
                                </div>

                                <!-- Interazione al click -->
                                <div class="particle-control-item">
                                    <label for="clickEffect">Effetto al click:</label>
                                    <select id="clickEffect">
                                        <option value="none">Nessuno</option>
                                        <option value="push" selected>Aggiungi particelle</option>
                                        <option value="remove">Rimuovi particelle</option>
                                        <option value="bubble">Bolla</option>
                                        <option value="repulse">Repulsione</option>
                                        <option value="connect">Connessione</option>
                                    </select>
                                </div>
                            </div>

                            <div class="particle-control-actions">
                                <button id="resetParticleSettings" class="secondary-btn">
                                    <span class="material-symbols-outlined">restart_alt</span> Ripristina Default
                                </button>
                                <button id="applyParticleSettings" class="primary-btn">
                                    <span class="material-symbols-outlined">check</span> Applica
                                </button>
                            </div>
                        </div>

                        <div class="setting-item">
                            <span class="setting-label">Cancella Dati</span>
                            <button id="clearData" class="delete-btn">
                                <span class="material-symbols-outlined">delete_forever</span> Cancella Tutto
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Sezione Contatti -->
            <div id="contacts-section" class="section">
                <div class="card">
                    <h2>Contatti PWS Group</h2>

                    <div class="contact-address">
                        <div class="contact-item">
                            <span class="material-symbols-outlined">location_on</span>
                            <span>Trezzano S.N(MI) 20090, via G.Boccaccio, 95/c</span>
                        </div>
                        <div class="contact-item">
                             <span class="material-symbols-outlined">call</span>
                            <span>Tel: 02 93219393</span>
                        </div>
                    </div>

                    <div class="qr-code-container">
                        <h4>Scansiona il QR Code per visitare il nostro sito web</h4>
                        <div id="qrcode">
                            <!-- QR code generated by JS -->
                        </div>
                    </div>

                    <div class="qr-code-container">
                        <h4>Scansiona il QR Code per copiare i contatti e l'indirizzo</h4>
                        <div id="contacts-qrcode">
                             <!-- QR code generated by JS -->
                        </div>
                    </div>

                    <div class="contacts-container">
                        <div class="contact-group">
                            <h3>CEO PWS Group</h3>
                            <div class="contact-card">
                                <div class="contact-name">Marcello Cipriani</div>
                                <div class="contact-info">
                                    <div class="contact-item">
                                        <span class="material-symbols-outlined">call</span>
                                        <a href="tel:+393481282035">+39.348.1282035</a>
                                    </div>
                                    <div class="contact-item">
                                        <span class="material-symbols-outlined">mail</span>
                                        <a href="mailto:m.cipriani@pwsdecoart.it">m.cipriani@pwsdecoart.it</a>
                                    </div>
                                </div>
                            </div>
                        </div>

                         <div class="contact-group">
                            <h3>Operation Director</h3>
                            <div class="contact-card">
                                <div class="contact-name">Mauro Pirovano</div>
                                <div class="contact-info">
                                    <div class="contact-item">
                                         <span class="material-symbols-outlined">call</span>
                                        <a href="tel:+393341041545">+39.334.1041545</a>
                                    </div>
                                    <div class="contact-item">
                                        <span class="material-symbols-outlined">mail</span>
                                        <a href="mailto:m.pirovano@pwsdecoart.it">m.pirovano@pwsdecoart.it</a>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="contact-group">
                            <h3>Sales Director</h3>
                            <div class="contact-card">
                                <div class="contact-name">Danilo Rosa</div>
                                <div class="contact-info">
                                     <div class="contact-item">
                                        <span class="material-symbols-outlined">mail</span>
                                        <a href="mailto:d.rosa@pwsdecoart.it">d.rosa@pwsdecoart.it</a>
                                    </div>
                                </div>
                            </div>
                        </div>

                         <div class="contact-group">
                            <h3>Commerciale</h3>
                            <div class="contact-card">
                                <div class="contact-name">Roberto Bonzanini</div>
                                <div class="contact-info">
                                    <div class="contact-item">
                                         <span class="material-symbols-outlined">mail</span>
                                        <a href="mailto:r.bonzanini@pwsdecoart.it">r.bonzanini@pwsdecoart.it</a>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="contact-group">
                            <h3>Ufficio Tecnico</h3>
                            <div class="contact-card">
                                <div class="contact-name">Nicola Manniello</div>
                                <div class="contact-info">
                                     <div class="contact-item">
                                         <span class="material-symbols-outlined">mail</span>
                                        <a href="mailto:n.manniello@pwsdecoart.it">n.manniello@pwsdecoart.it</a>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="contact-group">
                            <h3>Ufficio Grafico</h3>
                            <div class="contact-card">
                                <div class="contact-name">Claudia Favagrossa</div>
                                <div class="contact-info">
                                    <div class="contact-item">
                                         <span class="material-symbols-outlined">mail</span>
                                        <a href="mailto:c.favagrossa@pwsdecoart.it">c.favagrossa@pwsdecoart.it</a>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="contact-group">
                            <h3>Amministrazione</h3>
                            <div class="contact-card">
                                <div class="contact-name">Daniela Dicensi</div>
                                <div class="contact-info">
                                    <div class="contact-item">
                                         <span class="material-symbols-outlined">mail</span>
                                        <a href="mailto:d.dicensi@pwsdecoart.it">d.dicensi@pwsdecoart.it</a>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <!-- Add other contacts similarly -->

                        <!-- Pulsante per aggiungere nuovi contatti -->
                        <div class="add-contact-container">
                            <button id="addContactBtn" class="btn">
                                <span class="material-symbols-outlined">person_add</span> Aggiungi Contatto
                            </button>
                        </div>
                    </div>

                    <!-- Modal per aggiungere un nuovo contatto -->
                    <div id="addContactModal" class="modal">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h3>Aggiungi Nuovo Contatto</h3>
                                <span class="close-modal" id="closeContactModal">&times;</span>
                            </div>
                            <div class="modal-body">
                                <form id="addContactForm">
                                    <div class="form-group">
                                        <label for="contactDepartment">Reparto/Ruolo</label>
                                        <input type="text" id="contactDepartment" required placeholder="Es. Ufficio Acquisti">
                                    </div>
                                    <div class="form-group">
                                        <label for="contactName">Nome e Cognome</label>
                                        <input type="text" id="contactName" required placeholder="Es. Mario Rossi">
                                    </div>
                                    <div class="form-group">
                                        <label for="contactEmail">Email</label>
                                        <input type="email" id="contactEmail" required placeholder="Es. m.rossi@pwsdecoart.it">
                                    </div>
                                    <div class="form-group">
                                        <label for="contactPhone">Telefono (opzionale)</label>
                                        <input type="tel" id="contactPhone" placeholder="Es. +39.333.1234567">
                                    </div>
                                    <div class="form-actions">
                                        <button type="button" id="cancelAddContact" class="btn-secondary">Annulla</button>
                                        <button type="submit" id="saveContactBtn">Salva Contatto</button>
                                    </div>
                                </form>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

             <!-- Sezione Riepilogo Mensile -->
            <div id="monthly-report-section" class="section">
                <div class="card">
                    <div class="section-header">
                        <h2>Riepilogo Mensile</h2>
                        <div class="section-controls">
                            <div class="month-selector">
                                <select id="exportMonthSelect"></select>
                            </div>
                            <button id="exportMonthlyExcelTemplate" class="export-btn excel-btn" style="background-color: #FF9800;">
                                <span class="material-symbols-outlined">download_for_offline</span> Genera Excel
                            </button>
                            <button id="exportMonthlyPdf" class="export-btn pdf-btn">
                                <span class="material-symbols-outlined">picture_as_pdf</span> Converti PDF
                            </button>
                        </div>
                    </div>
                    <!-- Sezione per i file Excel esportati (collassabile) -->
                    <div class="excel-files-section">
                        <div class="excel-files-header">
                            <button id="toggleExcelFiles" class="toggle-excel-files">
                                <span class="material-symbols-outlined toggle-icon">expand_more</span>
                                <h3>File Excel Esportati</h3>
                            </button>
                        </div>
                        <div id="excelFilesContainer" class="excel-files-container collapsed">
                            <div id="excelFilesList" class="excel-files-list">
                                <!-- Lista dei file Excel esportati -->
                                <div class="empty-list-message">Nessun file Excel esportato</div>
                            </div>
                        </div>
                    </div>

                    <div id="monthlyReportContent" class="monthly-report-content">
                        <!-- Dynamic content -->
                    </div>
                </div>
            </div>

            <!-- Sezione Cash -->
            <div id="cash-section" class="section">
                <div class="card">
                    <div class="section-header">
                        <h2>Calcolo Busta Paga</h2>
                        <div class="section-actions">
                            <select id="cashMonthSelect" class="month-select">
                                <!-- Options will be populated by JS -->
                            </select>
                        </div>
                    </div>

                    <div class="cash-settings-container">
                        <h3>Impostazioni Tariffe</h3>
                        <div class="form-row">
                            <div class="form-group-inline">
                                <label for="normalHourRate">Tariffa Ore Normali (€/h)</label>
                                <input type="number" id="normalHourRate" step="0.01" min="0" placeholder="0.00">
                            </div>
                            <div class="form-group-inline">
                                <label for="nightHourRate">Tariffa Ore Notturne (€/h)</label>
                                <input type="number" id="nightHourRate" step="0.01" min="0" placeholder="0.00">
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-group-inline">
                                <label for="transferDayRate">Tariffa Giorno Trasferta (€/giorno)</label>
                                <input type="number" id="transferDayRate" step="0.01" min="0" placeholder="0.00">
                            </div>
                            <div class="form-group-inline">
                                <label for="sickDayRate">Tariffa Giorno Malattia (€/giorno)</label>
                                <input type="number" id="sickDayRate" step="0.01" min="0" placeholder="0.00">
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-group-inline">
                                <label for="vacationDayRate">Tariffa Giorno Ferie (€/giorno)</label>
                                <input type="number" id="vacationDayRate" step="0.01" min="0" placeholder="0.00">
                            </div>
                            <div class="form-group-inline">
                                <label for="igpBresciaRate">Tariffa IGP Brescia (€/giorno)</label>
                                <input type="number" id="igpBresciaRate" step="0.01" min="0" placeholder="0.00">
                            </div>
                        </div>
                        <div class="form-row">
                            <div class="form-group-inline">
                                <label for="holidayHourRate">Tariffa Ore Festive (€/h)</label>
                                <input type="number" id="holidayHourRate" step="0.01" min="0" placeholder="0.00">
                            </div>
                        </div>
                        <button id="saveRatesBtn" class="btn">
                            <span class="material-symbols-outlined">save</span>
                            Salva Tariffe
                        </button>
                    </div>

                    <div class="cash-results-container">
                        <h3>Calcolo Busta Paga</h3>
                        <div class="cash-results">
                            <div class="cash-result-item">
                                <div class="cash-result-label">Ore Normali</div>
                                <div class="cash-result-hours" id="normalHours">0h</div>
                                <div class="cash-result-amount" id="normalAmount">€0.00</div>
                            </div>
                            <div class="cash-result-item">
                                <div class="cash-result-label">Ore Notturne</div>
                                <div class="cash-result-hours" id="nightHours">0h</div>
                                <div class="cash-result-amount" id="nightAmount">€0.00</div>
                            </div>
                            <div class="cash-result-item">
                                <div class="cash-result-label">Ore Festive</div>
                                <div class="cash-result-hours" id="holidayHours">0h</div>
                                <div class="cash-result-amount" id="holidayAmount">€0.00</div>
                            </div>
                            <div class="cash-result-item">
                                <div class="cash-result-label">Giorni Trasferta</div>
                                <div class="cash-result-hours" id="transferDays">0g</div>
                                <div class="cash-result-amount" id="transferAmount">€0.00</div>
                            </div>
                            <div class="cash-result-item">
                                <div class="cash-result-label">Giorni Malattia</div>
                                <div class="cash-result-hours" id="sickDays">0g</div>
                                <div class="cash-result-amount" id="sickAmount">€0.00</div>
                            </div>
                            <div class="cash-result-item">
                                <div class="cash-result-label">Giorni Ferie</div>
                                <div class="cash-result-hours" id="vacationDays">0g</div>
                                <div class="cash-result-amount" id="vacationAmount">€0.00</div>
                            </div>
                            <div class="cash-result-item">
                                <div class="cash-result-label">IGP Brescia</div>
                                <div class="cash-result-hours" id="igpBresciaDays">0g</div>
                                <div class="cash-result-amount" id="igpBresciaAmount">€0.00</div>
                            </div>
                            <div class="cash-result-item cash-result-total">
                                <div class="cash-result-label">TOTALE</div>
                                <div class="cash-result-hours"></div>
                                <div class="cash-result-amount" id="totalAmount">€0.00</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

             <!-- Sezione Ferie/malattie -->
            <div id="ferie-malattie-section" class="section">
                <div class="card">
                    <h2>Ferie e Malattie</h2>
                    <div class="ferie-malattie-content">
                        <div class="ferie-malattie-form">
                            <div class="form-group">
                                <label for="ferieMalattieType">Tipo</label>
                                <select id="ferieMalattieType" class="form-control">
                                    <option value="ferie">Ferie</option>
                                    <option value="malattia">Malattia</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label class="checkbox-label">
                                    <input type="checkbox" id="multipleDays" class="form-control">
                                    <span>Più giorni</span>
                                </label>
                            </div>
                            <div id="singleDateGroup" class="form-group">
                                <label for="ferieMalattieDate">Data</label>
                                <input type="text" id="ferieMalattieDate" class="form-control datepicker-ferie" placeholder="gg/mm/aaaa">
                            </div>
                            <div id="dateRangeGroup" class="form-group" style="display: none;">
                                <div class="form-row">
                                    <div class="form-group-inline">
                                        <label for="ferieMalattieStartDate">Data inizio</label>
                                        <input type="text" id="ferieMalattieStartDate" class="form-control datepicker-ferie" placeholder="gg/mm/aaaa">
                                    </div>
                                    <div class="form-group-inline">
                                        <label for="ferieMalattieEndDate">Data fine</label>
                                        <input type="text" id="ferieMalattieEndDate" class="form-control datepicker-ferie" placeholder="gg/mm/aaaa">
                                    </div>
                                </div>
                            </div>
                            <div class="form-group">
                                <label for="ferieMalattieNote">Note</label>
                                <textarea id="ferieMalattieNote" class="form-control" rows="3" placeholder="Aggiungi note (opzionale)"></textarea>
                            </div>
                            <div style="text-align: right;">
                                <button id="saveFerieMalattie">
                                    <span class="material-symbols-outlined">save</span> Salva Assenza
                                </button>
                            </div>
                        </div>
                        <div class="ferie-malattie-list">
                            <h3>Riepilogo Assenze</h3>
                            <div id="ferieMalattieEntries">
                                <!-- Dynamic content -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>

        </div>
    </main>

    <nav class="bottom-nav">
        <a href="#" class="nav-item active" data-section="home-section">
            <span class="material-symbols-outlined">home</span>
            <span>Home</span>
        </a>
        <a href="#" class="nav-item" data-section="calendar-section">
            <span class="material-symbols-outlined">calendar_month</span>
            <span>Calendario</span>
        </a>
        <a href="#" class="nav-item" data-section="monthly-report-section">
             <span class="material-symbols-outlined">summarize</span>
            <span>Riepilogo</span>
        </a>
        <a href="#" class="nav-item" data-section="cash-section" style="display: none;" id="cash-nav-item">
            <span class="material-symbols-outlined">payments</span>
            <span>Cash</span>
        </a>
        <a href="#" class="nav-item" data-section="ferie-malattie-section">
            <span class="material-symbols-outlined">hotel_class</span> <!-- or event_busy / medical_services -->
            <span>Assenze</span>
        </a>
        <a href="#" class="nav-item" data-section="contacts-section">
            <span class="material-symbols-outlined">contacts</span>
            <span>Contatti</span>
        </a>
        <a href="#" class="nav-item" data-section="settings-section">
            <span class="material-symbols-outlined">settings</span>
            <span>Impostazioni</span>
        </a>
    </nav>

    <!-- Modale per i dettagli del giorno -->
    <div id="dayModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="modalTitle">Dettagli Giorno</h3>
                <!-- Moved holiday info placeholder here -->
                <div id="modalHolidayInfo" class="modal-holiday-info" style="text-align: center; margin-top: 0.5rem; padding: 0.3rem 0.5rem; background-color: var(--md-sys-color-surface-variant); border-radius: var(--border-radius-small); color: var(--md-sys-color-on-surface-variant); display: none; width: fit-content; margin-left: auto; margin-right: auto;">
                    <!-- Holiday name will be inserted here by JS -->
                </div>
                <button class="close-modal">
                    <span class="material-symbols-outlined">close</span>
                </button>
            </div>
            <div class="modal-body">
                <!-- Summary section -->
                <div class="day-summary">
                    <div class="day-summary-item">
                        <span class="day-summary-value" id="modalTotalHours">0h</span>
                        <span class="day-summary-label">Ore Totali</span>
                    </div>
                    <div class="day-summary-item">
                        <span class="day-summary-value" id="modalTransferta"></span>
                        <span class="day-summary-label">Giorni di Trasferta</span>
                    </div>
                    <div class="day-summary-item">
                        <span class="day-summary-value" id="modalNotturne">0h</span>
                        <span class="day-summary-label">Notturne</span>
                    </div>
                </div>
                 <!-- Action buttons -->
                 <div class="modal-actions" style="display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: center; margin-top: 1rem; margin-bottom: 1rem;">
                     <button id="addEntryBtn" class="action-btn">
                         <span class="material-symbols-outlined">add_circle</span> Aggiungi Voce
                     </button>
                     <!-- New buttons -->
                     <button id="markFerieBtn" class="action-btn tertiary-btn">
                         <span class="material-symbols-outlined">beach_access</span> Segna Ferie
                     </button>
                     <button id="markMalattiaBtn" class="action-btn secondary-btn">
                         <span class="material-symbols-outlined">sick</span> Segna Malattia
                     </button>
                 </div>
                 <!-- Entries list -->
                <div class="day-entries" id="modalEntries">
                    <!-- Dynamic entries -->
                </div>
            </div>
            <!-- Optional Footer -->
            <!-- <div class="modal-footer">
                 <button class="btn text-btn">Azione Footer</button>
            </div> -->
        </div>
    </div>

    <!-- Toast Notification Placeholder -->
    <div id="toast-container"></div>

    <!-- Gratta e Vinci Overlay -->
    <div id="scratchCardOverlay">
        <button class="scratch-card-close" id="closeScratchCard">
            <span class="material-symbols-outlined">close</span>
        </button>
        <div class="scratch-card-container">
            <div class="scratch-card-content">
                <p>Bravo hai vinto una lavatrice!!!</p>
                <span>Ora torna a lavorare PIRLA!</span>
            </div>
            <!-- Canvas per il grattamento realistico -->
            <canvas id="scratchCanvas"></canvas>
        </div>
    </div>

    <!-- Overlay per la GIF del supereroe rimosso per ottimizzazione -->

        <!-- Audio per lo scherzo del pulsante che scappa - Ottimizzato per iOS -->
        <!-- Gli elementi audio sono creati dinamicamente via JavaScript per compatibilità iOS -->
        <div id="audio-container" style="display:none;"></div>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script>
        // Ensure this is the very start of the script block or globally accessible
        const DEFAULT_VEHICLES = [
            { id: 'default_panda10', name: 'Panda 10' },
            { id: 'default_doblo_metano7', name: 'Doblò Metano 7' },
            { id: 'default_doblo11', name: 'Doblò 11' },
            { id: 'default_doblo9', name: 'Doblò 9' },
            { id: 'default_ducato_ch', name: 'Ducato CH' },
            { id: 'default_personale', name: 'Personale' } // Added new default vehicle
        ];

        // --- Utility Functions (Database, Toast, etc.) ---

        // Funzione per gestire lo spazio nel localStorage
        function manageLocalStorageSpace() {
            try {
                // Calcola lo spazio utilizzato
                let totalSize = 0;
                let itemSizes = {};

                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    const value = localStorage.getItem(key);
                    const size = (key.length + value.length) * 2; // Approssimazione in byte (2 byte per carattere)

                    totalSize += size;
                    itemSizes[key] = size;
                }

                // Converti in MB
                const totalSizeMB = totalSize / (1024 * 1024);

                // Log dello spazio utilizzato
                console.log(`Spazio localStorage utilizzato: ${totalSizeMB.toFixed(2)}MB`);

                // Se lo spazio utilizzato supera i 4MB, pulisci i dati meno importanti
                if (totalSizeMB > 4) {
                    console.warn("Spazio localStorage quasi esaurito, pulizia in corso...");

                    // Rimuovi i dati temporanei o meno importanti
                    const lowPriorityKeys = [
                        'reminderSettings', // Già disabilitato
                        'pws-particles-enabled', // Configurazione particelle
                        'excelFiles', // File Excel (già gestiti separatamente)
                        'lastViewedMonth', // Preferenza UI
                        'lastViewedYear', // Preferenza UI
                        'lastSelectedVehicle' // Preferenza UI
                    ];

                    // Rimuovi i dati meno importanti
                    lowPriorityKeys.forEach(key => {
                        if (localStorage.getItem(key)) {
                            console.log(`Rimozione dati non essenziali: ${key}`);
                            localStorage.removeItem(key);
                        }
                    });

                    // Verifica lo spazio dopo la pulizia
                    let newTotalSize = 0;
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        const value = localStorage.getItem(key);
                        newTotalSize += (key.length + value.length) * 2;
                    }

                    const newTotalSizeMB = newTotalSize / (1024 * 1024);
                    console.log(`Nuovo spazio utilizzato dopo pulizia: ${newTotalSizeMB.toFixed(2)}MB`);

                    // Se ancora troppo grande, mostra un avviso
                    if (newTotalSizeMB > 4.5) {
                        showToast("Memoria locale quasi piena. Considera di esportare e poi cancellare alcuni dati.", "warning", 5000);
                    }
                }

                return totalSizeMB;
            } catch (error) {
                console.error("Errore nella gestione dello spazio localStorage:", error);
                return -1;
            }
        }

        // Esegui la gestione dello spazio all'avvio e periodicamente
        window.addEventListener('load', () => {
            // Controlla lo spazio all'avvio
            setTimeout(manageLocalStorageSpace, 5000);

            // Controlla lo spazio ogni ora
            setInterval(manageLocalStorageSpace, 60 * 60 * 1000);
        });

        // ... other code like getDb, etc. ...

        // Sezione rimossa - Codice duplicato

        // Fixed initDatepicker definition to prevent ReferenceError
        function initDatepicker() {
            // Rileva iOS per mostrare istruzioni speciali e gestione crash-safe
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
            const isIOSSafari = /iPad|iPhone|iPod/.test(navigator.userAgent) && /WebKit/.test(navigator.userAgent) && !/CriOS/.test(navigator.userAgent);
            
            if (isIOS) {
                const iosInstructions = document.getElementById('ios-instructions');
                if (iosInstructions) {
                    iosInstructions.style.display = 'block';
                }
            }

            const dateInput = document.getElementById('date');
            if (!dateInput) return;

            console.log("Inizializzazione datepicker Material Design - iOS Safe Mode:", isIOSSafari);

            try {
                // Hide the date input field visually using CSS added earlier
                // dateInput.style.display = 'none'; // No longer needed if CSS handles it

                // Destroy any existing instance
                const oldInstance = dateInput._flatpickr;
                if (oldInstance) {
                    try {
                        oldInstance.destroy();
                        console.log("Istanza Flatpickr precedente distrutta.");
                    } catch (err) {
                        console.warn("Errore durante la distruzione dell'istanza precedente:", err);
                    }
                }

                // Set today's date if no date is set
                if (!dateInput.value) {
                    const today = new Date();
                    dateInput.value = formatDateForInput(today); // Use helper
                    console.log("Nessuna data impostata, uso oggi:", dateInput.value);
                } else {
                    console.log("Data già impostata:", dateInput.value);
                }

                // Store a global reference to track the last selected date
                window.lastSelectedDate = dateInput.value;
                console.log("Data iniziale salvata globalmente:", window.lastSelectedDate);
                                // --- Inizializza le frecce giorno avanti/indietro ---
                function parseDate(str) {
                    if (!str) return new Date();
                    if (str.includes('/')) {
                        const [d, m, y] = str.split('/').map(Number);
                        return new Date(y, m - 1, d);
                    } else if (str.includes('-')) {
                        return new Date(str);
                    }
                    return new Date(str);
                }
                function formatDateForInput(d) {
                    return d.toLocaleDateString('it-IT').replace(/\//g, '/');
                }
                function updateDateByArrow(delta) {
                    let current = parseDate(dateInput.value);
                    if (isNaN(current)) current = new Date();
                    current.setDate(current.getDate() + delta);
                    const newDateStr = formatDateForInput(current);
                    dateInput.value = newDateStr;
                    if (dateInput._flatpickr) {
                        dateInput._flatpickr.setDate(newDateStr, true);
                    }
                    window.lastSelectedDate = newDateStr;
                    updateDateIndicator(current);
                }
                // Delego l'evento perché l'indicatore viene ricreato
                document.addEventListener('click', function(e) {
                    if (e.target.closest('#prevDayBtn')) {
                        e.preventDefault();
                        updateDateByArrow(-1);
                    } else if (e.target.closest('#nextDayBtn')) {
                        e.preventDefault();
                        updateDateByArrow(1);
                    }
                });

                // --- iOS-safe Inizializza le frecce giorno avanti/indietro ---
                setTimeout(function() {
                    console.log("🔄 Inizializzazione frecce navigazione data...");
                    
                    const setupArrowButtons = () => {
                        const prevBtn = document.getElementById('prevDayBtn');
                        const nextBtn = document.getElementById('nextDayBtn');
                        const dateIndicatorContent = document.getElementById('dateIndicator');
                        
                        console.log("🎯 Elementi trovati:", {
                            prevBtn: !!prevBtn,
                            nextBtn: !!nextBtn,
                            dateIndicatorContent: !!dateIndicatorContent
                        });

                        function parseDate(str) {
                            if (!str) return new Date();
                            if (str.includes('/')) {
                                const [d, m, y] = str.split('/').map(Number);
                                return new Date(y, m - 1, d);
                            } else if (str.includes('-')) {
                                return new Date(str);
                            }
                            return new Date(str);
                        }
                        
                        function formatDateForInput(d) {
                            return d.toLocaleDateString('it-IT').replace(/\//g, '/');
                        }
                        
                        function updateDate(delta) {
                            try {
                                console.log(`📅 Aggiornamento data con delta: ${delta}`);
                                let current = parseDate(dateInput.value || window.lastSelectedDate);
                                if (isNaN(current)) current = new Date();
                                
                                current.setDate(current.getDate() + delta);
                                const newDateStr = formatDateForInput(current);
                                
                                console.log(`📅 Nuova data: ${newDateStr}`);
                                
                                // Aggiorna input e flatpickr
                                dateInput.value = newDateStr;
                                window.lastSelectedDate = newDateStr;
                                
                                if (dateInput._flatpickr) {
                                    // Su iOS usa delay per evitare problemi
                                    if (isIOSSafari) {
                                        setTimeout(() => {
                                            dateInput._flatpickr.setDate(newDateStr, true);
                                        }, 50);
                                    } else {
                                        dateInput._flatpickr.setDate(newDateStr, true);
                                    }
                                }
                                
                                // Aggiorna indicatore visuale
                                if (isIOSSafari) {
                                    setTimeout(() => {
                                        updateDateIndicator(current);
                                    }, 100);
                                } else {
                                    updateDateIndicator(current);
                                }
                                
                                // Carica entry esistente per la nuova data
                                if (typeof loadExistingEntry === 'function') {
                                    if (isIOSSafari) {
                                        setTimeout(() => {
                                            loadExistingEntry(newDateStr);
                                        }, 150);
                                    } else {
                                        loadExistingEntry(newDateStr);
                                    }
                                }
                                
                            } catch (error) {
                                console.error("❌ Errore nell'aggiornamento data:", error);
                                if (typeof showToast === 'function') {
                                    showToast("Errore nel cambio data", "error");
                                }
                            }
                        }

                        // Setup freccia precedente
                        if (prevBtn) {
                            const handlePrevClick = function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                console.log("⬅️ Click freccia precedente");
                                updateDate(-1);
                            };
                            
                            // iOS-safe event handling
                            if (isIOSSafari) {
                                prevBtn.addEventListener('touchstart', handlePrevClick, { passive: false });
                            } else {
                                prevBtn.addEventListener('click', handlePrevClick);
                            }
                        }

                        // Setup freccia successiva  
                        if (nextBtn) {
                            const handleNextClick = function(e) {
                                e.preventDefault();
                                e.stopPropagation();
                                console.log("➡️ Click freccia successiva");
                                updateDate(1);
                            };
                            
                            // iOS-safe event handling
                            if (isIOSSafari) {
                                nextBtn.addEventListener('touchstart', handleNextClick, { passive: false });
                            } else {
                                nextBtn.addEventListener('click', handleNextClick);
                            }
                        }

                        // Setup click sulla data centrale per aprire calendario
                        if (dateIndicatorContent) {
                            const handleDateClick = function(e) {
                                // Solo se il click è esattamente sulla data (non sulle frecce)
                                if (e.target.closest('#prevDayBtn') || e.target.closest('#nextDayBtn')) {
                                    return;
                                }
                                
                                e.preventDefault();
                                e.stopPropagation();
                                console.log("📅 Click sulla data centrale - apertura calendario");
                                
                                // Prevent multiple rapid clicks on iOS
                                if (window._datePickerOpening) {
                                    return;
                                }
                                
                                try {
                                    window._datePickerOpening = true;
                                    
                                    if (isIOSSafari) {
                                        // iOS Safari: delayed opening to prevent crashes
                                        setTimeout(() => {
                                            if (fp && !fp.isOpen) {
                                                fp.open();
                                            } else if (fp && fp.isOpen) {
                                                fp.close();
                                            }
                                            window._datePickerOpening = false;
                                        }, 50);
                                    } else {
                                        // Other browsers: immediate opening
                                        if (fp && !fp.isOpen) {
                                            fp.open();
                                        } else if (fp && fp.isOpen) {
                                            fp.close();
                                        }
                                        window._datePickerOpening = false;
                                    }
                                } catch (error) {
                                    console.error("❌ Errore apertura calendario:", error);
                                    window._datePickerOpening = false;
                                }
                            };

                            // Note: Event listener per data centrale ora gestito da attachDateClickListener()
                        }
                    };

                    // Esegui setup iniziale
                    setupArrowButtons();
                    
                    // Re-setup dopo aggiornamenti dell'indicatore (con throttling)
                    let setupThrottle = false;
                    const originalUpdateDateIndicator = window.updateDateIndicator;
                    window.updateDateIndicator = function(date) {
                        if (originalUpdateDateIndicator) {
                            originalUpdateDateIndicator(date);
                        }
                        
                        // Re-setup buttons after DOM update (throttled)
                        if (!setupThrottle) {
                            setupThrottle = true;
                            setTimeout(() => {
                                setupArrowButtons();
                                setupThrottle = false;
                            }, 100);
                        }
                    };
                    
                }, 100); // Delay maggiore per assicurare che tutti gli elementi siano pronti

                // Configure flatpickr with iOS-safe settings
                const fp = flatpickr(dateInput, {
                    dateFormat: "d/m/Y",
                    locale: {
                        ...flatpickr.l10ns.it, // Mantieni tutte le impostazioni italiane
                        firstDayOfWeek: 1 // Inizia la settimana dal lunedì
                    },
                    allowInput: false, // Disable direct input, use picker only
                    defaultDate: dateInput.value,
                    // iOS-specific optimizations to prevent crashes
                    disableMobile: !isIOSSafari, // Enable mobile mode for iOS Safari to prevent crashes
                    static: isIOSSafari, // Use static positioning on iOS Safari
                    appendTo: isIOSSafari ? dateInput.parentElement : document.body, // Safer positioning on iOS
                    clickOpens: true, // Riabilito clickOpens anche su iOS per permettere apertura programmatica
                    
                    // ++ Add dropdown for month only (disabled on iOS for stability) ++
                    dropdowns: isIOSSafari ? false : {
                        months: true,
                        years: false
                    },
                    // Funzione per aggiungere la classe weekend ai giorni di sabato, domenica e festivi
                    onDayCreate: function(dObj, dStr, fp, dayElem) {
                        const date = dayElem.dateObj;
                        const year = date.getFullYear();
                        const month = date.getMonth(); // 0-11
                        const day = date.getDate();

                        // 0 = domenica, 6 = sabato
                        if (date.getDay() === 0 || date.getDay() === 6) {
                            dayElem.classList.add('flatpickr-weekend');
                        }

                        // Festività nazionali italiane (date fisse)
                        const fixedHolidays = [
                            { day: 1, month: 0 },    // Capodanno (1 Gennaio)
                            { day: 6, month: 0 },    // Epifania (6 Gennaio)
                            { day: 25, month: 3 },   // Festa della Liberazione (25 Aprile)
                            { day: 1, month: 4 },    // Festa dei Lavoratori (1 Maggio)
                            { day: 2, month: 5 },    // Festa della Repubblica (2 Giugno)
                            { day: 15, month: 7 },   // Ferragosto (15 Agosto)
                            { day: 1, month: 10 },   // Tutti i Santi (1 Novembre)
                            { day: 8, month: 11 },   // Immacolata Concezione (8 Dicembre)
                            { day: 25, month: 11 },  // Natale (25 Dicembre)
                            { day: 26, month: 11 }   // Santo Stefano (26 Dicembre)
                        ];

                        // Controlla le festività a data fissa
                        if (fixedHolidays.some(holiday => holiday.day === day && holiday.month === month)) {
                            dayElem.classList.add('flatpickr-weekend');
                        }

                        // Calcolo della Pasqua e festività correlate (Lunedì dell'Angelo)
                        // Algoritmo di Gauss per calcolare la Pasqua
                        function getEasterDate(year) {
                            const a = year % 19;
                            const b = Math.floor(year / 100);
                            const c = year % 100;
                            const d = Math.floor(b / 4);
                            const e = b % 4;
                            const f = Math.floor((b + 8) / 25);
                            const g = Math.floor((b - f + 1) / 3);
                            const h = (19 * a + b - d - g + 15) % 30;
                            const i = Math.floor(c / 4);
                            const k = c % 4;
                            const l = (32 + 2 * e + 2 * i - h - k) % 7;
                            const m = Math.floor((a + 11 * h + 22 * l) / 451);
                            const month = Math.floor((h + l - 7 * m + 114) / 31) - 1; // 0-11
                            const day = ((h + l - 7 * m + 114) % 31) + 1;
                            return { day, month };
                        }

                        // Calcola la Pasqua per l'anno corrente
                        const easter = getEasterDate(year);

                        // Controlla se è Pasqua
                        if (day === easter.day && month === easter.month) {
                            dayElem.classList.add('flatpickr-weekend');
                        }

                        // Calcola il Lunedì dell'Angelo (Pasquetta) - giorno dopo Pasqua
                        const easterMonday = new Date(year, easter.month, easter.day);
                        easterMonday.setDate(easterMonday.getDate() + 1);

                        // Controlla se è Lunedì dell'Angelo
                        if (day === easterMonday.getDate() && month === easterMonday.getMonth()) {
                            dayElem.classList.add('flatpickr-weekend');
                        }
                    },
                    // ++ End dropdowns ++
                    onChange: function(selectedDates, dateStr, instance) {
                        console.log("Datepicker onChange:", dateStr);

                        // iOS-safe date change handler with error prevention
                        try {
                            // Sometimes dateStr might be empty if cleared, handle it
                            if(dateStr && selectedDates.length > 0) {
                                window.lastSelectedDate = dateStr;
                                dateInput.value = dateStr; // Update hidden input
                                
                                // Delay updateDateIndicator on iOS to prevent layout issues
                                if (isIOSSafari) {
                                    setTimeout(() => {
                                        updateDateIndicator(selectedDates[0]);
                                    }, 100);
                                } else {
                                    updateDateIndicator(selectedDates[0]); // Update visual indicator
                                }

                                if (typeof loadExistingEntry === 'function') {
                                    // Delay loadExistingEntry on iOS to prevent crashes
                                    if (isIOSSafari) {
                                        setTimeout(() => {
                                            loadExistingEntry(dateStr);
                                        }, 150);
                                    } else {
                                        loadExistingEntry(dateStr);
                                    }
                                }
                            } else if (!dateStr) {
                                // Handle case where date is cleared (if allowInput was true)
                                 const today = new Date();
                                 instance.setDate(today, true); // Reset to today if cleared
                                 console.log("Data cancellata, reimpostata a oggi.");
                            }
                        } catch (error) {
                            console.error("Errore iOS-safe nella gestione cambio data:", error);
                            // Fallback sicuro per iOS
                            if (typeof showToast === 'function') {
                                showToast("Errore nel cambio data, riprova", "error");
                            }
                        }
                    },
                    onReady: function(selectedDates, dateStr, instance) {
                         // iOS-safe onReady with delayed execution
                         if (isIOSSafari) {
                             setTimeout(() => {
                                 updateDateIndicator(instance.selectedDates[0] || new Date());
                             }, 200);
                         } else {
                             updateDateIndicator(instance.selectedDates[0] || new Date()); // Initial update
                         }
                         console.log("Flatpickr pronto - iOS Safe Mode:", isIOSSafari);
                     },
                    // onClose needed? Maybe not if onChange handles everything
                errorHandler: (error) => {
    console.error("Errore Flatpickr:", error);
    if (typeof showToast === 'function') {
        showToast(`Errore calendario: ${error.message || 'Errore sconosciuto'}`, "error");
    }
},
});

                // Il click sul calendario è ora gestito specificamente dal dateIndicatorContent
                // nell'inizializzazione delle frecce sopra - rimuoviamo questo gestore duplicato
                console.log("✅ Click calendario gestito da dateIndicatorContent")

                console.log("Datepicker inizializzato con successo - input nascosto e indicatore data cliccabile");
            } catch (error) {
                console.error("Errore nell'inizializzazione del datepicker:", error);
                 // Fallback: Show basic input if error occurs (though CSS hides label/input now)
                 // Consider adding a visible fallback mechanism if robust error handling is needed
                 const today = new Date();
                 dateInput.value = formatDateForInput(today);
                 const dateIndicator = document.getElementById('dateIndicator');
                 if(dateIndicator) dateIndicator.innerHTML = `<div>Errore nel caricamento del calendario. Data: ${dateInput.value}</div>`;
            }
        }

        // Helper to update the visual date indicator with iOS-safe error handling
        function updateDateIndicator(date) {
            // iOS-safe updateDateIndicator with comprehensive error handling
            try {
                const dateIndicator = document.getElementById('dateIndicator');
                if (!dateIndicator || !date || isNaN(date.getTime())) {
                    console.warn("updateDateIndicator: Indicatore non trovato o data non valida");
                    if(dateIndicator) {
                        dateIndicator.innerHTML = `<div class="date-navigator">
                            <button type="button" id="prevDayBtn" class="date-arrow-btn" title="Giorno precedente"><span class="material-symbols-outlined">chevron_left</span></button>
                            <span id="dateIndicatorContent" style="display: flex; align-items: center; gap: 4px;">
                                <span class='material-symbols-outlined'>calendar_today</span>
                                <span>Data non valida</span>
                            </span>
                            <button type="button" id="nextDayBtn" class="date-arrow-btn" title="Giorno successivo"><span class="material-symbols-outlined">chevron_right</span></button>
                        </div>`;
                    }
                    return;
                }

                const options = { weekday: 'long', day: 'numeric', month: 'long', year: 'numeric' };
                const italianDate = date.toLocaleDateString('it-IT', options);
                
                // Estrai solo il nome del giorno
                const dayName = date.toLocaleDateString('it-IT', { weekday: 'long' });
                const capitalizedDayName = dayName.charAt(0).toUpperCase() + dayName.slice(1);
                
                // Aggiorna il nome del giorno
                const dayNameIndicator = document.getElementById('dayNameIndicator');
                if (dayNameIndicator) {
                    dayNameIndicator.textContent = capitalizedDayName;
                }
                
                // iOS-safe DOM manipulation with requestAnimationFrame
                const updateDOM = () => {
                    // Detect iOS Safari
                    const isIOSSafari = /iPad|iPhone|iPod/.test(navigator.userAgent) && /Safari/.test(navigator.userAgent);
                    
                    if (isIOSSafari) {
                        // iOS: Sposta input funzionante al centro, elimina data problematica
                        dateIndicator.innerHTML = `
                            <div class="date-navigator" style="display: flex; align-items: center; gap: 8px; justify-content: center;">
                                <button type="button" id="prevDayBtn" class="date-arrow-btn" title="Giorno precedente"><span class="material-symbols-outlined">chevron_left</span></button>
                                <input type="text" id="dateInputCentral" class="form-control datepicker" value="${italianDate}" style="border: none; background: transparent; text-align: center; font-weight: 500; width: auto; min-width: 250px; cursor: pointer;" readonly title="Clicca per cambiare data">
                                <button type="button" id="nextDayBtn" class="date-arrow-btn" title="Giorno successivo"><span class="material-symbols-outlined">chevron_right</span></button>
                            </div>
                        `;
                        
                        // Sincronizza il nuovo input con l'originale nascosto e applica Flatpickr
                        setTimeout(() => {
                            const originalInput = document.getElementById('date');
                            const centralInput = document.getElementById('dateInputCentral');
                            
                            if (originalInput && centralInput) {
                                // Il centralInput mostra la data formattata completa, ma Flatpickr usa quella originale
                                const originalDate = originalInput.value;
                                
                                // Applica Flatpickr al nuovo input centrale
                                if (window.flatpickr && !centralInput._flatpickr) {
                                    const fp = flatpickr(centralInput, {
                                        dateFormat: "d/m/Y",
                                        locale: { ...flatpickr.l10ns.it, firstDayOfWeek: 1 },
                                        allowInput: false,
                                        defaultDate: originalDate, // Usa la data originale per inizializzazione
                                        disableMobile: false,
                                        static: true,
                                        clickOpens: true,
                                        onChange: function(selectedDates) {
                                            if (selectedDates[0]) {
                                                // Aggiorna input originale con formato d/m/Y
                                                const shortFormat = selectedDates[0].toLocaleDateString('it-IT', {
                                                    day: '2-digit',
                                                    month: '2-digit', 
                                                    year: 'numeric'
                                                });
                                                originalInput.value = shortFormat;
                                                
                                                // Aggiorna display con formato completo
                                                const longFormat = selectedDates[0].toLocaleDateString('it-IT', {
                                                    weekday: 'long',
                                                    day: 'numeric',
                                                    month: 'long',
                                                    year: 'numeric'
                                                });
                                                centralInput.value = longFormat;
                                                
                                                // Sincronizza Flatpickr originale se esiste
                                                if (originalInput._flatpickr) {
                                                    originalInput._flatpickr.setDate(selectedDates[0], false);
                                                }
                                                
                                                // Trigger eventi necessari
                                                const event = new Event('change', { bubbles: true });
                                                originalInput.dispatchEvent(event);
                                            }
                                        }
                                    });
                                }
                                
                                // Nascondi input originale
                                originalInput.style.display = 'none';
                            }
                        }, 100);
                        
                    } else {
                        // Android/Desktop: Layout normale con data centrale cliccabile
                        dateIndicator.innerHTML = `
                            <div class="date-navigator" title="Clicca per cambiare data" style="display: flex; align-items: center; gap: 8px; justify-content: center;">
                                <button type="button" id="prevDayBtn" class="date-arrow-btn" title="Giorno precedente"><span class="material-symbols-outlined">chevron_left</span></button>
                                <span id="dateIndicatorContent" style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                                    <span class="material-symbols-outlined">calendar_month</span>
                                    <span style="font-weight: 500;">${italianDate}</span>
                                </span>
                                <button type="button" id="nextDayBtn" class="date-arrow-btn" title="Giorno successivo"><span class="material-symbols-outlined">chevron_right</span></button>
                            </div>
                        `;
                    }
                };

                // Use requestAnimationFrame for smoother updates on iOS
                if (window.requestAnimationFrame) {
                    requestAnimationFrame(() => {
                        updateDOM();
                        // Attacca event listener SOLO per Android (iOS usa input centrale)
                        const isIOSSafari = /iPad|iPhone|iPod/.test(navigator.userAgent) && /Safari/.test(navigator.userAgent);
                        if (!isIOSSafari) {
                            attachDateClickListener();
                        }
                    });
                } else {
                    updateDOM();
                    // Attacca event listener SOLO per Android (iOS usa input centrale)  
                    const isIOSSafari = /iPad|iPhone|iPod/.test(navigator.userAgent) && /Safari/.test(navigator.userAgent);
                    if (!isIOSSafari) {
                        attachDateClickListener();
                    }
                }
                
            } catch (e) {
                console.error("Errore iOS-safe nell'aggiornamento dell'indicatore:", e);
                const dateIndicator = document.getElementById('dateIndicator');
                if(dateIndicator) {
                    dateIndicator.innerHTML = `<div class="date-navigator">
                        <button type="button" id="prevDayBtn" class="date-arrow-btn" title="Giorno precedente"><span class="material-symbols-outlined">chevron_left</span></button>
                        <span id="dateIndicatorContent" style="display: flex; align-items: center; gap: 4px;">
                            <span class='material-symbols-outlined'>calendar_today</span>
                            <span>Errore data</span>
                        </span>
                        <button type="button" id="nextDayBtn" class="date-arrow-btn" title="Giorno successivo"><span class="material-symbols-outlined">chevron_right</span></button>
                    </div>`;
                }
            }
        }

        // Function to attach click listener to central date after DOM update
        function attachDateClickListener() {
            try {
                const dateIndicatorContent = document.getElementById('dateIndicatorContent');
                if (!dateIndicatorContent) {
                    console.warn("⚠️ dateIndicatorContent non trovato per event listener");
                    return;
                }

                console.log("🎯 Attaching event listener alla data centrale...");

                const handleDateClick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    console.log("🗓️ Click su data centrale - apertura calendario");
                    
                    try {
                        if (window._datePickerOpening) {
                            console.log("⏳ Apertura calendario già in corso...");
                            return;
                        }
                        
                        window._datePickerOpening = true;
                        const dateInput = document.getElementById('date');
                        
                        console.log("�️ Click su data centrale - triggerando click su data in alto");
                        
                        // SOLUZIONE SEMPLICE: Trigger click sulla data in alto che funziona
                        if (dateInput) {
                            console.log("📅 Triggering click su input data in alto");
                            
                            // Simula un click diretto sull'input che funziona
                            dateInput.click();
                            
                            // Per iOS: anche focus se necessario
                            const isIOSSafari = /iPad|iPhone|iPod/.test(navigator.userAgent) && /Safari/.test(navigator.userAgent);
                            if (isIOSSafari) {
                                dateInput.focus();
                            }
                            
                        } else {
                            console.warn("❌ Input data non trovato");
                        }
                        
                        window._datePickerOpening = false;
                        
                    } catch (error) {
                        console.error("❌ Errore apertura calendario dalla data centrale:", error);
                        window._datePickerOpening = false;
                    }
                };

                // Remove existing listeners to avoid duplicates
                const newElement = dateIndicatorContent.cloneNode(true);
                dateIndicatorContent.parentNode.replaceChild(newElement, dateIndicatorContent);

                // iOS-safe event handling
                const isIOSSafari = /iPad|iPhone|iPod/.test(navigator.userAgent) && /Safari/.test(navigator.userAgent);
                if (isIOSSafari) {
                    newElement.addEventListener('touchstart', handleDateClick, { passive: false });
                } else {
                    newElement.addEventListener('click', handleDateClick);
                }
                
                // Visual feedback
                newElement.style.cursor = 'pointer';
                newElement.style.userSelect = 'none';
                newElement.style.webkitUserSelect = 'none';
                
                console.log("✅ Event listener per data centrale attaccato correttamente!");
                
            } catch (error) {
                console.error("❌ Errore nell'attaching event listener data centrale:", error);
            }
        }

        // Function to show toast notification - Material Design 3 Style
        function showToast(message, type = 'info', duration = 3000, actions = null) {
            const container = document.getElementById('toast-container');
            if (!container) {
                console.error("Toast container non trovato!");
                return; // Exit if container doesn't exist
            }

            // Verifica se esiste già un toast con lo stesso messaggio e tipo
            const existingToasts = Array.from(container.querySelectorAll('.toast'));
            const duplicateToast = existingToasts.find(t =>
                t.querySelector('.toast-message')?.textContent === message &&
                t.classList.contains(type)
            );

            // Se esiste già un toast identico, non ne creiamo un altro
            if (duplicateToast) {
                console.log("Toast duplicato ignorato:", message);
                return;
            }

            // Assicuriamoci che il container sia visibile e sopra tutto
            container.style.zIndex = "10000";

            const toast = document.createElement('div');
            toast.className = `toast ${type}`;

            // Creiamo un contenitore per il messaggio
            const messageElement = document.createElement('div');
            messageElement.className = 'toast-message';
            messageElement.textContent = message;
            toast.appendChild(messageElement);

            // Aggiungiamo icona in base al tipo di toast
            let icon = '';
            switch(type) {
                case 'success':
                    icon = 'check_circle';
                    break;
                case 'error':
                    icon = 'error';
                    break;
                case 'warning':
                    icon = 'warning';
                    break;
                case 'info':
                default:
                    icon = 'info';
                    break;
            }

            // Inseriamo l'icona prima del messaggio
            if (icon) {
                const iconElement = document.createElement('span');
                iconElement.className = 'material-symbols-outlined';
                iconElement.textContent = icon;
                iconElement.style.marginRight = '12px';
                iconElement.style.fontSize = '20px';
                toast.insertBefore(iconElement, messageElement);
            }

            // Se ci sono azioni, aggiungiamo i pulsanti
            if (actions && Array.isArray(actions) && actions.length > 0) {
                const actionsContainer = document.createElement('div');
                actionsContainer.className = 'toast-actions';

                actions.forEach(action => {
                    if (action && action.text) {
                        const button = document.createElement('button');
                        button.textContent = action.text.toUpperCase(); // Material Design usa testo maiuscolo
                        button.className = 'toast-action-button';

                        // Aggiungiamo l'evento click
                        button.addEventListener('click', () => {
                            // Rimuoviamo il toast
                            toast.classList.remove('show');

                            // Eseguiamo l'azione
                            if (typeof action.onClick === 'function') {
                                action.onClick();
                            }

                            // Rimuoviamo il toast dal DOM dopo la transizione
                            toast.addEventListener('transitionend', () => {
                                if (toast.parentNode) {
                                    toast.parentNode.removeChild(toast);
                                }
                            }, { once: true });
                        });

                        actionsContainer.appendChild(button);
                    }
                });

                toast.appendChild(actionsContainer);
            }

            // Aggiungiamo un pulsante per chiudere il toast
            if (duration > 0) {
                const closeButton = document.createElement('button');
                closeButton.innerHTML = '&times;';
                closeButton.className = 'toast-close-button';
                closeButton.setAttribute('aria-label', 'Chiudi notifica');

                closeButton.addEventListener('click', () => {
                    toast.classList.remove('show');
                    toast.addEventListener('transitionend', () => {
                        if (toast.parentNode) {
                            toast.parentNode.removeChild(toast);
                        }
                    }, { once: true });
                });

                toast.appendChild(closeButton);
            }

            container.appendChild(toast);

            console.log("Toast creato:", message); // Log per debug

            // Trigger transition for appearance
            requestAnimationFrame(() => {
                // We need a double requestAnimationFrame to ensure the transition works on add
                requestAnimationFrame(() => {
                    toast.classList.add('show');
                    console.log("Toast mostrato:", message); // Log per debug
                });
            });

            // Remove toast after duration (only if duration > 0)
            if (duration > 0) {
                setTimeout(() => {
                    toast.classList.remove('show');
                    console.log("Toast nascosto:", message); // Log per debug
                    // Remove from DOM after transition ends
                    toast.addEventListener('transitionend', () => {
                        // Check if the element still has a parent before removing
                        if (toast.parentNode) {
                            toast.parentNode.removeChild(toast);
                            console.log("Toast rimosso:", message); // Log per debug
                        }
                    }, { once: true }); // Use {once: true} for cleaner event handling
                }, duration);
            }
        }

        // Global DOMContentLoaded listener
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM completamente caricato e analizzato');

            // Controlla se il PIN Admin è già stato inserito correttamente
            const isAdminUnlocked = localStorage.getItem('adminUnlocked') === 'true';
            const cashNavItem = document.getElementById('cash-nav-item');
            const unlockAdminBtn = document.getElementById('unlockAdminFeatures');
            const lockAdminBtn = document.getElementById('lockAdminFeatures');

            if (isAdminUnlocked) {
                if (cashNavItem) cashNavItem.style.display = 'flex';
                if (lockAdminBtn) lockAdminBtn.style.display = 'block';
                if (unlockAdminBtn) unlockAdminBtn.style.display = 'none';
                console.log('Funzionalità admin sbloccate (da localStorage)');
            } else {
                if (cashNavItem) cashNavItem.style.display = 'none';
                if (lockAdminBtn) lockAdminBtn.style.display = 'none';
                if (unlockAdminBtn) unlockAdminBtn.style.display = 'block';
            }

            // Inizializza i controlli orari
            if (typeof initTimeControls === 'function') {
                initTimeControls();
                console.log('Controlli orari inizializzati');
            }

            // Inizializza le righe di lavoro multiple
            if (typeof initWorkRows === 'function') {
                initWorkRows();
                console.log('Righe di lavoro multiple inizializzate');
            }



             // --- Theme Initialization (Ottimizzato) ---
             const darkThemeToggle = document.getElementById('darkTheme');
             if(darkThemeToggle) {
                 console.log("Inizializzazione tema scuro/chiaro...");

                 // Funzione per applicare il tema
                 function applyTheme(isDark) {
                     if (isDark) {
                         document.body.classList.add('dark-theme');
                         darkThemeToggle.checked = true;
                         console.log("Tema scuro applicato.");
                     } else {
                         document.body.classList.remove('dark-theme');
                         darkThemeToggle.checked = false;
                         console.log("Tema chiaro applicato.");
                     }

                     // Forza l'aggiornamento degli elementi che dipendono dal tema
                     setTimeout(() => {
                         console.log("Forzando aggiornamento stile elementi");
                         const selects = document.querySelectorAll('select');
                         selects.forEach(s => {
                             s.style.display = 'none';
                             s.offsetHeight; // Forza reflow
                             s.style.display = '';
                         });
                     }, 50);
                 }

                 // Determina il tema iniziale
                 const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                 const savedTheme = localStorage.getItem('theme');

                 // Applica il tema iniziale
                 if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
                     applyTheme(true);

                     // Evento personalizzato per notificare il tema iniziale
                     setTimeout(() => {
                         const themeChangeEvent = new CustomEvent('themeChange', {
                             detail: { isDark: true }
                         });
                         document.dispatchEvent(themeChangeEvent);
                     }, 100);
                 } else {
                     applyTheme(false);
                 }

                 // Gestisci il cambio di tema
                 darkThemeToggle.addEventListener('change', () => {
                     const isDark = darkThemeToggle.checked;

                     // Applica il tema in base allo stato del toggle
                     if (isDark) {
                         document.body.classList.add('dark-theme');
                     } else {
                         document.body.classList.remove('dark-theme');
                     }

                     // Salva la preferenza
                     const currentTheme = isDark ? 'dark' : 'light';
                     localStorage.setItem('theme', currentTheme);
                     console.log(`Tema cambiato a: ${currentTheme}`);

                     // Aggiorna gli elementi che dipendono dal tema
                     setTimeout(() => {
                         console.log("Forzando aggiornamento stile elementi dopo cambio tema");
                         const selects = document.querySelectorAll('select');
                         selects.forEach(s => {
                             s.style.display = 'none';
                             s.offsetHeight; // Forza reflow
                             s.style.display = '';
                         });

                         // Evento personalizzato per notificare il cambio tema
                         const themeChangeEvent = new CustomEvent('themeChange', {
                             detail: { isDark: isDark }
                         });
                         document.dispatchEvent(themeChangeEvent);
                     }, 50);
                 });
             } else {
                  console.warn("Toggle tema scuro non trovato.");
             }


            // --- Initialize datepicker ---
            if (typeof initDatepicker === 'function') {
                initDatepicker();
            } else {
                console.error("initDatepicker function not found!");
            }

             // --- Initialize other pickers ---
             if (typeof initFerieMalattieDatepickers === 'function') {
                 initFerieMalattieDatepickers();
             }


             // --- Load User Name ---
            const userNameInput = document.getElementById('userName');
            const saveUserNameBtn = document.getElementById('saveUserName');
            if (userNameInput) {
                const savedUserName = localStorage.getItem('userName');
                if (savedUserName) {
                    userNameInput.value = savedUserName;
                    console.log("Nome utente caricato:", savedUserName);
                }
                if (saveUserNameBtn) {
                    saveUserNameBtn.addEventListener('click', () => {
                        const nameToSave = userNameInput.value.trim();
                        localStorage.setItem('userName', nameToSave);
                        showToast('Nome utente salvato!', 'success');
                         console.log("Nome utente salvato:", nameToSave);
                    });
                } else {
                     console.warn("Pulsante salvataggio nome utente non trovato.");
                }
            } else {
                console.warn("Input nome utente non trovato.");
            }


            // --- Navigation Logic ---
            const navItems = document.querySelectorAll('.nav-item');
            const sections = document.querySelectorAll('.section');

            // Variabile per tenere traccia se una transizione è in corso
            let isNavigating = false;

            if (navItems.length > 0 && sections.length > 0) {
                navItems.forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.preventDefault();

                        // Evita clic multipli durante una transizione
                        if (isNavigating) return;

                        const targetSectionId = item.getAttribute('data-section');

                        // Evita di navigare alla sezione già attiva
                        if (item.classList.contains('active')) {
                            console.log(`Già nella sezione: ${targetSectionId}`);
                            return;
                        }

                        console.log(`Navigazione a: ${targetSectionId}`);

                        // Imposta lo stato di navigazione
                        isNavigating = true;

                        // Update active nav item
                        navItems.forEach(nav => nav.classList.remove('active'));
                        item.classList.add('active');

                        // Update active section with improved transition

                        // Prima nascondiamo tutte le sezioni con una breve transizione
                        sections.forEach(section => {
                            if (section.classList.contains('active') && section.id !== targetSectionId) {
                                section.style.animation = 'fadeOut 0.2s ease forwards';
                                setTimeout(() => {
                                    section.classList.remove('active');
                                    section.style.animation = '';
                                }, 200);
                            }
                        });

                        // Poi mostriamo la sezione target
                        setTimeout(() => {
                            let sectionFound = false;

                            sections.forEach(section => {
                                if (section.id === targetSectionId) {
                                    section.classList.add('active');
                                    sectionFound = true;

                                    // Inizializza la sezione in base al tipo
                                    setTimeout(() => {
                                        if (targetSectionId === 'home-section') {
                                            console.log("Inizializzazione home dopo attivazione...");
                                            loadTimeEntries();
                                            populateVehicleDropdown();
                                            // Inizializza i controlli orari quando si attiva la sezione home
                                            if (typeof initTimeControls === 'function') {
                                                initTimeControls();
                                            }
                                        } else if (targetSectionId === 'calendar-section') {
                                            console.log("Inizializzazione calendario dopo attivazione...");
                                            loadCalendarData();
                                        } else if (targetSectionId === 'monthly-report-section') {
                                            console.log("Inizializzazione report mensile dopo attivazione...");
                                            initMonthlyReport();
                                        } else if (targetSectionId === 'cash-section') {
                                            console.log("Inizializzazione sezione Cash dopo attivazione...");
                                            initCashSection();
                                        } else if (targetSectionId === 'ferie-malattie-section') {
                                            console.log("Inizializzazione ferie/malattie dopo attivazione...");
                                            initFerieMalattieSection();
                                            loadFerieMalattieEntries();
                                        } else if (targetSectionId === 'contacts-section') {
                                            console.log("Inizializzazione contatti dopo attivazione...");
                                            // Non richiede inizializzazione speciale
                                        } else if (targetSectionId === 'settings-section') {
                                            console.log("Inizializzazione impostazioni dopo attivazione...");
                                            populateVehicleSettingsList(); // Carica la lista dei veicoli nelle impostazioni


                                            // Gestione PWA per iOS quando la sezione impostazioni è attiva
                                            const checkIOSPWA = function() {
                                                const iosInstructions = document.getElementById('iosInstructions');
                                                const pwaStatus = document.getElementById('pwaStatus');
                                                const installButton = document.getElementById('installPwa');

                                                // Funzione per rilevare iOS
                                                const isIOS = function() {
                                                    return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                                                };

                                                // Funzione per rilevare Safari su iOS
                                                const isIOSSafari = function() {
                                                    return isIOS() && /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent);
                                                };

                                                if (isIOS()) {
                                                    console.log('Dispositivo iOS rilevato nella sezione impostazioni');

                                                    // Controlla se l'app è già installata su iOS
                                                    if (window.navigator.standalone === true) {
                                                        // L'app è già installata come PWA su iOS
                                                        if (pwaStatus) {
                                                            pwaStatus.textContent = 'App già installata';
                                                            pwaStatus.style.color = 'var(--md-sys-color-primary)';
                                                        }

                                                        // Nascondi le istruzioni per iOS
                                                        if (iosInstructions) {
                                                            iosInstructions.style.display = 'none';
                                                        }
                                                    } else {
                                                        // L'app non è installata su iOS
                                                        if (pwaStatus) {
                                                            if (isIOSSafari()) {
                                                                pwaStatus.textContent = 'Segui le istruzioni sotto per installare l\'app';
                                                                pwaStatus.style.color = 'var(--md-sys-color-primary)';
                                                            } else {
                                                                pwaStatus.textContent = 'Apri questa pagina in Safari per installare l\'app';
                                                            }
                                                        }

                                                        // Mostra le istruzioni per iOS
                                                        if (iosInstructions) {
                                                            iosInstructions.style.display = 'block';
                                                        }

                                                        // Nascondi il pulsante di installazione (non funziona su iOS)
                                                        if (installButton) {
                                                            installButton.style.display = 'none';
                                                        }
                                                    }
                                                }
                                            };

                                            // Esegui il controllo dopo un breve ritardo per assicurarsi che tutti gli elementi siano caricati
                                            setTimeout(checkIOSPWA, 200);
                                        }
                                    }, 100); // Piccolo ritardo per assicurarsi che la sezione sia completamente attivata
                                }
                            });

                            // Verifichiamo se la sezione è stata trovata dopo il timeout
                            if (!sectionFound) {
                                console.error(`Sezione ${targetSectionId} non trovata!`);
                            }

                            // Resetta lo stato di navigazione
                            isNavigating = false;
                        }, 250);

                         // Scroll to top of the main content area for clarity
                         const mainElement = document.querySelector('main');
                         if(mainElement) {
                             mainElement.scrollTo({ top: 0, behavior: 'smooth' });
                         }

                        // Nota: l'inizializzazione delle sezioni viene ora gestita nel timeout sopra
                        // Qui possiamo aggiungere altre operazioni specifiche se necessario in futuro

                    });
                });
            } else {
                console.warn("Elementi di navigazione o sezioni non trovati.");
            }


            // --- Form submission ---
            const form = document.getElementById('timeEntryForm');
            if(form) {
                 form.addEventListener('submit', saveTimeEntry);
                 // Auto-calculate total hours
                 ['startTime', 'endTime', 'breakTime'].forEach(id => {
                     const input = document.getElementById(id);
                     if(input) {
                         input.addEventListener('input', calculateTotalHours);
                     } else {
                         console.warn(`Input ${id} non trovato per il calcolo automatico.`);
                     }
                 });
                 calculateTotalHours(); // Initial calculation

                 // Gestione del pulsante di trasferta
                 const trasfertaButton = document.getElementById('transferta');
                 if (trasfertaButton) {
                     trasfertaButton.addEventListener('click', function() {
                         // Toggle della classe active
                         this.classList.toggle('active');
                         // Aggiungiamo un attributo data-active per tenere traccia dello stato
                         const textElement = this.querySelector('.trasferta-text');

                         if (this.classList.contains('active')) {
                             this.setAttribute('data-active', 'true');
                             if (textElement) textElement.textContent = 'Trasferta attiva';
                         } else {
                             this.setAttribute('data-active', 'false');
                             if (textElement) textElement.textContent = 'Seleziona trasferta';
                         }
                     });
                 } else {
                     console.warn("Pulsante trasferta non trovato.");
                 }
            } else {
                 console.warn("Form inserimento ore non trovato.");
            }


            // --- Load initial data ---
            if (typeof loadTimeEntries === 'function') loadTimeEntries();
            if (typeof populateVehicleDropdown === 'function') populateVehicleDropdown(); // Populate dropdown on home
            if (typeof loadFerieMalattieTypes === 'function') loadFerieMalattieTypes();


            // --- Settings actions ---
            const exportBtn = document.getElementById('exportData');
            if(exportBtn && typeof exportData === 'function') {
                exportBtn.addEventListener('click', exportAllData);
            } else if (!exportBtn) { console.warn("Pulsante Esporta Dati non trovato."); }

             const importBtn = document.getElementById('importData');
            if(importBtn && typeof triggerImport === 'function') {
                importBtn.addEventListener('click', importAllData);
            } else if (!importBtn) { console.warn("Pulsante Importa Dati non trovato."); }

            const clearBtn = document.getElementById('clearData');
            if(clearBtn && typeof clearAllData === 'function') {
                clearBtn.addEventListener('click', clearAllData);
            } else if (!clearBtn) { console.warn("Pulsante Cancella Dati non trovato."); }

             // --- Vehicle Management ---
             const addVehicleBtn = document.getElementById('addVehicle');
             if(addVehicleBtn && typeof addVehicle === 'function') {
                 addVehicleBtn.addEventListener('click', addVehicle);
             } else if (!addVehicleBtn) { console.warn("Pulsante Aggiungi Mezzo non trovato."); }

            // --- Monthly Report Initialization ---
            // initMonthlyReport(); // Called when section becomes active

            // --- Ferie/Malattie Initialization ---
             // initFerieMalattieSection(); // Called when section becomes active


             // --- QR Code Generation (using library) ---
             if (typeof generateQRCodes === 'function') {
                 generateQRCodes();
             } else {
                 console.warn("Funzione generateQRCodes non trovata.");
             }


            // --- Modal Handling ---
             const modal = document.getElementById('dayModal');
             if (modal) {
                 const closeModalBtn = modal.querySelector('.close-modal');
                 const addEntryModalBtn = modal.querySelector('#addEntryBtn');

                 if(closeModalBtn) {
                     closeModalBtn.addEventListener('click', () => {
                         modal.style.display = 'none';
                         modal.style.opacity = '0';
                         modal.style.visibility = 'hidden';
                         modal.classList.remove('visible');
                         console.log("Modale chiuso tramite pulsante di chiusura");
                     });
                 } else { console.warn("Pulsante chiusura modale non trovato."); }

                 // Close modal if clicking on the background scrim
                 modal.addEventListener('click', (event) => {
                     if (event.target === modal) {
                         modal.style.display = 'none';
                         modal.style.opacity = '0';
                         modal.style.visibility = 'hidden';
                         modal.classList.remove('visible');
                         console.log("Modale chiuso tramite click sullo sfondo");
                     }
                 });

                  if (addEntryModalBtn) {
                     addEntryModalBtn.addEventListener('click', () => {
                         const dateStr = window.lastClickedDate; // Assume this is set when modal opens

                         if (dateStr) {
                             console.log(`Aggiunta voce da modale per data: ${dateStr}`);
                             // Navigate to home section
                              const homeNavItem = document.querySelector('.nav-item[data-section="home-section"]');
                              if (homeNavItem) {
                                  homeNavItem.click(); // Simulate click to navigate
                              } else {
                                   console.error("Nav item Home non trovato per la navigazione.");
                                   showToast("Errore: Impossibile navigare alla sezione Home.", "error");
                                   return;
                              }


                             // Wait for navigation and section switch animation, then set date and focus
                             setTimeout(() => {
                                 const dateInput = document.getElementById('date');
                                 const startTimeInput = document.getElementById('startTime');
                                 if (dateInput && startTimeInput) {
                                     // Find the flatpickr instance and set date
                                     if (dateInput._flatpickr) {
                                         dateInput._flatpickr.setDate(dateStr, true); // true triggers onChange
                                         console.log(`Data ${dateStr} impostata nel datepicker.`);
                                     } else {
                                         // Fallback if flatpickr instance not found
                                         console.warn("Istanza flatpickr non trovata, impostazione manuale fallback.");
                                         dateInput.value = dateStr;
                                         if(typeof updateDateIndicator === 'function') updateDateIndicator(parseDate(dateStr)); // Manually update indicator
                                         if(typeof loadExistingEntry === 'function') loadExistingEntry(dateStr); // Manually load entry
                                     }
                                     startTimeInput.focus(); // Focus on start time field
                                      // Scroll form into view
                                      const formElement = document.getElementById('timeEntryForm');
                                      if (formElement) {
                                          formElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                      }
                                 } else {
                                      console.error("Input data o ora inizio non trovati dopo navigazione.");
                                 }
                                 modal.style.display = 'none'; // Close modal
                                modal.style.opacity = '0';
                                modal.style.visibility = 'hidden';
                                modal.classList.remove('visible');
                             }, 300); // Delay might need adjustment based on animation timing
                         } else {
                             console.error("Impossibile determinare la data (window.lastClickedDate) per aggiungere la voce.");
                             showToast("Errore: Impossibile determinare la data per aggiungere la voce.", "error");
                         }
                     });
                 } else { console.warn("Pulsante aggiungi voce nel modale non trovato."); }
             } else {
                 console.warn("Modale dettagli giorno non trovato.");
             }

            // Initial load for the default active section (Home)
            if (document.getElementById('home-section')?.classList.contains('active')) {
                 if (typeof loadTimeEntries === 'function') loadTimeEntries();
            }

             console.log("Inizializzazione interfaccia completata.");

        }); // End DOMContentLoaded

        // --- Core Data Functions ---

        function getDb() {
            try {
                const data = localStorage.getItem('timeTrackerData');
                // Ensure structure consistency on load
                const defaultDb = {
                    entries: {},
                    settings: {},
                    holidays: {},
                    vehicles: [],
                    rates: {
                        normalHour: 0,
                        nightHour: 0,
                        transferDay: 0,
                        sickDay: 0,
                        vacationDay: 0,
                        igpBrescia: 0
                    }
                };

                if (!data) return defaultDb;

                const parsedData = JSON.parse(data);
                // Merge with default to ensure all keys exist
                return {
                    entries: parsedData.entries || {},
                    settings: parsedData.settings || {},
                    holidays: parsedData.holidays || {},
                    vehicles: Array.isArray(parsedData.vehicles) ? parsedData.vehicles : [],
                    rates: parsedData.rates || defaultDb.rates
                };
            } catch (e) {
                console.error("Error reading from localStorage:", e);
                showToast("Errore nel caricamento dei dati. Prova a cancellare i dati.", "error", 5000);
                return {
                    entries: {},
                    settings: {},
                    holidays: {},
                    vehicles: [],
                    rates: {
                        normalHour: 0,
                        nightHour: 0,
                        transferDay: 0,
                        sickDay: 0,
                        vacationDay: 0,
                        igpBrescia: 0
                    }
                }; // Return default structure on error
            }
        }

        function saveDb(db) {
             try {
                localStorage.setItem('timeTrackerData', JSON.stringify(db));

                // Aggiorna la sezione Cash se attiva
                updateCashSectionIfActive();
             } catch (e) {
                  console.error("Error saving to localStorage:", e);
                  // Check for QuotaExceededError specifically
                  if (e.name === 'QuotaExceededError') {
                      showToast("Errore: Spazio di archiviazione locale esaurito!", "error", 7000);
                  } else {
                      showToast("Errore nel salvataggio dei dati.", "error", 5000);
                  }
             }
        }

        // Funzione per aggiornare la sezione Cash se attiva
        function updateCashSectionIfActive() {
            if (document.getElementById('cash-section')?.classList.contains('active')) {
                const cashMonthSelect = document.getElementById('cashMonthSelect');
                if (cashMonthSelect && cashMonthSelect.value) {
                    calculatePayForMonth(cashMonthSelect.value);
                }
            }
        }

        // Funzione per ottenere i mesi disponibili nel database
        function getAvailableMonths(db) {
            const months = new Set();

            // Aggiungi solo i mesi per cui ci sono voci nel database
            if (db && db.entries) {
                Object.keys(db.entries).forEach(dateStr => {
                    if (dateStr && dateStr.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
                        const parts = dateStr.split('/');
                        const year = parts[2];
                        const month = parts[1];
                        months.add(`${year}-${month}`);
                    }
                });
            }

            // Aggiungi anche i mesi per cui ci sono ferie o malattie
            if (db && db.holidays) {
                Object.keys(db.holidays).forEach(dateStr => {
                    if (dateStr && dateStr.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
                        const parts = dateStr.split('/');
                        const year = parts[2];
                        const month = parts[1];
                        months.add(`${year}-${month}`);
                    }
                });
            }

            // Se non ci sono mesi nel database, aggiungi il mese corrente
            if (months.size === 0) {
                const currentDate = new Date();
                const currentYear = currentDate.getFullYear();
                const currentMonth = currentDate.getMonth() + 1;
                months.add(`${currentYear}-${String(currentMonth).padStart(2, '0')}`);
            }

            // Converti in array e ordina (dal più recente al più vecchio)
            return Array.from(months)
                .sort((a, b) => b.localeCompare(a)) // Ordine decrescente
                .map(monthStr => {
                    const [year, month] = monthStr.split('-');
                    const date = new Date(parseInt(year), parseInt(month) - 1, 1);
                    const monthName = date.toLocaleString('it-IT', { month: 'long' });
                    return {
                        value: monthStr,
                        label: `${monthName.charAt(0).toUpperCase() + monthName.slice(1)} ${year}`
                    };
                });
        }

        // --- Time Entry Functions ---

        // Funzione per inizializzare le righe di lavoro multiple
        function initWorkRows() {
            console.log("Inizializzazione righe di lavoro multiple...");

            // Aggiungi event listener al pulsante "Aggiungi riga"
            const addWorkRowBtn = document.getElementById('add-work-row');
            if (addWorkRowBtn) {
                addWorkRowBtn.addEventListener('click', addWorkRow);
            }

            // Aggiungi event listener alla prima riga di lavoro
            setupWorkRowListeners(document.querySelector('.work-description-input'));
        }

        // Funzione per aggiungere una nuova riga di lavoro
        function addWorkRow() {
            const container = document.getElementById('work-descriptions-container');
            if (!container) return;

            // Conta le righe esistenti per assegnare un indice univoco
            const rowIndex = container.querySelectorAll('.work-description-row').length;

            // Crea una nuova riga
            const newRow = document.createElement('div');
            newRow.className = 'work-description-row';
            newRow.innerHTML = `
                <input type="text" class="form-control work-description-input" placeholder="Inserisci un lavoro" data-row="${rowIndex}">
                <button type="button" class="btn-remove-work" data-row="${rowIndex}">
                    <span class="material-symbols-outlined">close</span>
                </button>
            `;

            // Aggiungi la nuova riga al container
            container.appendChild(newRow);

            // Aggiungi event listener alla nuova riga
            setupWorkRowListeners(newRow.querySelector('.work-description-input'));

            // Aggiungi event listener al pulsante di rimozione
            const removeBtn = newRow.querySelector('.btn-remove-work');
            if (removeBtn) {
                removeBtn.addEventListener('click', function() {
                    newRow.remove();
                });
            }

            // Focus sulla nuova riga
            newRow.querySelector('.work-description-input').focus();
        }

        // Funzione per configurare gli event listener per una riga di lavoro
        function setupWorkRowListeners(inputElement) {
            if (!inputElement) return;

            // Event listener per il tasto "Invio"
            inputElement.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault(); // Previeni l'invio del form
                    addWorkRow(); // Aggiungi una nuova riga
                }
            });
        }

        // Funzione per raccogliere tutte le descrizioni di lavoro
        function getAllWorkDescriptions() {
            const inputs = document.querySelectorAll('.work-description-input');
            const descriptions = [];

            inputs.forEach(input => {
                const value = input.value.trim();
                if (value) {
                    descriptions.push(value);
                }
            });

            return descriptions.join(', ');
        }

        function saveTimeEntry(event) {
            event.preventDefault();
            console.log("Tentativo di salvataggio voce...");
            const db = getDb();
            const dateInput = document.getElementById('date');
            const startTimeInput = document.getElementById('startTime');
            const endTimeInput = document.getElementById('endTime');
            const breakTimeInput = document.getElementById('breakTime');
            const notturneInput = document.getElementById('notturne');
            const transfertaInput = document.getElementById('transferta');
            const totalHoursInput = document.getElementById('totalHours');
            const vehicleSelect = document.getElementById('vehicleSelect');
            const form = document.getElementById('timeEntryForm');

            // Validate elements exist
             if (!dateInput || !startTimeInput || !endTimeInput || !breakTimeInput || !notturneInput || !transfertaInput || !totalHoursInput || !vehicleSelect || !form) {
                 console.error("Uno o più elementi del form non trovati!");
                 showToast("Errore interno: Elementi del form mancanti.", "error");
                 return;
             }

            const date = dateInput.value;
            const startTime = startTimeInput.value;
            const endTime = endTimeInput.value;
            const breakTime = parseFloat(breakTimeInput.value) || 0;
            const notturne = parseFloat(notturneInput.value) || 0;
            // Verifica se il pulsante di trasferta è attivo
            const transferta = transfertaInput.classList.contains('active') || transfertaInput.getAttribute('data-active') === 'true';
            // Raccogli tutte le descrizioni di lavoro
            const description = getAllWorkDescriptions();
            const totalHours = parseFloat(totalHoursInput.value) || 0;
            const selectedVehicle = vehicleSelect.value; // Get selected vehicle ID or name

             // Basic validation
             if (!date) {
                 showToast("La data è obbligatoria.", "error");
                 return;
             }

             // Verifica se almeno uno tra ore e descrizione è presente
             const hasTimeData = startTime && endTime;
             const hasDescription = description.trim() !== '';

             if (!hasTimeData && !hasDescription) {
                 showToast("Inserisci almeno le ore di lavoro o una descrizione.", "error");
                 return;
             }

             // Se sono state inserite le ore, verifica che siano valide
             if (hasTimeData && totalHours <= 0) {
                 showToast("Se inserisci orari, le ore totali devono essere maggiori di zero.", "error");
                 return;
             }

             if (notturne < 0 || breakTime < 0) {
                 showToast("Ore notturne e pausa non possono essere negative.", "error");
                 return;
             }


            const entryId = form.dataset.editingId || Date.now().toString();
            const isEditing = !!form.dataset.editingId;
            const newEntry = {
                id: entryId,
                startTime,
                endTime,
                breakTime,
                notturne,
                transferta,
                description,
                totalHours,
                vehicle: selectedVehicle, // Save selected vehicle
                 lastModified: new Date().toISOString() // Track last edit
            };

            if (!db.entries[date]) {
                db.entries[date] = [];
            }

             // Check if editing or adding
             const existingEntryIndex = db.entries[date].findIndex(entry => entry.id === entryId);
             if (isEditing && existingEntryIndex > -1) {
                 // Update existing entry
                 db.entries[date][existingEntryIndex] = newEntry;
                 showToast('Voce aggiornata!', 'success');
                 console.log(`Voce aggiornata per ${date}, ID: ${entryId}`);
             } else if (!isEditing) {
                 // Add new entry
                 // Check if an entry with the same start/end time already exists for the day (prevent accidental duplicates)
                 const duplicateExists = db.entries[date].some(e => e.startTime === startTime && e.endTime === endTime);
                 if (duplicateExists) {
                     if (!confirm(`Sembra esistere già una voce con orario ${startTime}-${endTime} per il ${date}. Salvare comunque?`)) {
                         showToast("Salvataggio annullato.", "info");
                         return;
                     }
                 }
                 db.entries[date].push(newEntry);
                 showToast('Voce salvata!', 'success');
                 console.log(`Nuova voce salvata per ${date}, ID: ${entryId}`);
             } else if (isEditing && existingEntryIndex === -1) {
                  // Was in edit mode, but original entry not found? Treat as new entry.
                  console.warn(`Tentativo di aggiornare voce ${entryId} non trovata per data ${date}. Aggiunta come nuova.`);
                  db.entries[date].push(newEntry);
                  showToast('Voce salvata come nuova (originale non trovata).', 'success');
             }


            saveDb(db);

            // Reload relevant views if functions exist
            if (typeof loadTimeEntries === 'function') loadTimeEntries();
            if (document.getElementById('calendar-section')?.classList.contains('active') && typeof loadCalendarData === 'function') {
                loadCalendarData(); // Reload calendar data only if it's the active view
            }
             if (document.getElementById('monthly-report-section')?.classList.contains('active') && typeof displayMonthlyReport === 'function') {
                 const monthSelect = document.getElementById('exportMonthSelect');
                 if (monthSelect) displayMonthlyReport(monthSelect.value, document.getElementById('monthlyReportContent')); // Reload report if active
             }

            resetForm();
        }

        function loadTimeEntries(limit = 10) {
            const entriesContainer = document.getElementById('timeEntries');
            if (!entriesContainer) {
                console.warn("Contenitore 'timeEntries' non trovato per caricare le voci.");
                return;
            }
            console.log(`Caricamento ultime ${limit} voci...`);
            const db = getDb();
            entriesContainer.innerHTML = ''; // Clear previous entries

            // Flatten entries and sort by date descending, then by lastModified descending
            const allEntries = Object.entries(db.entries)
                .flatMap(([date, entriesOnDate]) =>
                    entriesOnDate.map(entry => ({ ...entry, date })) // Add date to each entry object
                )
                .sort((a, b) => {
                    // Prioritize date, then modification time
                    const dateA = parseDate(a.date).getTime();
                    const dateB = parseDate(b.date).getTime();
                    if (dateB !== dateA) return dateB - dateA; // Most recent date first

                    // If same date, sort by modification time (most recent first)
                    // Use entry ID (timestamp) as fallback if lastModified is missing
                    const timeA = a.lastModified ? new Date(a.lastModified).getTime() : parseInt(a.id);
                    const timeB = b.lastModified ? new Date(b.lastModified).getTime() : parseInt(b.id);
                    return timeB - timeA;
                });

            const recentEntries = allEntries.slice(0, limit);

            if (recentEntries.length === 0) {
                entriesContainer.innerHTML = '<p style="text-align: center; color: var(--md-sys-color-on-surface-variant); padding: 1rem;">Nessuna voce recente.</p>';
                console.log("Nessuna voce recente trovata.");
                return;
            }

            recentEntries.forEach(entry => {
                // Ensure createTimeEntryElement function exists and handles errors
                if (typeof createTimeEntryElement === 'function') {
                    try {
                        const entryElement = createTimeEntryElement(entry.date, entry);
                        if (entryElement) { // Check if the function returned a valid element
                             entriesContainer.appendChild(entryElement);
                        } else {
                             console.error(`createTimeEntryElement ha restituito null per la voce:`, entry);
                        }
                    } catch (error) {
                        console.error(`Errore nella creazione dell'elemento per la voce ${entry.id} del ${entry.date}:`, error);
                        // Optionally display an error placeholder in the list
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'time-entry';
                        errorDiv.innerHTML = `<div class='time-entry-info' style='color: var(--md-sys-color-error);'>Errore nel caricamento di questa voce.</div>`;
                        entriesContainer.appendChild(errorDiv);
                    }
                } else {
                     console.error("Funzione createTimeEntryElement non definita!");
                     // Stop processing further entries if critical function is missing
                     return;
                }
            });
             console.log(`${recentEntries.length} voci caricate.`);
        }

        function createTimeEntryElement(date, entry) {
            // Validate input
            if (!date || !entry || !entry.id) {
                console.error("createTimeEntryElement: Dati di input non validi.", { date, entry });
                return null; // Return null if data is invalid
            }

             const div = document.createElement('div');
             div.className = 'time-entry';
             div.dataset.id = entry.id;
             div.dataset.date = date;

             let vehicleName = '';
             if (typeof getVehicleNameById === 'function') {
                 vehicleName = getVehicleNameById(entry.vehicle);
             } else {
                  console.warn("Funzione getVehicleNameById non definita.");
             }


             // Build HTML safely
             const totalHoursText = typeof entry.totalHours === 'number' ? `${entry.totalHours.toFixed(1)}h` : 'N/A';
             const startTimeText = entry.startTime || 'N/A';
             const endTimeText = entry.endTime || 'N/A';
             const breakTimeText = typeof entry.breakTime === 'number' ? `${entry.breakTime.toFixed(1)}h` : 'N/A';

             let detailsHtml = `<span><span class="material-symbols-outlined">schedule</span> ${startTimeText} - ${endTimeText}</span>
                              <span><span class="material-symbols-outlined">pause_circle</span> Pausa: ${breakTimeText}</span>`;
             if (entry.transferta === true || (typeof entry.transferta === 'number' && entry.transferta > 0)) {
                 detailsHtml += `<span><span class="material-symbols-outlined">local_shipping</span> Trasferta: TR</span>`;
             }
             if (typeof entry.notturne === 'number' && entry.notturne > 0) {
                 detailsHtml += `<span><span class="material-symbols-outlined">dark_mode</span> Notturne: ${entry.notturne.toFixed(1)}h</span>`;
             }

             const descriptionHtml = entry.description ? `<p class="time-entry-description">${escapeHtml(entry.description)}</p>` : '';
             const vehicleHtml = vehicleName ? `<p class="day-entry-vehicle"><span class="material-symbols-outlined">directions_car</span> ${escapeHtml(vehicleName)}</p>` : '';

             div.innerHTML = `
                 <div class="time-entry-info">
                     <div class="time-entry-header">
                         <span class="time-entry-date">${formatDate(date)}</span>
                         <span class="time-entry-hours">${totalHoursText}</span>
                     </div>
                     <div class="time-entry-details">
                         ${detailsHtml}
                     </div>
                     ${descriptionHtml}
                     ${vehicleHtml}
                 </div>
                 <div class="entry-buttons">
                     <button class="edit-btn" title="Modifica Voce" onclick="editEntry('${date}', '${entry.id}')">
                         <span class="material-symbols-outlined">edit</span>
                     </button>
                     <button class="delete-btn" title="Elimina Voce" onclick="deleteEntry('${date}', '${entry.id}')">
                          <span class="material-symbols-outlined">delete</span>
                     </button>
                 </div>
             `;
             return div;
         }


         function loadExistingEntry(date) {
             // iOS-safe loadExistingEntry with comprehensive error handling
             try {
                 console.log(`Caricamento voce esistente per ${date}...`);
                 const db = getDb();
                 const entries = db.entries[date] || [];
                 const form = document.getElementById('timeEntryForm');
                 const submitBtn = document.getElementById('submitBtn');

                 if (!form || !submitBtn) {
                      console.error("Form o pulsante submit non trovati per loadExistingEntry.");
                      return;
                 }

                 if (entries.length > 0) {
                     // Load the *last* entry for the day if multiple exist.
                     const entryToLoad = entries[entries.length - 1];
                     console.log("Trovata voce da caricare:", entryToLoad);

                     // iOS-safe form field population with error handling
                     try {
                         form.elements.startTime.value = entryToLoad.startTime || '';
                         form.elements.endTime.value = entryToLoad.endTime || '';
                         form.elements.breakTime.value = entryToLoad.breakTime ?? 0.5; // Default to 0.5 if undefined
                         form.elements.notturne.value = entryToLoad.notturne || '';
                     } catch (fieldError) {
                         console.error("Errore nel popolamento campi form:", fieldError);
                     }

                     // Gestione del pulsante di trasferta con error handling
                     try {
                         const trasfertaButton = form.elements.transferta;
                         const textElement = trasfertaButton ? trasfertaButton.querySelector('.trasferta-text') : null;

                         if (trasfertaButton) {
                             if (typeof entryToLoad.transferta === 'boolean' && entryToLoad.transferta) {
                                 // Nuovo formato (boolean)
                                 trasfertaButton.classList.add('active');
                                 trasfertaButton.setAttribute('data-active', 'true');
                                 if (textElement) textElement.textContent = 'Trasferta attiva';
                             } else if (typeof entryToLoad.transferta === 'number' && entryToLoad.transferta > 0) {
                                 // Vecchio formato (numero di ore)
                                 trasfertaButton.classList.add('active');
                                 trasfertaButton.setAttribute('data-active', 'true');
                                 if (textElement) textElement.textContent = 'Trasferta attiva';
                             } else {
                                 trasfertaButton.classList.remove('active');
                                 trasfertaButton.setAttribute('data-active', 'false');
                                 if (textElement) textElement.textContent = 'Seleziona trasferta';
                             }
                         }
                     } catch (trasfertaError) {
                         console.error("Errore nella gestione trasferta:", trasfertaError);
                     }

                 // Gestione delle righe di lavoro multiple
                 const description = entryToLoad.description || '';

                 // Pulisci le righe di lavoro esistenti tranne la prima
                 const container = document.getElementById('work-descriptions-container');
                 if (container) {
                     const rows = container.querySelectorAll('.work-description-row');
                     // Mantieni solo la prima riga
                     for (let i = 1; i < rows.length; i++) {
                         rows[i].remove();
                     }

                     // Imposta il valore della prima riga
                     const firstInput = container.querySelector('.work-description-input');
                     if (firstInput) {
                         firstInput.value = '';
                     }

                     // Se ci sono descrizioni multiple separate da virgole, crea righe aggiuntive
                     if (description) {
                         const descriptions = description.split(',').map(d => d.trim()).filter(d => d);

                         // Imposta la prima descrizione nella riga esistente
                         if (descriptions.length > 0 && firstInput) {
                             firstInput.value = descriptions[0];
                         }

                         // Crea righe aggiuntive per le altre descrizioni
                         for (let i = 1; i < descriptions.length; i++) {
                             const rowIndex = i;
                             const newRow = document.createElement('div');
                             newRow.className = 'work-description-row';
                             newRow.innerHTML = `
                                 <input type="text" class="form-control work-description-input" placeholder="Inserisci un lavoro" data-row="${rowIndex}" value="${descriptions[i]}">
                                 <button type="button" class="btn-remove-work" data-row="${rowIndex}">
                                     <span class="material-symbols-outlined">close</span>
                                 </button>
                             `;
                             container.appendChild(newRow);

                             // Aggiungi event listener alla nuova riga
                             setupWorkRowListeners(newRow.querySelector('.work-description-input'));

                             // Aggiungi event listener al pulsante di rimozione
                             const removeBtn = newRow.querySelector('.btn-remove-work');
                             if (removeBtn) {
                                 removeBtn.addEventListener('click', function() {
                                     newRow.remove();
                                 });
                             }
                         }
                     }
                 } else {
                     // Fallback se il container non esiste
                     const descInput = document.getElementById('description');
                     if (descInput) {
                         descInput.value = description;
                     }
                 }

                 form.elements.totalHours.value = entryToLoad.totalHours || '';
                 form.elements.vehicleSelect.value = entryToLoad.vehicle || ""; // Set vehicle

                 form.dataset.editingId = entryToLoad.id; // Set editing ID
                 submitBtn.innerHTML = '<span class="material-symbols-outlined">update</span> Aggiorna';
             } else {
                 console.log(`Nessuna voce trovata per ${date}, reset parziale del form.`);
                 // Reset form fields but keep the date
                 resetForm(false); // false = Don't reset date
             }
             // Recalculate hours after loading/resetting
             calculateTotalHours();
         } catch (error) {
             console.error("Errore iOS-safe in loadExistingEntry:", error);
             if (typeof showToast === 'function') {
                 showToast("Errore nel caricamento dati, riprova", "error");
             }
         }
         }

         function editEntry(date, entryId) {
             console.log(`Tentativo di modifica voce ${entryId} del ${date}`);
             const db = getDb();
             const entry = db.entries[date]?.find(e => e.id === entryId);
             const form = document.getElementById('timeEntryForm');
             const submitBtn = document.getElementById('submitBtn');
             const dateInput = document.getElementById('date');

             if (!form || !submitBtn || !dateInput) {
                 console.error("Elementi form mancanti per editEntry.");
                 showToast("Errore interno: Impossibile caricare la voce per la modifica.", "error");
                 return;
             }

             if (entry) {
                 console.log("Voce trovata, caricamento nel form:", entry);
                 // Set date in flatpickr first *without* triggering onChange
                 if (dateInput._flatpickr) {
                     dateInput._flatpickr.setDate(date, false);
                 } else {
                      dateInput.value = date; // Fallback
                 }
                 // Manually update the visual indicator as onChange wasn't triggered
                 if (typeof updateDateIndicator === 'function') {
                     updateDateIndicator(parseDate(date));
                 }


                 // Populate form fields
                 form.elements.startTime.value = entry.startTime || '';
                 form.elements.endTime.value = entry.endTime || '';
                 form.elements.breakTime.value = entry.breakTime ?? 0.5;
                 form.elements.notturne.value = entry.notturne || '';

                 // Gestione del pulsante di trasferta
                 const trasfertaButton = form.elements.transferta;
                 const textElement = trasfertaButton.querySelector('.trasferta-text');

                 if (typeof entry.transferta === 'boolean' && entry.transferta) {
                     // Nuovo formato (boolean)
                     trasfertaButton.classList.add('active');
                     trasfertaButton.setAttribute('data-active', 'true');
                     if (textElement) textElement.textContent = 'Trasferta attiva';
                 } else if (typeof entry.transferta === 'number' && entry.transferta > 0) {
                     // Vecchio formato (numero di ore)
                     trasfertaButton.classList.add('active');
                     trasfertaButton.setAttribute('data-active', 'true');
                     if (textElement) textElement.textContent = 'Trasferta attiva';
                 } else {
                     trasfertaButton.classList.remove('active');
                     trasfertaButton.setAttribute('data-active', 'false');
                     if (textElement) textElement.textContent = 'Seleziona trasferta';
                 }

                 form.elements.description.value = entry.description || '';
                 form.elements.totalHours.value = entry.totalHours || '';
                 form.elements.vehicleSelect.value = entry.vehicle || "";

                 form.dataset.editingId = entry.id; // Mark as editing this specific entry
                 submitBtn.innerHTML = '<span class="material-symbols-outlined">update</span> Aggiorna';

                  // Ensure the home section is active and scroll to form
                  const homeNavItem = document.querySelector('.nav-item[data-section="home-section"]');
                  if (homeNavItem && !homeNavItem.classList.contains('active')) {
                      homeNavItem.click(); // Navigate if not already there
                  }
                  // Scroll into view after a short delay for section switch
                 setTimeout(() => {
                     form.scrollIntoView({ behavior: 'smooth', block: 'start' });
                     form.elements.startTime.focus(); // Focus first editable field
                 }, 150);


             } else {
                 console.error(`Voce ${entryId} non trovata per la data ${date}.`);
                 showToast("Voce non trovata.", "error");
                 resetForm(); // Reset form if entry not found
             }
         }

         function deleteEntry(date, entryId) {
             console.log(`Tentativo di eliminazione voce ${entryId} del ${date}`);
             if (confirm(`Sei sicuro di voler eliminare questa voce del ${date}?`)) {
                 const db = getDb();
                 let entryDeleted = false;
                 if (db.entries[date]) {
                     const initialLength = db.entries[date].length;
                     db.entries[date] = db.entries[date].filter(entry => entry.id !== entryId);
                     if (db.entries[date].length < initialLength) {
                         entryDeleted = true;
                         console.log(`Voce ${entryId} eliminata.`);
                     }
                     // If no entries left for this date, remove the date key entirely
                     if (db.entries[date].length === 0) {
                         delete db.entries[date];
                         console.log(`Array voci per ${date} rimosso perché vuoto.`);
                     }
                     saveDb(db);
                     showToast('Voce eliminata.', 'success');
                     // Reload relevant views
                     if (typeof loadTimeEntries === 'function') loadTimeEntries();
                     if (document.getElementById('calendar-section')?.classList.contains('active') && typeof loadCalendarData === 'function') loadCalendarData();
                     if (document.getElementById('monthly-report-section')?.classList.contains('active') && typeof displayMonthlyReport === 'function') {
                          const monthSelect = document.getElementById('exportMonthSelect');
                          if (monthSelect) displayMonthlyReport(monthSelect.value, document.getElementById('monthlyReportContent'));
                     }
                      // If the deleted entry was being edited, reset the form
                      const form = document.getElementById('timeEntryForm');
                      if (form && form.dataset.editingId === entryId) {
                          resetForm(false); // Reset form but keep date
                      }

                 } else {
                      console.warn(`Nessuna voce trovata per la data ${date} durante l'eliminazione.`);
                       showToast('Voce non trovata (potrebbe essere già stata eliminata).', 'warning');
                 }

             } else {
                  console.log("Eliminazione annullata dall'utente.");
             }
         }

        function resetForm(resetDate = true) {
            console.log(`Reset form requested. Reset date: ${resetDate}`);
            const form = document.getElementById('timeEntryForm');
             if (!form) {
                 console.error("Form non trovato per il reset.");
                 return;
             }

             const dateInput = document.getElementById('date');
             const totalHoursInput = document.getElementById('totalHours');
             const submitBtn = document.getElementById('submitBtn');

             // Store current date before reset if needed
             const currentDateValue = dateInput ? dateInput.value : null;

             form.reset(); // Resets native form elements to default values (e.g., breakTime to 0.5)

             // Imposta i valori predefiniti per ora inizio e ora fine
             if (document.getElementById('startTime')) document.getElementById('startTime').value = '7';
             if (document.getElementById('endTime')) document.getElementById('endTime').value = '16.5';
             if (document.getElementById('breakTime')) document.getElementById('breakTime').value = '0.5';

             // Explicitly clear fields that might not reset correctly or need specific handling
             if (document.getElementById('notturne')) document.getElementById('notturne').value = '';

             // Reset trasferta button
             const trasfertaButton = document.getElementById('transferta');
             if (trasfertaButton) {
                 trasfertaButton.classList.remove('active');
                 trasfertaButton.setAttribute('data-active', 'false');
                 const textElement = trasfertaButton.querySelector('.trasferta-text');
                 if (textElement) textElement.textContent = 'Seleziona trasferta';
             }

             // Reset delle righe di lavoro multiple
             const container = document.getElementById('work-descriptions-container');
             if (container) {
                 // Rimuovi tutte le righe tranne la prima
                 const rows = container.querySelectorAll('.work-description-row');
                 for (let i = 1; i < rows.length; i++) {
                     rows[i].remove();
                 }

                 // Resetta il valore della prima riga
                 const firstInput = container.querySelector('.work-description-input');
                 if (firstInput) {
                     firstInput.value = '';
                 }
             } else if (document.getElementById('description')) {
                 // Fallback per il vecchio campo descrizione
                 document.getElementById('description').value = '';
             }
             if (document.getElementById('vehicleSelect')) document.getElementById('vehicleSelect').value = ''; // Reset vehicle select
             if (totalHoursInput) totalHoursInput.value = ''; // Clear calculated hours

             delete form.dataset.editingId; // Remove editing state

             if (submitBtn) {
                 submitBtn.innerHTML = '<span class="material-symbols-outlined">save</span> Salva';
             }

             if (resetDate && dateInput) {
                 const today = new Date();
                 const dateStr = formatDateForInput(today);
                 if (dateInput._flatpickr) {
                     dateInput._flatpickr.setDate(dateStr, true); // Set to today and trigger update
                     console.log("Data reimpostata a oggi nel datepicker.");
                 } else {
                      dateInput.value = dateStr;
                     if(typeof updateDateIndicator === 'function') updateDateIndicator(today); // Manual update if no flatpickr
                     console.log("Data reimpostata a oggi (fallback).");
                 }
             } else if (!resetDate && dateInput && currentDateValue) {
                  // Restore the original date if we didn't reset it
                  if (dateInput._flatpickr) {
                     dateInput._flatpickr.setDate(currentDateValue, false); // Restore without triggering change
                  } else {
                      dateInput.value = currentDateValue;
                  }
                  // Manually update indicator since onChange wasn't triggered
                  if(typeof updateDateIndicator === 'function') updateDateIndicator(parseDate(currentDateValue));
                   console.log(`Data ${currentDateValue} mantenuta dopo reset parziale.`);
             }


             // Recalculate hours (should be 0 or based on default break)
             calculateTotalHours();

             // Focus first field (optional)
             const startTimeInput = document.getElementById('startTime');
             if (startTimeInput) {
                 // startTimeInput.focus(); // Focus might be annoying, comment out for now
             }

             // Reinizializza i controlli orari dopo il reset
             if (typeof initTimeControls === 'function') {
                 initTimeControls();
             }

             console.log("Form resettato.");
         }


        // --- Calendar Functions ---

        function loadCalendarData(targetDate = null) {
             const calendarContainer = document.getElementById('calendarEntries');
             const monthlySummaryContainer = document.getElementById('monthlySummary');
             const calendarSection = document.getElementById('calendar-section');

             // Only render if the calendar section is active
             if (!calendarSection || !calendarSection.classList.contains('active')) {
                 console.log("Skipping calendar render: section not active.");
                 return;
             }

             if (!calendarContainer || !monthlySummaryContainer) {
                 console.error("Elementi del calendario (#calendarEntries) o del riepilogo mensile (#monthlySummary) non trovati.");
                 return;
             }
             console.log("Rendering calendar...");

             const db = getDb();
             // Determine the date to display: use targetDate if provided, else current view, else today
             let dateToDisplay;
             if (targetDate) {
                 dateToDisplay = parseDate(targetDate);
                 if (isNaN(dateToDisplay.getTime())) { // Handle invalid targetDate
                     console.warn(`Data target non valida (${targetDate}), uso data corrente o oggi.`);
                     dateToDisplay = window.currentCalendarDate || new Date();
                 }
             } else {
                 dateToDisplay = window.currentCalendarDate || new Date();
             }
              if (isNaN(dateToDisplay.getTime())) { // Final fallback if stored date is invalid
                    dateToDisplay = new Date();
              }

             window.currentCalendarDate = dateToDisplay; // Store current view date

             const year = dateToDisplay.getFullYear();
             const month = dateToDisplay.getMonth(); // 0-indexed

             try {
                calendarContainer.innerHTML = generateCalendarHTML(year, month, db);
                updateMonthlySummary(year, month, db);
                // Add event listeners after generating HTML
                attachCalendarEventListeners();
                 console.log(`Calendario generato per ${month + 1}/${year}`);
             } catch (error) {
                  console.error(`Errore durante la generazione del calendario per ${month + 1}/${year}:`, error);
                  calendarContainer.innerHTML = `<p style='color: var(--md-sys-color-error); text-align: center; padding: 1rem;'>Errore nella generazione del calendario.</p>`;
             }
         }

         function generateCalendarHTML(year, month, db) {
             const firstDayOfMonth = new Date(year, month, 1);
             const lastDayOfMonth = new Date(year, month + 1, 0);
             const daysInMonth = lastDayOfMonth.getDate();
             let startingDay = firstDayOfMonth.getDay(); // 0 (Sun) to 6 (Sat)
             startingDay = startingDay === 0 ? 6 : startingDay - 1; // Adjust to Mon (0) to Sun (6)

             const monthNames = ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"];
             const dayNames = ["Lun", "Mar", "Mer", "Gio", "Ven", "Sab", "Dom"];

             let html = `<div class="calendar-buttons-container">
                         <button id="calendar-share-btn" class="calendar-share-btn" onclick="toggleCalendarShare()">
                             <span class="material-symbols-outlined">share</span>
                             <span class="share-text">Condividi</span>
                         </button>
                         <button id="calendar-paste-btn" class="calendar-paste-btn" onclick="pasteWorkHours()">
                             <span class="material-symbols-outlined">content_paste</span>
                             <span class="paste-text">Incolla</span>
                         </button>
                       </div>
                       <div class="calendar-header">
                         <button onclick="changeMonth(-1)" title="Mese Precedente"><span class="material-symbols-outlined">chevron_left</span></button>
                         <div class="calendar-title">
                             <span class="calendar-month">${monthNames[month]}</span>
                             <span class="calendar-year">${year}</span>
                         </div>
                         <button onclick="changeMonth(1)" title="Mese Successivo"><span class="material-symbols-outlined">chevron_right</span></button>
                       </div>`;

             html += `<div class="calendar-grid">`;

             // Weekday Headers
             dayNames.forEach(day => {
                 html += `<div class="calendar-weekday">${day}</div>`;
             });

             // Empty cells before the start of the month
             for (let i = 0; i < startingDay; i++) {
                 html += `<div class="calendar-day empty"></div>`;
             }

             // Days of the month
             const today = new Date();
             const todayStr = formatDateForInput(today);

             for (let day = 1; day <= daysInMonth; day++) {
                 const date = new Date(year, month, day);
                 const dateStr = formatDateForInput(date);
                 const entries = db.entries[dateStr] || [];
                 const holidayInfo = db.holidays[dateStr]; // Check ferie/malattie first
                 const isWeekend = date.getDay() === 0 || date.getDay() === 6; // Sunday or Saturday
                 const isStdHoliday = !holidayInfo && isItalianHoliday(date); // Check standard holiday if not ferie/malattia
                 const holidayName = holidayInfo ? (holidayInfo.note || (holidayInfo.type === 'ferie' ? 'Ferie' : 'Malattia')) : (isStdHoliday ? getHolidayName(date) : '');


                 let dayClasses = 'calendar-day';
                 if (dateStr === todayStr) dayClasses += ' today';
                 if (entries.length > 0) dayClasses += ' has-entries';
                  if (holidayInfo) dayClasses += ` ${holidayInfo.type}`; // 'ferie' or 'malattia' class
                 else if (isStdHoliday) dayClasses += ' holiday';
                 // Add weekend class? Optional for styling.
                 // if (isWeekend) dayClasses += ' weekend';

                 let totalHours = 0;
                 let hasTransferta = false;
                 let hasNotturne = false;
                 let hasVehicle = false;
                 entries.forEach(e => {
                     // Ensure totalHours is a number before adding
                     totalHours += (typeof e.totalHours === 'number' ? e.totalHours : 0);
                     if (e.transferta > 0) hasTransferta = true;
                     if (e.notturne > 0) hasNotturne = true;
                     if (e.vehicle) hasVehicle = true;
                 });

                 // Determine title attribute for hover info
                 let title = `${day} ${monthNames[month]} ${year}`;
                 if(holidayInfo) title += ` - ${holidayInfo.type === 'ferie' ? 'Ferie' : 'Malattia'}${holidayInfo.note ? ': ' + holidayInfo.note : ''}`;
                 else if(isStdHoliday) title += ` - ${holidayName}`;
                 else if(entries.length > 0) title += ` - Lavorato: ${totalHours.toFixed(1)}h`;


                 const hasWorkEntries = entries.length > 0 && totalHours > 0;
                 const selectableClass = hasWorkEntries ? ' selectable' : '';
                 const checkbox = hasWorkEntries ? `<div class="calendar-day-checkbox">
                                                      <input type="checkbox" id="day-${dateStr}" data-date="${dateStr}">
                                                      <span class="checkmark"></span>
                                                   </div>` : '';
                 html += `<div class="${dayClasses}${selectableClass}" data-date="${dateStr}" title="${escapeHtml(title)}">
                          ${checkbox}`;
                 html += `<span class="calendar-day-number">${day}</span>`;
                 html += `<div class="calendar-day-content">`;

                  if (holidayInfo) {
                     // Show Ferie/Malattia icon and optional note
                     const icon = holidayInfo.type === 'ferie' ? 'beach_access' : 'sick';
                     html += `<span class="calendar-icons"><span class="material-symbols-outlined">${icon}</span></span>`;
                      if (holidayInfo.note) {
                          html += `<span class="calendar-holiday-name">${escapeHtml(holidayInfo.note)}</span>`;
                      } else {
                           html += `<span class="calendar-holiday-name">${holidayInfo.type === 'ferie' ? 'Ferie' : 'Malattia'}</span>`;
                      }
                  } else if (entries.length > 0) {
                     // Show work details
                      if (totalHours > 0) { // Show hours if positive
                        html += `<span class="calendar-hours">${totalHours.toFixed(1)}h</span>`;
                      } else {
                        // Se non ci sono ore ma ci sono voci (solo descrizione), mostra una "i" di info
                        html += `<span class="info-icon" title="Solo descrizione">i</span>`;
                      }
                     html += `<div class="calendar-icons">`;
                     if (hasTransferta) html += `<span class="material-symbols-outlined" title="Trasferta">local_shipping</span>`;
                     if (hasNotturne) html += `<span class="material-symbols-outlined" title="Notturne">dark_mode</span>`;
                     if (hasVehicle) html += `<span class="material-symbols-outlined" title="Mezzo utilizzato">directions_car</span>`;
                     html += `</div>`;
                 } else if (isStdHoliday) {
                     // Show standard holiday name
                     html += `<span class="calendar-holiday-name">${escapeHtml(holidayName)}</span>`;
                 } else {
                      // Empty workday or weekend - maybe add a subtle indicator?
                      // html += `<span style="opacity: 0.5;">-</span>`
                 }

                 html += `</div>`; // end content
                 html += `</div>`; // end day
             }

             // Empty cells after the end of the month
             const totalCells = startingDay + daysInMonth;
             const remainingCells = (7 - (totalCells % 7)) % 7;
             for (let i = 0; i < remainingCells; i++) {
                 html += `<div class="calendar-day empty"></div>`;
             }

             html += `</div>`; // end grid
             return html;
         }

        // Calendar Share Functionality
        let calendarSelectionMode = false;
        let selectedDays = new Set();

        function toggleCalendarShare() {
            const btn = document.getElementById('calendar-share-btn');
            const calendar = document.getElementById('calendarEntries');

            if (!calendarSelectionMode) {
                // Attiva modalità selezione
                calendarSelectionMode = true;
                calendar.classList.add('calendar-selection-mode');
                btn.querySelector('.share-text').textContent = 'Copia (0)';
                btn.querySelector('.material-symbols-outlined').textContent = 'content_copy';

                // Aggiungi event listeners per la selezione
                attachSelectionListeners();
            } else {
                // Copia e reset
                if (selectedDays.size > 0) {
                    copySelectedDaysToClipboard();
                } else {
                    showToast('Nessun giorno selezionato', 'warning');
                }
                resetCalendarSelection();
            }
        }

        function attachSelectionListeners() {
            const selectableDays = document.querySelectorAll('.calendar-day.selectable');

            selectableDays.forEach(day => {
                day.addEventListener('click', handleDaySelection);
                day.addEventListener('touchstart', handleDaySelection);
            });
        }

        function handleDaySelection(event) {
            event.preventDefault();
            event.stopPropagation();

            const day = event.currentTarget;
            const dateStr = day.dataset.date;
            const checkbox = day.querySelector('input[type="checkbox"]');

            if (!checkbox) return;

            if (selectedDays.has(dateStr)) {
                selectedDays.delete(dateStr);
                checkbox.checked = false;
                day.classList.remove('selected');
            } else {
                selectedDays.add(dateStr);
                checkbox.checked = true;
                day.classList.add('selected');
            }

            updateShareButton();
        }

        function updateShareButton() {
            const btn = document.getElementById('calendar-share-btn');
            const count = selectedDays.size;
            btn.querySelector('.share-text').textContent = `Copia (${count})`;
        }

        function copySelectedDaysToClipboard() {
            const db = getDb();
            const sortedDates = Array.from(selectedDays).sort((a, b) => {
                const dateA = parseDate(a);
                const dateB = parseDate(b);
                return dateA - dateB;
            });

            let reportText = "🗓️ REPORT ORE LAVORO\n\n";

            sortedDates.forEach(dateStr => {
                const entries = db.entries[dateStr] || [];
                const date = parseDate(dateStr);
                const dayName = ['Domenica', 'Lunedì', 'Martedì', 'Mercoledì', 'Giovedì', 'Venerdì', 'Sabato'][date.getDay()];
                const formattedDate = `${dayName} ${date.getDate().toString().padStart(2, '0')}/${(date.getMonth() + 1).toString().padStart(2, '0')}/${date.getFullYear()}`;

                reportText += `📅 ${formattedDate}\n`;

                entries.forEach(entry => {
                    // Formato ore: inizio-pausa-fine
                    const startTime = entry.startTime || '';
                    const endTime = entry.endTime || '';
                    const breakTime = entry.breakTime || 0;
                    const timeFormat = `${startTime}-${breakTime}-${endTime}`;

                    reportText += `⏰ Ore: ${timeFormat}\n`;

                    // Descrizione lavoro
                    if (entry.description && entry.description.trim() !== '') {
                        reportText += `📍 ${entry.description}\n`;
                    }

                    // Trasferta (solo se true)
                    if (entry.transferta === true) {
                        reportText += `🚗 Trasferta: Sì\n`;
                    }

                    // Ore notturne (solo se > 0)
                    if (entry.notturne && entry.notturne > 0) {
                        reportText += `🌙 Ore notturne: ${entry.notturne}h\n`;
                    }

                    // Totale ore
                    if (entry.totalHours && entry.totalHours > 0) {
                        reportText += `💼 Totale ore: ${entry.totalHours}h\n`;
                    }
                });

                reportText += "\n";
            });

            // Copia negli appunti
            navigator.clipboard.writeText(reportText).then(() => {
                showSuccessButton();
                showToast('Report copiato negli appunti!', 'success');
            }).catch(err => {
                console.error('Errore nella copia:', err);
                showToast('Errore nella copia negli appunti', 'error');
            });
        }

        function showSuccessButton() {
            const btn = document.getElementById('calendar-share-btn');
            btn.classList.add('success');
            btn.querySelector('.share-text').textContent = 'Copiato!';
            btn.querySelector('.material-symbols-outlined').textContent = 'check';

            setTimeout(() => {
                resetCalendarSelection();
            }, 2000);
        }

        function resetCalendarSelection() {
            const btn = document.getElementById('calendar-share-btn');
            const calendar = document.getElementById('calendarEntries');

            calendarSelectionMode = false;
            selectedDays.clear();
            calendar.classList.remove('calendar-selection-mode');

            // Reset pulsante
            btn.classList.remove('success');
            btn.querySelector('.share-text').textContent = 'Condividi';
            btn.querySelector('.material-symbols-outlined').textContent = 'share';

            // Rimuovi selezioni
            document.querySelectorAll('.calendar-day.selected').forEach(day => {
                day.classList.remove('selected');
                const checkbox = day.querySelector('input[type="checkbox"]');
                if (checkbox) checkbox.checked = false;
            });

            // Rimuovi event listeners
            document.querySelectorAll('.calendar-day.selectable').forEach(day => {
                day.removeEventListener('click', handleDaySelection);
                day.removeEventListener('touchstart', handleDaySelection);
            });
        }

        // Calendar Paste Functionality
        let pendingImportData = null;

        async function pasteWorkHours() {
            const btn = document.getElementById('calendar-paste-btn');

            try {
                // Update button to processing state
                btn.classList.add('processing');
                btn.querySelector('.paste-text').textContent = 'Lettura...';
                btn.querySelector('.material-symbols-outlined').textContent = 'refresh';

                // Check clipboard API support
                if (!navigator.clipboard || !navigator.clipboard.readText) {
                    throw new Error('La funzione incolla non è supportata in questo browser');
                }

                // Read clipboard text
                const clipboardText = await navigator.clipboard.readText();

                if (!clipboardText || clipboardText.trim() === '') {
                    throw new Error('Il clipboard è vuoto');
                }

                // Parse the clipboard content
                const parsedData = parseWorkHoursReport(clipboardText);

                if (!parsedData || parsedData.entries.length === 0) {
                    throw new Error('Formato non riconosciuto. Assicurati di aver copiato un report valido.');
                }

                // Store data for import and show preview
                pendingImportData = parsedData;
                showImportPreview(parsedData);

                // Reset button
                resetPasteButton();

            } catch (error) {
                console.error('Errore durante l\'incolla:', error);

                // Show error state
                btn.classList.remove('processing');
                btn.classList.add('error');
                btn.querySelector('.paste-text').textContent = 'Errore';
                btn.querySelector('.material-symbols-outlined').textContent = 'error';

                showToast(error.message, 'error');

                // Reset after delay
                setTimeout(() => {
                    resetPasteButton();
                }, 3000);
            }
        }

        function parseWorkHoursReport(text) {
            try {
                const lines = text.split('\n').map(line => line.trim()).filter(line => line !== '');

                if (lines.length === 0 || !lines[0].includes('REPORT ORE LAVORO')) {
                    return null;
                }

                const entries = [];
                let currentEntry = null;

                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i];

                    // Date line (📅 Day DD/MM/YYYY)
                    const dateMatch = line.match(/^📅\s+(.+)\s+(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
                    if (dateMatch) {
                        // Save previous entry if exists
                        if (currentEntry) {
                            entries.push(currentEntry);
                        }

                        // Create new entry
                        const day = parseInt(dateMatch[2]);
                        const month = parseInt(dateMatch[3]) - 1; // JS months are 0-based
                        const year = parseInt(dateMatch[4]);
                        const date = new Date(year, month, day);

                        currentEntry = {
                            dateStr: formatDateForInput(date),
                            date: date,
                            dayName: dateMatch[1],
                            startTime: '',
                            endTime: '',
                            breakTime: 0,
                            description: '',
                            transferta: false,
                            notturne: 0,
                            totalHours: 0
                        };
                        continue;
                    }

                    if (!currentEntry) continue;

                    // Time line (⏰ Ore: start-break-end)
                    const timeMatch = line.match(/^⏰\s+Ore:\s+(.+)-(.+)-(.+)$/);
                    if (timeMatch) {
                        currentEntry.startTime = timeMatch[1].trim();
                        currentEntry.breakTime = parseFloat(timeMatch[2].trim()) || 0;
                        currentEntry.endTime = timeMatch[3].trim();
                        continue;
                    }

                    // Description line (📍 text)
                    const descMatch = line.match(/^📍\s+(.+)$/);
                    if (descMatch) {
                        currentEntry.description = descMatch[1].trim();
                        continue;
                    }

                    // Trasferta line (🚗 Trasferta: Sì)
                    if (line.match(/^🚗\s+Trasferta:\s+Sì$/)) {
                        currentEntry.transferta = true;
                        continue;
                    }

                    // Night hours line (🌙 Ore notturne: Xh)
                    const nightMatch = line.match(/^🌙\s+Ore\s+notturne:\s+(\d+(?:\.\d+)?)h$/);
                    if (nightMatch) {
                        currentEntry.notturne = parseFloat(nightMatch[1]);
                        continue;
                    }

                    // Total hours line (💼 Totale ore: Xh)
                    const totalMatch = line.match(/^💼\s+Totale\s+ore:\s+(\d+(?:\.\d+)?)h$/);
                    if (totalMatch) {
                        currentEntry.totalHours = parseFloat(totalMatch[1]);
                        continue;
                    }
                }

                // Add last entry
                if (currentEntry) {
                    entries.push(currentEntry);
                }

                return {
                    totalEntries: entries.length,
                    entries: entries
                };

            } catch (error) {
                console.error('Errore nel parsing:', error);
                return null;
            }
        }

        function showImportPreview(data) {
            const modal = document.getElementById('importPreviewModal');
            const summary = document.getElementById('importSummary');
            const entriesList = document.getElementById('importEntriesList');

            // Build summary
            const totalDays = data.entries.length;
            const totalHours = data.entries.reduce((sum, entry) => sum + entry.totalHours, 0);
            const dateRange = getDateRange(data.entries);

            summary.innerHTML = `
                <h4>📊 Riepilogo Importazione</h4>
                <p><strong>Giorni da importare:</strong> ${totalDays}</p>
                <p><strong>Ore totali:</strong> ${totalHours.toFixed(1)}h</p>
                <p><strong>Periodo:</strong> ${dateRange}</p>
            `;

            // Build entries list
            entriesList.innerHTML = '';
            data.entries.forEach(entry => {
                const entryDiv = document.createElement('div');
                entryDiv.className = 'import-entry-item';

                const details = [];
                if (entry.startTime && entry.endTime) {
                    details.push(`⏰ ${entry.startTime}-${entry.breakTime}-${entry.endTime}`);
                }
                if (entry.description) {
                    details.push(`📍 ${entry.description}`);
                }
                if (entry.transferta) {
                    details.push('🚗 Trasferta');
                }
                if (entry.notturne > 0) {
                    details.push(`🌙 ${entry.notturne}h notturne`);
                }
                if (entry.totalHours > 0) {
                    details.push(`💼 ${entry.totalHours}h totali`);
                }

                entryDiv.innerHTML = `
                    <div class="import-entry-date">${entry.dayName} ${entry.dateStr}</div>
                    <div class="import-entry-details">${details.join(' • ')}</div>
                `;

                entriesList.appendChild(entryDiv);
            });

            // Check for conflicts
            checkImportConflicts(data.entries);

            // Show modal
            modal.style.display = 'block';
        }

        function getDateRange(entries) {
            if (entries.length === 0) return '';
            if (entries.length === 1) return entries[0].dateStr;

            const dates = entries.map(e => e.date).sort((a, b) => a - b);
            const first = formatDateForInput(dates[0]);
            const last = formatDateForInput(dates[dates.length - 1]);

            return `${first} - ${last}`;
        }

        function checkImportConflicts(entries) {
            const db = getDb();
            const replaceBtn = document.getElementById('importReplaceBtn');
            const mergeBtn = document.getElementById('importMergeBtn');

            let hasConflicts = false;
            let conflictDays = 0;

            entries.forEach(entry => {
                if (db.entries[entry.dateStr] && db.entries[entry.dateStr].length > 0) {
                    hasConflicts = true;
                    conflictDays++;
                }
            });

            if (hasConflicts) {
                replaceBtn.textContent = `Sostituisci (${conflictDays} conflitti)`;
                replaceBtn.style.display = 'block';
                mergeBtn.textContent = 'Aggiungi';
            } else {
                replaceBtn.style.display = 'none';
                mergeBtn.textContent = 'Importa';
            }
        }

        function importWorkHours(mode) {
            if (!pendingImportData) {
                showToast('Nessun dato da importare', 'error');
                return;
            }

            const db = getDb();
            let importedCount = 0;
            let replacedCount = 0;

            pendingImportData.entries.forEach(entry => {
                const dateStr = entry.dateStr;

                // Check if date already has entries
                const existingEntries = db.entries[dateStr] || [];

                if (mode === 'replace' && existingEntries.length > 0) {
                    // Replace existing entries
                    db.entries[dateStr] = [];
                    replacedCount++;
                }

                // Ensure entries array exists
                if (!db.entries[dateStr]) {
                    db.entries[dateStr] = [];
                }

                // Create new entry object
                const newEntry = {
                    startTime: entry.startTime,
                    endTime: entry.endTime,
                    breakTime: entry.breakTime,
                    description: entry.description,
                    transferta: entry.transferta,
                    notturne: entry.notturne,
                    totalHours: entry.totalHours,
                    id: generateId(),
                    timestamp: Date.now()
                };

                db.entries[dateStr].push(newEntry);
                importedCount++;
            });

            // Save to database
            saveDb(db);

            // Show success message
            let message = `${importedCount} giorni importati`;
            if (replacedCount > 0) {
                message += `, ${replacedCount} sostituiti`;
            }
            showToast(message, 'success');

            // Close modal and refresh views
            closeImportPreviewModal();

            // Refresh calendar and other views
            if (typeof loadCalendarData === 'function') {
                loadCalendarData();
            }
            if (typeof loadTimeEntries === 'function') {
                loadTimeEntries();
            }
        }

        function closeImportPreviewModal() {
            const modal = document.getElementById('importPreviewModal');
            modal.style.display = 'none';
            pendingImportData = null;
        }

        function resetPasteButton() {
            const btn = document.getElementById('calendar-paste-btn');
            btn.classList.remove('processing', 'success', 'error');
            btn.querySelector('.paste-text').textContent = 'Incolla';
            btn.querySelector('.material-symbols-outlined').textContent = 'content_paste';
        }

        // Helper function to generate unique IDs
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }


        function updateMonthlySummary(year, month, db) {
            // Get the container element
            const monthlySummaryContainer = document.getElementById('monthlySummary');
            if (!monthlySummaryContainer) {
                console.warn("Contenitore riepilogo mensile del calendario (#monthlySummary) non trovato.");
                return;
            }

            // Calculate stats (same logic as before)
            let totalHours = 0;
            let workDays = 0;
            let totalTransferta = 0;
            let totalNotturne = 0;
            let ferieDays = 0;
            let malattiaDays = 0;

             const daysInMonth = new Date(year, month + 1, 0).getDate();
             for (let day = 1; day <= daysInMonth; day++) {
                 const date = new Date(year, month, day);
                 const dateStr = formatDateForInput(date);
                 const entries = db.entries[dateStr] || [];
                const holidayInfo = db.holidays[dateStr];

                if (holidayInfo) {
                    if (holidayInfo.type === 'ferie') ferieDays++;
                    if (holidayInfo.type === 'malattia') malattiaDays++;
                } else if (entries.length > 0) {
                     let dayHasHours = false;
                     let dayHasDescription = false;
                     entries.forEach(entry => {
                         // Usa totalHours se disponibile, altrimenti calcola dalle ore di inizio e fine
                         if (typeof entry.totalHours === 'number' && entry.totalHours > 0) {
                             totalHours += entry.totalHours;
                             console.log(`Riepilogo mensile: Aggiunte ${entry.totalHours} ore dal campo totalHours`);
                         } else if (entry.startTime && entry.endTime) {
                             const startTime = parseTimeString(entry.startTime);
                             const endTime = parseTimeString(entry.endTime);

                             if (startTime && endTime) {
                                 let entryHours = calculateHoursBetween(startTime, endTime);

                                 // Sottrai la pausa se presente
                                 if (entry.breakTime && !isNaN(parseFloat(entry.breakTime))) {
                                     entryHours -= parseFloat(entry.breakTime);
                                 }

                                 totalHours += entryHours;
                                 console.log(`Riepilogo mensile: Calcolate e aggiunte ${entryHours} ore da ${entry.startTime} a ${entry.endTime}`);
                             }
                         }

                         // Contiamo i giorni di trasferta, non le ore
                         if (entry.transferta === true || entry.isTransfer === true ||
                             (typeof entry.transferta === 'boolean' && entry.transferta) ||
                             (typeof entry.transferta === 'string' && entry.transferta === 'true')) {
                             // Incrementiamo solo se non abbiamo già contato questo giorno
                             if (!entries.some((e, idx) => idx < entries.indexOf(entry) &&
                                 (e.transferta === true || e.isTransfer === true ||
                                  (typeof e.transferta === 'boolean' && e.transferta) ||
                                  (typeof e.transferta === 'string' && e.transferta === 'true')))) {
                                 totalTransferta += 1;
                                 console.log(`Riepilogo mensile: Aggiunto giorno di trasferta`);
                             }
                         }

                         // Calcola le ore notturne
                         if (entry.isNightShift || entry.notturne === 'true' || entry.notturne === true) {
                             // Se è un turno notturno, tutte le ore sono notturne
                             if (typeof entry.totalHours === 'number' && entry.totalHours > 0) {
                                 totalNotturne += entry.totalHours;
                                 console.log(`Riepilogo mensile: Aggiunte ${entry.totalHours} ore notturne (turno notturno)`);
                             }
                         } else if (typeof entry.notturne === 'number' && entry.notturne > 0) {
                             // Se ci sono ore notturne specificate come numero
                             totalNotturne += entry.notturne;
                             console.log(`Riepilogo mensile: Aggiunte ${entry.notturne} ore notturne`);
                         }

                         // Verifica se ci sono ore o descrizione
                         if (typeof entry.totalHours === 'number' && entry.totalHours > 0) dayHasHours = true;
                         if (entry.description && entry.description.trim() !== '') dayHasDescription = true;
                    });
                    // Conta come giorno lavorato se ci sono ore o descrizione
                    if (dayHasHours || dayHasDescription) workDays++;
                }
            }

            // Arrotonda le ore a una cifra decimale (per gestire le mezze ore)
            totalHours = Math.round(totalHours * 10) / 10;
            totalNotturne = Math.round(totalNotturne * 10) / 10;

            console.log(`Riepilogo mensile finale: Ore totali: ${totalHours}, Ore notturne: ${totalNotturne}, Trasferte: ${totalTransferta}, Giorni lavorati: ${workDays}, Ferie: ${ferieDays}, Malattia: ${malattiaDays}`);

            // Generate the HTML string (copied structure and styles from displayMonthlyReport's statsHtml)
            const statsHtml = `
                 <div class="monthly-report-stats card" style="background-color: var(--md-sys-color-surface-variant); padding: 1rem; margin-bottom: 0;">
                     <div class="monthly-stat-item" style="background-color: var(--md-sys-color-surface);">
                         <span class="monthly-stat-value">${totalHours.toFixed(1)}h</span>
                         <span class="monthly-stat-label">Ore Totali</span>
                     </div>
                      <div class="monthly-stat-item" style="background-color: var(--md-sys-color-surface);">
                         <span class="monthly-stat-value">${workDays}</span>
                         <span class="monthly-stat-label">Giorni Lavorati</span>
                     </div>
                     <div class="monthly-stat-item" style="background-color: var(--md-sys-color-surface);">
                         <span class="monthly-stat-value">${totalTransferta}</span>
                         <span class="monthly-stat-label">Giorni Trasferta</span>
                     </div>
                     <div class="monthly-stat-item" style="background-color: var(--md-sys-color-surface);">
                         <span class="monthly-stat-value">${totalNotturne.toFixed(1)}h</span>
                         <span class="monthly-stat-label">Ore Notturne</span>
                     </div>
                      ${ferieDays > 0 ? `
                     <div class="monthly-stat-item" style="background-color: var(--md-sys-color-tertiary-container); color: var(--md-sys-color-on-tertiary-container);">
                         <span class="monthly-stat-value" style="color: var(--md-sys-color-tertiary);">${ferieDays}</span>
                         <span class="monthly-stat-label">Giorni Ferie</span>
                     </div>` : ''}
                     ${malattiaDays > 0 ? `
                     <div class="monthly-stat-item" style="background-color: var(--md-sys-color-secondary-container); color: var(--md-sys-color-on-secondary-container);">
                         <span class="monthly-stat-value" style="color: var(--md-sys-color-secondary);">${malattiaDays}</span>
                         <span class="monthly-stat-label">Giorni Malattia</span>
                     </div>` : ''}
                 </div>
            `;

            // Inject the generated HTML into the container
            monthlySummaryContainer.innerHTML = statsHtml;

            console.log(`Riepilogo mensile calendario aggiornato (con HTML generato) per ${month + 1}/${year}: Lavorati=${workDays}, Ore=${totalHours.toFixed(1)}, Ferie=${ferieDays}, Malattia=${malattiaDays}`);
        }


         function changeMonth(delta) {
             if (!window.currentCalendarDate) window.currentCalendarDate = new Date();
             // Ensure we have a valid date before changing month
             if (isNaN(window.currentCalendarDate.getTime())) window.currentCalendarDate = new Date();

             window.currentCalendarDate.setDate(1); // Go to the 1st to avoid month skipping issues
             window.currentCalendarDate.setMonth(window.currentCalendarDate.getMonth() + delta);
             console.log(`Cambio mese a: ${window.currentCalendarDate.toLocaleDateString()}`);
             loadCalendarData(formatDateForInput(window.currentCalendarDate)); // Reload with new date
         }

         function attachCalendarEventListeners() {
             const days = document.querySelectorAll('#calendarEntries .calendar-day:not(.empty)');
             if (days.length === 0) {
                 console.log("Nessun giorno cliccabile trovato nel calendario per aggiungere event listener.");
                 return;
             }
             let listenerCount = 0; // Rename variable for clarity
             days.forEach(day => {
                 // Remove previous listener if any? Maybe not necessary if grid is regenerated.
                 day.addEventListener('click', (event) => { // Add event parameter
                     const clickedElement = event.currentTarget; // Get the element the listener is attached to
                     const dateStr = clickedElement.getAttribute('data-date');
                     console.log(`[attachCalendarEventListeners] Click detected on element with data-date: ${dateStr}`); // LOG 1
                     if (dateStr && typeof openDayModal === 'function') {
                          console.log(`[attachCalendarEventListeners] Calling openDayModal with dateStr: ${dateStr}`); // LOG 2
                         openDayModal(dateStr);
                     }
                 });
                 listenerCount++;
             });
             console.log(`Aggiunti listener di click a ${listenerCount} giorni del calendario.`);
         }

        // --- Modal Functions ---

        function openDayModal(dateStr) {
            console.log(`[openDayModal] Function called with dateStr: ${dateStr}`); // LOG 3
            const modal = document.getElementById('dayModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalHolidayInfo = document.getElementById('modalHolidayInfo'); // Get new element
            const modalEntries = document.getElementById('modalEntries');
            const daySummary = modal ? modal.querySelector('.day-summary') : null;
            const addEntryModalBtn = modal ? modal.querySelector('#addEntryBtn') : null;
            const markFerieBtn = modal ? modal.querySelector('#markFerieBtn') : null; // New
            const markMalattiaBtn = modal ? modal.querySelector('#markMalattiaBtn') : null; // New

            // Add new buttons to null check
            if (!modal || !modalTitle || !modalHolidayInfo || !daySummary || !modalEntries || !addEntryModalBtn || !markFerieBtn || !markMalattiaBtn) {
                console.error("Uno o più elementi del modale (inclusi nuovi pulsanti) non trovati.");
                showToast("Errore: Impossibile aprire i dettagli del giorno.", "error");
                return;
            }

            // Assicuriamoci che il modale sia visibile
            modal.style.opacity = "1";

            // --- Restore code to define titleDateStr ---
            const db = getDb(); // Ensure db is defined early if needed
            let parsedDateResult;
            try {
                 parsedDateResult = parseDate(dateStr);
                 // Keep the log but remove the number for simplicity
                 console.log(`[openDayModal] parseDate('${dateStr}') result:`, parsedDateResult, ` (isValid: ${!isNaN(parsedDateResult?.getTime())})`);
            } catch (e) {
                 console.error(`[openDayModal] Error calling parseDate('${dateStr}'):`, e);
                 parsedDateResult = new Date(NaN);
            }

            window.lastClickedDate = dateStr; // Store for other actions

            // Construct title
            let titleDateStr = dateStr; // Fallback
            const parts = dateStr.split('/');
             if (parts.length === 3) {
                 const dayPart = parts[0];
                 const monthIndex = parseInt(parts[1], 10) - 1;
                 const yearPart = parts[2];
                 const monthNames = ["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"];
                 if(monthIndex >= 0 && monthIndex < 12) {
                    titleDateStr = `${dayPart} ${monthNames[monthIndex]} ${yearPart}`;
                    if (!isNaN(parsedDateResult?.getTime())) {
                         try {
                             titleDateStr = parsedDateResult.toLocaleDateString('it-IT', { weekday: 'long', day: 'numeric', month: 'long' });
                         } catch (e) { console.warn(`[openDayModal] Error formatting date title with toLocaleDateString:`, e); /* Use simple string */ }
                    }
                 }
             }
             // --- End restore titleDateStr code ---

             modalTitle.textContent = `Dettagli ${titleDateStr}`; // Set the title
            modalEntries.innerHTML = ''; // Clear previous entries
             modalHolidayInfo.innerHTML = ''; // Clear holiday info
             modalHolidayInfo.style.display = 'none'; // Hide holiday info by default

            // --- Reset button states ---
            addEntryModalBtn.style.display = 'inline-flex';
            markFerieBtn.style.display = 'inline-flex';
            markMalattiaBtn.style.display = 'inline-flex';
            daySummary.style.display = 'grid';

            // --- Remove previous listeners from absence buttons to prevent duplicates ---
            markFerieBtn.replaceWith(markFerieBtn.cloneNode(true));
            markMalattiaBtn.replaceWith(markMalattiaBtn.cloneNode(true));
            // Re-acquire references after cloning
            const freshMarkFerieBtn = modal.querySelector('#markFerieBtn');
            const freshMarkMalattiaBtn = modal.querySelector('#markMalattiaBtn');

            // --- Attach new listeners ---
            freshMarkFerieBtn.addEventListener('click', () => markDayAsAbsence(dateStr, 'ferie'));
            freshMarkMalattiaBtn.addEventListener('click', () => markDayAsAbsence(dateStr, 'malattia'));

             // --- Get data AFTER setting up buttons and title ---
             console.log(`[openDayModal] Accessing db.entries with key: '${dateStr}'`);
             const entries = db.entries[dateStr] || [];
             console.log(`[openDayModal] Found ${entries.length} entries for key '${dateStr}'. Content:`, JSON.stringify(entries)); // Log the content
             console.log(`[openDayModal] Accessing db.holidays with key: '${dateStr}'`);
             const holidayInfo = db.holidays[dateStr];
             console.log(`[openDayModal] Found holidayInfo:`, holidayInfo);

            if (holidayInfo) {
                 // --- Display Ferie/Malattia Info (already marked) ---
                 // Restore the code that displays the colored block and delete button
                 console.log(`Giorno ${dateStr} è ${holidayInfo.type}`);
                 const typeText = holidayInfo.type === 'ferie' ? 'Ferie' : 'Malattia';
                 const icon = holidayInfo.type === 'ferie' ? 'beach_access' : 'sick';
                 modalEntries.innerHTML = `
                     <div style="text-align: center; padding: 1rem; background-color: ${holidayInfo.type === 'ferie' ? 'var(--md-sys-color-tertiary-container)' : 'var(--md-sys-color-secondary-container)'} ; border-radius: var(--border-radius-medium); color: ${holidayInfo.type === 'ferie' ? 'var(--md-sys-color-on-tertiary-container)' : 'var(--md-sys-color-on-secondary-container)'};">
                         <span class="material-symbols-outlined" style="font-size: 2rem; vertical-align: middle; margin-right: 0.5rem;">${icon}</span>
                         <strong style="font-size: 1.1rem;">${typeText}</strong>
                         ${holidayInfo.note ? `<p style="margin-top: 0.5rem; font-style: italic;">${escapeHtml(holidayInfo.note)}</p>` : ''}
                          <button class="delete-btn" style="margin-top: 1rem; background-color: var(--md-sys-color-error-container); color: var(--md-sys-color-on-error-container);" onclick="deleteFerieMalattieEntryFromModal('${dateStr}')">
                             <span class="material-symbols-outlined">delete</span> Elimina ${typeText}
                         </button>
                     </div>`;

                 // Hide action buttons if already marked as absence
                 daySummary.style.display = 'none';
                 addEntryModalBtn.style.display = 'none';
                 freshMarkFerieBtn.style.display = 'none'; // Use fresh reference
                 freshMarkMalattiaBtn.style.display = 'none'; // Use fresh reference

            } else if (entries.length > 0) {
                 // --- Display Work Entries ---
                 // Keep absence buttons visible
                 let totalHoursSummary = 0; // Rename for clarity: this is for the summary
                 let totalTransferta = 0;
                 let totalNotturne = 0;
                 let totalBreakTime = 0; // Added for break time
                 modalEntries.innerHTML = entries.map((entry, index) => {
                     // Reconstruct full date-time strings for Date parsing
                     // dateStr is DD/MM/YYYY, startTime/endTime are HH:MM
                     const dateParts = dateStr.split('/'); // [DD, MM, YYYY]
                     if (dateParts.length !== 3) {
                         console.error(`Invalid dateStr format: ${dateStr} for entry ID ${entry.id}`);
                         return `<div class="modal-entry error">Errore formato data.</div>`;
                     }
                     const isoDatePart = `${dateParts[2]}-${dateParts[1].padStart(2, '0')}-${dateParts[0].padStart(2, '0')}`;
                     // Ensure startTime and endTime exist and are valid time formats (HH:MM)
                     // Handle both "HH:MM" and numeric string format like "6" or "13"
                     let rawStartTime = entry.startTime ? String(entry.startTime) : '0';
                     let rawEndTime = entry.endTime ? String(entry.endTime) : '0';

                     // Special case: "24" represents midnight at the START of the day, treat as "00"
                     if (rawStartTime === '24') {
                         rawStartTime = '00';
                     }

                     // Function to format raw time (string number, decimal, or HH:MM) into HH:MM
                     const formatToHHMM = (rawTime) => {
                         if (String(rawTime).match(/^\d{1,2}:\d{2}$/)) {
                             return rawTime; // Already HH:MM
                         }
                         const timeNum = parseFloat(String(rawTime).replace(',', '.')); // Handle comma decimal
                         if (isNaN(timeNum)) {
                             return '00:00'; // Invalid input
                         }
                         const hours = Math.floor(timeNum);
                         const minutes = Math.round((timeNum - hours) * 60);
                         return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
                     };

                     let startTimeStr = formatToHHMM(rawStartTime);
                     let endTimeStr = formatToHHMM(rawEndTime);

                      const startDateTimeString = `${isoDatePart}T${startTimeStr}:00`;
                      const endDateTimeString = `${isoDatePart}T${endTimeStr}:00`;

                     //console.log(`Parsing start: ${startDateTimeString}, end: ${endDateTimeString}`); // Debugging

                     const start = new Date(startDateTimeString);
                     const end = new Date(endDateTimeString);

                     // Check if dates are valid after parsing
                     if (isNaN(start.getTime()) || isNaN(end.getTime())) {
                         console.error(`Invalid date constructed for entry ID ${entry.id}:`, { startStr: startDateTimeString, endStr: endDateTimeString });
                         return `<div class="modal-entry error">Errore nella visualizzazione dell'orario per questa voce.</div>`;
                     }

                     // Calculate duration for THIS entry, subtracting break time
                     const rawDuration = (end - start) / (1000 * 60 * 60);
                     const breakTimeForEntry = Number(entry.breakTime) || 0;
                     const hoursNet = Math.max(0, rawDuration - breakTimeForEntry);

                     // Add pre-calculated totalHours (which includes break) to summary total
                     totalHoursSummary += Number(entry.totalHours) || 0;
                     totalTransferta += Number(entry.transferta) || 0;
                     totalNotturne += Number(entry.notturne) || 0;
                     totalBreakTime += Number(entry.breakTime) || 0; // Add break time to total
                     return `
                         <div class="modal-entry">
                             <span>${formatTime(start)}-${Number(entry.breakTime || 0).toFixed(1).replace('.', ',')}-${formatTime(end)}</span>
                             <span title="${escapeHtml(entry.description || '')}">${escapeHtml(entry.description || '-')}</span>
                             <span>${hoursNet.toFixed(2)}h</span> <!-- Display net hours for the entry -->
                             <div>
                                 <button class="edit-btn" onclick="editEntryFromModal('${dateStr}', '${entry.id}')">
                                 <span class="material-symbols-outlined">edit</span>
                             </button>
                                 <button class="delete-btn" onclick="deleteEntryFromModal('${dateStr}', '${entry.id}')">
                                 <span class="material-symbols-outlined">delete</span>
                             </button>
                             </div>
                         </div>
                     `;
                 }).join('');

                // Display total hours for the day in the summary
                if (daySummary) {
                    const totalHoursElement = daySummary.querySelector('#modalTotalHours');
                    const transfertaHoursElement = daySummary.querySelector('#modalTransferta'); // Correct ID
                    const notturneHoursElement = daySummary.querySelector('#modalNotturne');   // Correct ID

                    if (totalHoursElement) {
                        // Use the summary total derived from entry.totalHours
                        totalHoursElement.textContent = `${totalHoursSummary.toFixed(2)}h`;
                    }
                    if (transfertaHoursElement) {
                        // Verifica se c'è almeno una voce con trasferta
                        const hasTransferta = entries.some(entry =>
                            entry.transferta === true || (typeof entry.transferta === 'number' && entry.transferta > 0)
                        );
                        transfertaHoursElement.textContent = hasTransferta ? 'SI' : '';
                    }
                    if (notturneHoursElement) {
                        notturneHoursElement.textContent = `${totalNotturne.toFixed(1)}h`;   // Use toFixed(1) like elsewhere
                    }
                 daySummary.style.display = 'grid'; // Ensure summary is visible
                }
                 modalHolidayInfo.style.display = 'none'; // Make sure holiday info is hidden
                 addEntryModalBtn.style.display = 'inline-flex'; // Ensure add button is visible
                 freshMarkFerieBtn.style.display = 'inline-flex'; // Ensure absence buttons are visible
                 freshMarkMalattiaBtn.style.display = 'inline-flex';

            } else {
                 // --- No work entries and not a Ferie/Malattia entry ---
                 // Check if it's a standard holiday (like Christmas, etc.)
                 // ... (existing code to check for standard holiday and display it) ...
                  // Keep absence buttons visible
                  // If it is a standard holiday, the holiday name is shown in modalHolidayInfo
                  // If not, the "No entries" message is shown in modalEntries
            }

            // Assicuriamoci che il modale sia visibile e interattivo
            modal.style.display = 'block';
            modal.style.visibility = 'visible';
            modal.style.opacity = '1';
            modal.style.pointerEvents = 'auto';
            modal.classList.add('visible');

            // Aggiungiamo un piccolo ritardo per assicurarci che il modale sia completamente visibile
            setTimeout(() => {
                if (modal.style.display === 'block') {
                    console.log("Modale aperto e visibile");
                    // Forza il repaint del modale
                    modal.offsetHeight;
                }
            }, 100);
        }

         // Function to handle editing directly from the modal
         function editEntryFromModal(dateStr, entryId) {
             console.log(`Modifica richiesta da modale per ${entryId} del ${dateStr}`);
             const modal = document.getElementById('dayModal');
             if(modal) {
                modal.style.display = 'none'; // Close modal first
                modal.style.opacity = '0';
                modal.style.visibility = 'hidden';
                modal.classList.remove('visible');
            }
             editEntry(dateStr, entryId); // Call the main edit function
         }

        function deleteEntryFromModal(dateStr, entryId) {
             console.log(`Eliminazione richiesta da modale per ${entryId} del ${dateStr}`);
             if (confirm(`Sei sicuro di voler eliminare questa voce?`)) {
                 const db = getDb();
                 if (db.entries[dateStr]) {
                     db.entries[dateStr] = db.entries[dateStr].filter(entry => entry.id !== entryId);
                     if (db.entries[dateStr].length === 0) {
                         delete db.entries[dateStr];
                     }
                     saveDb(db);
                     showToast('Voce eliminata.', 'success');
                     openDayModal(dateStr); // Refresh modal content immediately
                     // Reload other views after modal refresh
                     if (typeof loadTimeEntries === 'function') loadTimeEntries();
                     if (typeof loadCalendarData === 'function') loadCalendarData(); // Reload calendar view needed if day state changes
                     if (document.getElementById('monthly-report-section')?.classList.contains('active') && typeof displayMonthlyReport === 'function') {
                          const monthSelect = document.getElementById('exportMonthSelect');
                          if (monthSelect) displayMonthlyReport(monthSelect.value, document.getElementById('monthlyReportContent'));
                     }
                 } else {
                      console.warn(`Nessuna voce trovata per ${dateStr} durante eliminazione da modale.`);
                      showToast("Voce non trovata (potrebbe essere già stata eliminata).", "warning");
                      const modal = document.getElementById('dayModal');
                      if (modal) {
                          modal.style.display = 'none'; // Close modal if entry list was likely wrong
                          modal.style.opacity = '0';
                          modal.style.visibility = 'hidden';
                          modal.classList.remove('visible');
                      }
                 }
             } else {
                  console.log("Eliminazione da modale annullata.");
             }
         }

        // Function to delete Ferie/Malattia entry from the modal
        function deleteFerieMalattieEntryFromModal(dateStr) {
             console.log(`Eliminazione Ferie/Malattia da modale per ${dateStr}`);
             // Define db before using it in confirm message
                 const db = getDb();
             if (confirm(`Sei sicuro di voler eliminare l'assenza (${db.holidays && db.holidays[dateStr]?.type || 'N/D'}) per il ${dateStr}?`)) {
                 // db is already defined here
                 if (db.holidays && db.holidays[dateStr]) {
                     delete db.holidays[dateStr];
                     saveDb(db);
                     showToast('Assenza eliminata.', 'success');
                     openDayModal(dateStr); // Refresh modal content
                     // Also refresh lists and calendar
                     if (typeof loadFerieMalattieEntries === 'function') loadFerieMalattieEntries();
                     if (typeof loadCalendarData === 'function') loadCalendarData();
                      if (document.getElementById('monthly-report-section')?.classList.contains('active') && typeof displayMonthlyReport === 'function') {
                          const monthSelect = document.getElementById('exportMonthSelect');
                          if (monthSelect) displayMonthlyReport(monthSelect.value, document.getElementById('monthlyReportContent'));
                     }
                 } else {
                      // Should not happen due to check above, but handle defensively
                      console.warn(`Assenza per ${dateStr} scomparsa prima dell'eliminazione effettiva.`);
                       showToast("Voce di assenza non trovata (potrebbe essere già stata eliminata).", "warning");
                       loadFerieMalattieEntries();
                 }
             } else {
                 console.log("Eliminazione assenza da modale annullata.");
             }
         }


        // --- Settings Functions ---

        function exportData() {
             console.log("Esportazione dati richiesta...");
            try {
                 const db = getDb();
                 const userName = localStorage.getItem('userName') || 'Utente';
                 const filename = `Ore_${userName}_${new Date().toISOString().split('T')[0]}.json`;

                 // Transform data to the desired format
                 const exportData = {
                     timeEntries: [],
                     ferieMalattieEntries: [],
                     vehicles: db.vehicles || [],
                     userName: userName,
                     darkTheme: db.settings?.darkTheme === true
                 };

                 // Convert entries from nested object to flat array
                 Object.entries(db.entries).forEach(([dateStr, entriesOnDate]) => {
                     entriesOnDate.forEach(entry => {
                         exportData.timeEntries.push({
                             date: dateStr,
                             hours: entry.totalHours,
                             description: entry.description,
                             startTime: entry.startTime,
                             endTime: entry.endTime,
                             breakTime: entry.breakTime,
                             transferta: entry.transferta || 0,
                             notturne: entry.notturne || 0,
                             vehicleId: entry.vehicle || ""
                         });
                     });
                 });

                 // Convert holidays to ferieMalattieEntries
                 const holidayEntries = [];

                 // Group consecutive dates by type
                 const holidaysByType = {};
                 Object.entries(db.holidays).forEach(([dateStr, holiday]) => {
                     const type = holiday.type || "ferie";
                     if (!holidaysByType[type]) {
                         holidaysByType[type] = [];
                     }
                     holidaysByType[type].push({
                         date: dateStr,
                         note: holiday.note || "",
                         id: holiday.id
                     });
                 });

                 // Process each holiday type
                 Object.entries(holidaysByType).forEach(([type, entries]) => {
                     // Sort entries by date
                     entries.sort((a, b) => {
                         const dateA = a.date.split('/').reverse().join('-');
                         const dateB = b.date.split('/').reverse().join('-');
                         return dateA.localeCompare(dateB);
                     });

                     // Process consecutive dates as ranges
                     let i = 0;
                     while (i < entries.length) {
                         const current = entries[i];
                         const currentDate = new Date(current.date.split('/').reverse().join('-'));

                         // Check if there are consecutive dates
                         let j = i + 1;
                         const consecutiveDates = [current.date];
                         let lastDate = currentDate;

                         while (j < entries.length) {
                             const nextDate = new Date(entries[j].date.split('/').reverse().join('-'));
                             const dayDiff = (nextDate - lastDate) / (1000 * 60 * 60 * 24);

                             // Check if dates are consecutive (1 day apart)
                             if (dayDiff === 1 && entries[j].note === current.note) {
                                 consecutiveDates.push(entries[j].date);
                                 lastDate = nextDate;
                                 j++;
                             } else {
                                 break;
                             }
                         }

                         if (consecutiveDates.length > 1) {
                             // Multiple days - create a range entry
                             exportData.ferieMalattieEntries.push({
                                 type: type,
                                 date: `Dal ${consecutiveDates[0]} al ${consecutiveDates[consecutiveDates.length - 1]} (esclusi weekend)`,
                                 isMultipleDays: true,
                                 startDate: consecutiveDates[0],
                                 endDate: consecutiveDates[consecutiveDates.length - 1],
                                 excludeWeekends: true,
                                 specificDates: consecutiveDates,
                                 note: current.note
                             });
                             i = j;
                         } else {
                             // Single day
                             exportData.ferieMalattieEntries.push({
                                 type: type,
                                 date: current.date,
                                 isMultipleDays: false,
                                 startDate: null,
                                 endDate: null,
                                 excludeWeekends: true,
                                 specificDates: [current.date],
                                 note: current.note
                             });
                             i++;
                         }
                     }
                 });

                 const dataStr = JSON.stringify(exportData, null, 2); // Pretty print JSON
                 const dataBlob = new Blob([dataStr], { type: 'application/json;charset=utf-8' });

                 // Use File System Access API if available (more robust)
                 if ('showSaveFilePicker' in window) {
                     window.showSaveFilePicker({
                         suggestedName: filename,
                         types: [{
                             description: 'JSON Files',
                             accept: { 'application/json': ['.json'] },
                         }],
                     }).then(handle => handle.createWritable())
                       .then(writable => {
                           writable.write(dataBlob).then(() => {
                               writable.close();
                               showToast('Dati esportati con successo!', 'success');
                               console.log("Dati esportati con showSaveFilePicker.");
                           });
                       }).catch(err => {
                             if (err.name !== 'AbortError') { // Ignore user cancellation
                                 console.error("Errore showSaveFilePicker:", err);
                                 showToast(`Errore esportazione: ${err.message}`, 'error');
                             } else {
                                 console.log("Esportazione annullata dall'utente.");
                             }
                       });
                 } else {
                     // Fallback using download link
                     const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                     const linkElement = document.createElement('a');
                     linkElement.setAttribute('href', dataUri);
                     linkElement.setAttribute('download', filename);
                     linkElement.style.display = 'none';
                     document.body.appendChild(linkElement);
                     linkElement.click();
                     document.body.removeChild(linkElement);
                     showToast('Download dati avviato.', 'success');
                      console.log("Dati esportati con link download (fallback).");
                 }
            } catch (error) {
                 console.error("Errore catastrofico durante l'esportazione:", error);
                 showToast("Errore grave durante l'esportazione dati.", "error");
            }
        }

         function triggerImport() {
             console.log("Importazione dati richiesta...");
             const fileInput = document.createElement('input');
             fileInput.type = 'file';
             fileInput.accept = '.json,application/json'; // Be explicit
             fileInput.style.display = 'none';

             fileInput.addEventListener('change', handleImportFile, { once: true }); // Use once

             document.body.appendChild(fileInput);
             fileInput.click();
         }

         function handleImportFile(event) {
             console.log("File selezionato per l'importazione.");
             const fileInput = event.target; // Get the input element itself
             const file = fileInput.files[0];

             if (!file) {
                 showToast('Nessun file selezionato.', 'warning');
                 if (fileInput.parentNode) fileInput.parentNode.removeChild(fileInput); // Cleanup
                 return;
             }
             console.log(`File selezionato: ${file.name}, tipo: ${file.type}, dimensione: ${file.size}`);

             // Basic type check
             if (file.type !== 'application/json' && !file.name.toLowerCase().endsWith('.json')) {
                  showToast('Tipo di file non supportato. Seleziona un file .json.', 'error');
                  if (fileInput.parentNode) fileInput.parentNode.removeChild(fileInput); // Cleanup
                  return;
             }


             const reader = new FileReader();
             reader.onload = function(e) {
                 console.log("File letto con successo.");
                 try {
                     const importedText = e.target.result;
                      if (!importedText) {
                          throw new Error("Il file sembra essere vuoto.");
                      }
                     const importedData = JSON.parse(importedText);

                     // Custom format detection and conversion
                     if (importedData.timeEntries) {
                         console.log("Rilevato formato personalizzato con timeEntries.");
                         handleCustomFormatImport(importedData);
                         return;
                     }

                     // --- Comprehensive validation of imported structure ---
                     if (typeof importedData !== 'object' || importedData === null) {
                         throw new Error("Il file JSON non contiene un oggetto valido.");
                     }

                      const expectedKeys = ['entries', 'settings', 'holidays', 'vehicles'];
                      const foundKeys = Object.keys(importedData);
                      const hasExpectedStructure = expectedKeys.some(key => foundKeys.includes(key));

                      if (!hasExpectedStructure) {
                          throw new Error("La struttura del file JSON non è compatibile (mancano 'entries', 'settings', 'holidays' o 'vehicles').");
                      }

                     // Further validation (optional but recommended)
                     if (importedData.entries && typeof importedData.entries !== 'object') throw new Error("La chiave 'entries' non è un oggetto.");
                     if (importedData.settings && typeof importedData.settings !== 'object') throw new Error("La chiave 'settings' non è un oggetto.");
                     if (importedData.holidays && typeof importedData.holidays !== 'object') throw new Error("La chiave 'holidays' non è un oggetto.");
                      if (importedData.vehicles && !Array.isArray(importedData.vehicles)) throw new Error("La chiave 'vehicles' non è un array.");
                      // Could add checks for internal structures too (e.g., format of entries)


                     // --- Confirmation ---
                     if (confirm("Importando questo file sovrascriverai TUTTI i dati attuali (ore, impostazioni, mezzi, assenze). Continuare?")) {
                         console.log("Importazione confermata dall'utente.");
                         // Merge settings smartly? For now, overwrite.
                         const currentDb = getDb(); // Get current structure for reference if needed
                         const mergedDb = {
                             entries: { ...(importedData.entries || {}) },
                             settings: { ...(importedData.settings || {}) },
                             holidays: { ...(importedData.holidays || {}) },
                             vehicles: [ ...(importedData.vehicles || []) ]
                         };

                         saveDb(mergedDb);
                         console.log("Dati importati e salvati in localStorage.");
                         showToast('Dati importati con successo! Ricaricamento...', 'success', 3000);
                         // Reload everything to reflect changes
                         setTimeout(() => window.location.reload(), 1500); // Reload page after import
                     } else {
                          console.log("Importazione annullata dall'utente.");
                          showToast("Importazione annullata.", "info");
                     }
                 } catch (error) {
                     console.error("Errore durante l'analisi o la validazione del JSON importato:", error);
                     showToast(`Errore nell'importazione: ${error.message}`, 'error', 7000);
                 } finally {
                      // Ensure cleanup even on error
                      if (fileInput.parentNode) fileInput.parentNode.removeChild(fileInput);
                 }
             };
             reader.onerror = function() {
                  console.error("Errore FileReader durante la lettura del file.");
                 showToast('Errore nella lettura del file.', 'error');
                 if (fileInput.parentNode) fileInput.parentNode.removeChild(fileInput); // Cleanup
             };
             reader.readAsText(file);
         }

         // Function to generate unique IDs for entries
         function generateId() {
             // Simple UUID v4-like generator that creates a random ID
             return 'id_' + Date.now() + '_' + Math.random().toString(36).substring(2, 11);
         }

         // Funzione globale per calcolare la busta paga per un mese specifico
         function calculatePayForMonth(monthValue) {
             console.log(`Calcolo busta paga per il mese: ${monthValue}`);

             // Verifica che il valore del mese sia valido
             if (!monthValue) {
                 console.warn("Nessun mese selezionato per il calcolo della busta paga");
                 return;
             }

             const db = getDb();

             // Debug: stampa la struttura del database per capire come sono salvati i dati
             console.log("Struttura del database:", JSON.stringify(db, null, 2));

             // Assicuriamoci che le tariffe siano numeri validi
             const rates = {
                 normalHour: parseFloat(db.rates?.normalHour) || 0,
                 nightHour: parseFloat(db.rates?.nightHour) || 0,
                 holidayHour: parseFloat(db.rates?.holidayHour) || 0,
                 transferDay: parseFloat(db.rates?.transferDay) || 0,
                 sickDay: parseFloat(db.rates?.sickDay) || 0,
                 vacationDay: parseFloat(db.rates?.vacationDay) || 0,
                 igpBrescia: parseFloat(db.rates?.igpBrescia) || 0
             };

             console.log("Tariffe utilizzate:", rates);

             // Estrai anno e mese dal valore selezionato (formato: YYYY-MM)
             const [year, month] = monthValue.split('-').map(Number);

             // Inizializza i contatori
             let normalHours = 0;
             let nightHours = 0;
             let holidayHours = 0;
             let transferDays = new Set(); // Usa un Set per contare giorni unici
             let sickDays = 0;
             let vacationDays = 0;
             let igpBresciaDays = new Set(); // Usa un Set per contare giorni unici

             // Calcola il primo e l'ultimo giorno del mese
             const firstDay = new Date(year, month - 1, 1);
             const lastDay = new Date(year, month, 0);

             // Formatta il mese per il confronto (MM/YYYY)
             const monthYearStr = `${month.toString().padStart(2, '0')}/${year}`;

             // Debug
             console.log(`Calcolo per il mese: ${monthYearStr}, giorni: ${lastDay.getDate()}`);

             // Itera su tutti i giorni del mese
             for (let day = 1; day <= lastDay.getDate(); day++) {
                 const currentDate = new Date(year, month - 1, day);
                 const dateStr = formatDate(currentDate);

                 // Verifica che la data sia effettivamente nel mese selezionato
                 const dateParts = dateStr.split('/');
                 const dateMonthYear = `${dateParts[1]}/${dateParts[2]}`;

                 if (dateMonthYear !== monthYearStr) {
                     console.warn(`Data ${dateStr} non appartiene al mese ${monthYearStr}, salto...`);
                     continue;
                 }

                 // Debug
                 if (db.entries && db.entries[dateStr]) {
                     console.log(`Trovate voci per ${dateStr}: ${db.entries[dateStr].length}`);
                 }

                 // Controlla se ci sono voci per questa data
                 if (db.entries && db.entries[dateStr]) {
                     // Debug: stampa tutte le voci per questa data
                     console.log(`Voci per ${dateStr}:`, JSON.stringify(db.entries[dateStr], null, 2));

                     // Itera su tutte le voci della data
                     db.entries[dateStr].forEach(entry => {
                         // Debug
                         console.log(`Voce: ${JSON.stringify(entry)}`);

                         // Calcola le ore normali e notturne
                         if (entry.totalHours && typeof entry.totalHours === 'number' && entry.totalHours > 0) {
                             // Se abbiamo già il totale delle ore, usiamo quello direttamente
                             const totalHours = parseFloat(entry.totalHours);

                             console.log(`Usando ore totali già calcolate: ${totalHours}`);

                             // Controlla se è un giorno festivo
                             console.log(`Controllo se ${dateStr} è festivo, giorno della settimana: ${currentDate.getDay()} (0=domenica, 6=sabato)`);
                             const isHoliday = isHolidayDate(currentDate);
                             console.log(`Risultato controllo festività per ${dateStr}: ${isHoliday}`);

                             if (isHoliday) {
                                 // Se è un giorno festivo, tutte le ore sono festive
                                 holidayHours += totalHours;
                                 console.log(`Aggiunto ${totalHours} ore festive (giorno festivo: ${dateStr})`);
                             } else if (entry.isNightShift || entry.notturne === 'true' || entry.notturne === true) {
                                 // Se è un turno notturno, tutte le ore sono notturne
                                 nightHours += totalHours;
                                 console.log(`Aggiunto ${totalHours} ore notturne (turno notturno)`);
                             } else if (entry.notturne && typeof entry.notturne === 'number' && entry.notturne > 0) {
                                 // Se ci sono ore notturne specificate come numero
                                 const notturneHours = parseFloat(entry.notturne);
                                 nightHours += notturneHours;
                                 normalHours += (totalHours - notturneHours);
                                 console.log(`Aggiunto ${notturneHours} ore notturne e ${totalHours - notturneHours} ore normali`);
                             } else {
                                 // Altrimenti, tutte le ore sono normali
                                 normalHours += totalHours;
                                 console.log(`Aggiunto ${totalHours} ore normali`);
                             }
                         } else if (entry.startTime && entry.endTime) {
                             // Altrimenti, calcoliamo le ore dai tempi di inizio e fine
                             const startTime = parseTimeString(entry.startTime);
                             const endTime = parseTimeString(entry.endTime);

                             if (startTime && endTime) {
                                 // Calcola le ore totali considerando la pausa
                                 let totalHours = calculateHoursBetween(startTime, endTime);

                                 // Sottrai la pausa se presente
                                 if (entry.breakTime && !isNaN(parseFloat(entry.breakTime))) {
                                     totalHours -= parseFloat(entry.breakTime);
                                 }

                                 // Debug
                                 console.log(`Ore calcolate: ${totalHours} (${entry.startTime}-${entry.endTime})`);

                                 // Controlla se è un giorno festivo
                                 console.log(`Controllo se ${dateStr} è festivo, giorno della settimana: ${currentDate.getDay()} (0=domenica, 6=sabato)`);
                                 const isHoliday = isHolidayDate(currentDate);
                                 console.log(`Risultato controllo festività per ${dateStr}: ${isHoliday}`);

                                 if (isHoliday) {
                                     // Se è un giorno festivo, tutte le ore sono festive
                                     holidayHours += totalHours;
                                     console.log(`Aggiunto ${totalHours} ore festive (giorno festivo: ${dateStr})`);
                                 } else if (entry.isNightShift || entry.notturne === 'true' || entry.notturne === true) {
                                     // Se è un turno notturno, tutte le ore sono notturne
                                     nightHours += totalHours;
                                     console.log(`Aggiunto ${totalHours} ore notturne (turno notturno)`);
                                 } else if (entry.notturne && typeof entry.notturne === 'number' && entry.notturne > 0) {
                                     // Se ci sono ore notturne specificate come numero
                                     const notturneHours = parseFloat(entry.notturne);
                                     nightHours += notturneHours;
                                     normalHours += (totalHours - notturneHours);
                                     console.log(`Aggiunto ${notturneHours} ore notturne e ${totalHours - notturneHours} ore normali`);
                                 } else {
                                     // Altrimenti, tutte le ore sono normali
                                     normalHours += totalHours;
                                     console.log(`Aggiunto ${totalHours} ore normali`);
                                 }
                             }
                         }

                         // Controlla se è una trasferta
                         if (entry.isTransfer || entry.transferta === 'true' || entry.transferta === true ||
                             (typeof entry.transferta === 'boolean' && entry.transferta)) {
                             transferDays.add(dateStr); // Aggiungi la data al set per contare giorni unici
                             console.log(`Aggiunto giorno di trasferta: ${dateStr}`);
                         }

                         // Controlla se è IGP Brescia
                         const description = entry.description || entry.note || '';
                         console.log(`Controllo IGP Brescia per ${dateStr}, descrizione: "${description}"`);

                         // Verifica se è IGP Brescia (deve contenere entrambe le parole o la frase esatta)
                         const descLower = description.toLowerCase();
                         if (descLower.includes('igp brescia') ||
                             (descLower.includes('igp') && descLower.includes('brescia'))) {
                             igpBresciaDays.add(dateStr); // Aggiungi la data al set per contare giorni unici
                             console.log(`Aggiunto giorno IGP Brescia: ${dateStr}`);
                         }
                     });
                 }

                 // Controlla se ci sono ferie o malattie per questa data
                 if (db.holidays && db.holidays[dateStr]) {
                     const holiday = db.holidays[dateStr];
                     if (holiday.type === 'ferie') {
                         vacationDays++;
                         console.log(`Aggiunto giorno di ferie: ${dateStr}`);
                     } else if (holiday.type === 'malattia') {
                         sickDays++;
                         console.log(`Aggiunto giorno di malattia: ${dateStr}`);
                     }
                 }
             }

             // Converti i Set in conteggi
             const transferDaysCount = transferDays.size;
             const igpBresciaDaysCount = igpBresciaDays.size;

             // Arrotonda le ore a una cifra decimale (per gestire le mezze ore)
             normalHours = Math.round(normalHours * 10) / 10;
             nightHours = Math.round(nightHours * 10) / 10;
             holidayHours = Math.round(holidayHours * 10) / 10;

             // Riepilogo
             console.log(`Riepilogo: Ore normali: ${normalHours}, Ore notturne: ${nightHours}, Ore festive: ${holidayHours}, Trasferte: ${transferDaysCount}, Malattie: ${sickDays}, Ferie: ${vacationDays}, IGP Brescia: ${igpBresciaDaysCount}`);

             // Assicurati che le tariffe siano numeri
             const normalHourRate = parseFloat(rates.normalHour) || 0;
             const nightHourRate = parseFloat(rates.nightHour) || 0;
             const holidayHourRate = parseFloat(rates.holidayHour) || 0;
             const transferDayRate = parseFloat(rates.transferDay) || 0;
             const sickDayRate = parseFloat(rates.sickDay) || 0;
             const vacationDayRate = parseFloat(rates.vacationDay) || 0;
             const igpBresciaRate = parseFloat(rates.igpBrescia) || 0;

             // Calcola gli importi
             const normalAmount = normalHours * normalHourRate;
             const nightAmount = nightHours * nightHourRate;
             const holidayAmount = holidayHours * holidayHourRate;
             const transferAmount = transferDaysCount * transferDayRate;
             const sickAmount = sickDays * sickDayRate;
             const vacationAmount = vacationDays * vacationDayRate;
             const igpBresciaAmount = igpBresciaDaysCount * igpBresciaRate;
             const totalAmount = normalAmount + nightAmount + holidayAmount + transferAmount + sickAmount + vacationAmount + igpBresciaAmount;

             console.log(`Tariffe: Normale: €${normalHourRate}, Notturno: €${nightHourRate}, Festivo: €${holidayHourRate}, Trasferta: €${transferDayRate}, Malattia: €${sickDayRate}, Ferie: €${vacationDayRate}, IGP Brescia: €${igpBresciaRate}`);
             console.log(`Importi: Normale: €${normalAmount.toFixed(2)}, Notturno: €${nightAmount.toFixed(2)}, Festivo: €${holidayAmount.toFixed(2)}, Trasferta: €${transferAmount.toFixed(2)}, Malattia: €${sickAmount.toFixed(2)}, Ferie: €${vacationAmount.toFixed(2)}, IGP Brescia: €${igpBresciaAmount.toFixed(2)}, Totale: €${totalAmount.toFixed(2)}`);

             // Aggiorna l'interfaccia
             document.getElementById('normalHours').textContent = `${normalHours.toFixed(1)}h`;
             document.getElementById('nightHours').textContent = `${nightHours.toFixed(1)}h`;
             document.getElementById('holidayHours').textContent = `${holidayHours.toFixed(1)}h`;
             document.getElementById('transferDays').textContent = `${transferDaysCount}g`;
             document.getElementById('sickDays').textContent = `${sickDays}g`;
             document.getElementById('vacationDays').textContent = `${vacationDays}g`;
             document.getElementById('igpBresciaDays').textContent = `${igpBresciaDaysCount}g`;

             document.getElementById('normalAmount').textContent = `€${normalAmount.toFixed(2)}`;
             document.getElementById('nightAmount').textContent = `€${nightAmount.toFixed(2)}`;
             document.getElementById('holidayAmount').textContent = `€${holidayAmount.toFixed(2)}`;
             document.getElementById('transferAmount').textContent = `€${transferAmount.toFixed(2)}`;
             document.getElementById('sickAmount').textContent = `€${sickAmount.toFixed(2)}`;
             document.getElementById('vacationAmount').textContent = `€${vacationAmount.toFixed(2)}`;
             document.getElementById('igpBresciaAmount').textContent = `€${igpBresciaAmount.toFixed(2)}`;
             document.getElementById('totalAmount').textContent = `€${totalAmount.toFixed(2)}`;
         }

         // Funzione per formattare una data nel formato DD/MM/YYYY
         function formatDate(date) {
             if (!date) return '';

             // Se è già una stringa nel formato corretto, la restituiamo
             if (typeof date === 'string' && date.match(/^\d{2}\/\d{2}\/\d{4}$/)) {
                 return date;
             }

             // Altrimenti, convertiamo l'oggetto Date in una stringa formattata
             try {
                 const d = new Date(date);
                 if (isNaN(d.getTime())) {
                     console.warn("Data non valida:", date);
                     return '';
                 }

                 const day = String(d.getDate()).padStart(2, '0');
                 const month = String(d.getMonth() + 1).padStart(2, '0');
                 const year = d.getFullYear();

                 return `${day}/${month}/${year}`;
             } catch (error) {
                 console.error("Errore durante la formattazione della data:", error);
                 return '';
             }
         }

         // Funzione per calcolare la data della Pasqua per un dato anno
         function getEasterDate(year) {
             // Algoritmo di Gauss per calcolare la Pasqua
             const a = year % 19;
             const b = Math.floor(year / 100);
             const c = year % 100;
             const d = Math.floor(b / 4);
             const e = b % 4;
             const f = Math.floor((b + 8) / 25);
             const g = Math.floor((b - f + 1) / 3);
             const h = (19 * a + b - d - g + 15) % 30;
             const i = Math.floor(c / 4);
             const k = c % 4;
             const l = (32 + 2 * e + 2 * i - h - k) % 7;
             const m = Math.floor((a + 11 * h + 22 * l) / 451);
             const month = Math.floor((h + l - 7 * m + 114) / 31) - 1; // 0-based (0 = gennaio)
             const day = ((h + l - 7 * m + 114) % 31) + 1;

             return new Date(year, month, day);
         }

         // Funzione per verificare se una data è festiva (sabato, domenica o festività)
         function isHolidayDate(date) {
             // Verifica che la data sia un oggetto Date valido
             if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
                 console.warn("Data non valida per il controllo festività:", date);
                 return false;
             }

             // Verifica se è sabato (6) o domenica (0)
             const dayOfWeek = date.getDay();
             if (dayOfWeek === 0 || dayOfWeek === 6) {
                 console.log(`${formatDate(date)} è un giorno festivo (weekend)`);
                 return true;
             }

             // Verifica se è una festività italiana
             const day = date.getDate();
             const month = date.getMonth() + 1; // getMonth() restituisce 0-11
             const year = date.getFullYear();

             // Festività fisse
             const fixedHolidays = [
                 { day: 1, month: 1 },    // Capodanno
                 { day: 6, month: 1 },    // Epifania
                 { day: 25, month: 4 },   // Festa della Liberazione
                 { day: 1, month: 5 },    // Festa del Lavoro
                 { day: 2, month: 6 },    // Festa della Repubblica
                 { day: 15, month: 8 },   // Ferragosto
                 { day: 1, month: 11 },   // Tutti i Santi
                 { day: 8, month: 12 },   // Immacolata Concezione
                 { day: 25, month: 12 },  // Natale
                 { day: 26, month: 12 }   // Santo Stefano
             ];

             // Verifica festività fisse
             for (const holiday of fixedHolidays) {
                 if (day === holiday.day && month === holiday.month) {
                     console.log(`${formatDate(date)} è un giorno festivo (festività fissa)`);
                     return true;
                 }
             }

             // Calcola la Pasqua (festività mobile)
             const easterDate = getEasterDate(year);
             if (easterDate) {
                 // Pasqua
                 if (date.getTime() === easterDate.getTime()) {
                     console.log(`${formatDate(date)} è un giorno festivo (Pasqua)`);
                     return true;
                 }

                 // Lunedì dell'Angelo (Pasquetta)
                 const easterMonday = new Date(easterDate);
                 easterMonday.setDate(easterDate.getDate() + 1);
                 if (date.getTime() === easterMonday.getTime()) {
                     console.log(`${formatDate(date)} è un giorno festivo (Pasquetta)`);
                     return true;
                 }
             }

             return false;
         }

         // Funzione per calcolare le ore tra due orari
         function calculateHoursBetween(startTime, endTime) {
             console.log(`Calcolo ore tra ${startTime.getHours()}:${startTime.getMinutes()} e ${endTime.getHours()}:${endTime.getMinutes()}`);

             // Se l'ora di fine è minore dell'ora di inizio, assumiamo che sia il giorno successivo
             if (endTime < startTime) {
                 console.log("L'ora di fine è minore dell'ora di inizio, assumiamo che sia il giorno successivo");
                 endTime = new Date(endTime.getTime() + 24 * 60 * 60 * 1000);
             }

             // Calcola la differenza in millisecondi e converti in ore
             const diffMs = endTime - startTime;
             const hours = diffMs / (1000 * 60 * 60);

             console.log(`Ore calcolate: ${hours}`);

             return hours;
         }

         // Funzione per convertire una stringa oraria in un oggetto Date
         function parseTimeString(timeStr) {
             if (!timeStr) return null;

             console.log(`Parsing time string: "${timeStr}"`);

             // Gestisci diversi formati di orario
             let hours, minutes;

             // Formato HH:MM
             if (timeStr.includes(':')) {
                 [hours, minutes] = timeStr.split(':').map(Number);
             }
             // Formato HH.MM
             else if (timeStr.includes('.')) {
                 [hours, minutes] = timeStr.split('.').map(Number);
             }
             // Formato numerico (es. "8" per le 8:00)
             else if (!isNaN(timeStr)) {
                 hours = parseInt(timeStr);
                 minutes = 0;
             }
             // Formato non riconosciuto
             else {
                 console.warn(`Formato orario non riconosciuto: ${timeStr}`);
                 return null;
             }

             if (isNaN(hours) || isNaN(minutes)) {
                 console.warn(`Valori orari non validi: ore=${hours}, minuti=${minutes}`);
                 return null;
             }

             console.log(`Parsed time: ${hours}:${minutes}`);

             const date = new Date();
             date.setHours(hours, minutes, 0, 0);
             return date;
         }

         // Function to handle the custom format provided by the user
         function handleCustomFormatImport(importedData) {
             console.log("Elaborazione formato personalizzato con timeEntries, ferieMalattieEntries e vehicles.");

             try {
                 if (confirm("Importando questo file sovrascriverai TUTTI i dati attuali (ore, impostazioni, mezzi, assenze). Continuare?")) {
                     console.log("Importazione formato personalizzato confermata dall'utente.");

                     // Convert timeEntries to the app's db format
                     const newDb = getDb(); // Start with current structure
                     newDb.entries = {}; // Clear existing entries

                     // Process and convert time entries
                     if (Array.isArray(importedData.timeEntries)) {
                         importedData.timeEntries.forEach(entry => {
                             const dateStr = entry.date; // Already in dd/mm/yyyy format

                             // Create entry with the app's expected structure
                             const newEntry = {
                                 id: generateId(),
                                 lastModified: new Date().getTime(),
                                 startTime: entry.startTime.toString(),
                                 endTime: entry.endTime.toString(),
                                 breakTime: entry.breakTime,
                                 totalHours: entry.hours,
                                 description: entry.description,
                                 transferta: entry.transferta || 0,
                                 notturne: entry.notturne || 0,
                                 vehicle: entry.vehicleId || "" // Use vehicleId if present
                             };

                             // Initialize entry array for this date if needed
                             if (!newDb.entries[dateStr]) {
                                 newDb.entries[dateStr] = [];
                             }

                             // Add the entry to the appropriate date
                             newDb.entries[dateStr].push(newEntry);
                         });
                     }

                     // Process and convert vehicles
                     if (Array.isArray(importedData.vehicles)) {
                         newDb.vehicles = importedData.vehicles.map(vehicle => ({
                             id: vehicle.id,
                             name: vehicle.name,
                             plate: vehicle.plate || "",
                             isDefault: !!vehicle.isDefault
                         }));
                     }

                     // Process and convert ferie/malattie entries
                     if (Array.isArray(importedData.ferieMalattieEntries)) {
                         newDb.holidays = {}; // Clear existing holidays

                         importedData.ferieMalattieEntries.forEach(entry => {
                             if (entry.isMultipleDays && Array.isArray(entry.specificDates)) {
                                 // Process multiple dates
                                 entry.specificDates.forEach(dateStr => {
                                     newDb.holidays[dateStr] = {
                                         type: entry.type, // 'ferie' or 'malattia'
                                         note: entry.note || "",
                                         id: generateId()
                                     };
                                 });
                             } else if (!entry.isMultipleDays && entry.date) {
                                 // Process single date
                                 newDb.holidays[entry.date] = {
                                     type: entry.type,
                                     note: entry.note || "",
                                     id: generateId()
                                 };
                             }
                         });
                     }

                     // Save user settings if present
                     if (importedData.userName) {
                         localStorage.setItem('userName', importedData.userName);
                     }

                     if (importedData.darkTheme !== undefined) {
                         newDb.settings.darkTheme = importedData.darkTheme;
                     }

                     // Save the converted data
                     saveDb(newDb);
                     console.log("Dati in formato personalizzato importati e convertiti con successo.");
                     showToast('Dati importati con successo! Ricaricamento...', 'success', 3000);

                     // Reload to reflect changes
                     setTimeout(() => window.location.reload(), 1500);
                 } else {
                     console.log("Importazione formato personalizzato annullata dall'utente.");
                     showToast("Importazione annullata.", "info");
                 }
             } catch (error) {
                 console.error("Errore durante la conversione del formato personalizzato:", error);
                 showToast(`Errore nell'importazione del formato personalizzato: ${error.message}`, 'error', 7000);
             }
         }

        function clearAllData() {
             console.log("Richiesta cancellazione dati.");
            // Double confirmation
            if (confirm("SEI SICURO di voler cancellare TUTTI i dati inseriti (ore, impostazioni, mezzi, assenze)? Questa azione è IRREVERSIBILE!")) {
                 if (confirm("ULTIMA CONFERMA: Vuoi davvero cancellare TUTTI i dati salvati in questa applicazione?")) {
                    console.log("Cancellazione confermata. Rimuovo dati...");
                    localStorage.removeItem('timeTrackerData');
                    localStorage.removeItem('userName'); // Also clear user name
                    console.log("Dati rimossi da localStorage.");
                    showToast('Tutti i dati sono stati cancellati. Ricaricamento...', 'success', 4000);
                     // Reload page to clear state completely
                     setTimeout(() => window.location.reload(), 1500); // Reload page after import
                 } else {
                      console.log("Seconda conferma cancellazione fallita.");
                      showToast("Cancellazione annullata.", "info");
                 }
            } else {
                 console.log("Prima conferma cancellazione fallita.");
                 showToast("Cancellazione annullata.", "info");
            }
        }


         // --- Vehicle Functions ---
        const MAX_VEHICLES = 10;

        // Helper to get combined and sorted vehicles
        function getAllVehiclesSorted() {
            const db = getDb();
            const userVehicles = db.vehicles || [];
            const defaultVehicleNamesLower = DEFAULT_VEHICLES.map(v => v.name.toLowerCase());
            const uniqueUserVehicles = userVehicles.filter(uv =>
                !defaultVehicleNamesLower.includes(uv.name.toLowerCase())
            );
            const allVehicles = [...DEFAULT_VEHICLES, ...uniqueUserVehicles];
            allVehicles.sort((a, b) => a.name.localeCompare(b.name));
            return allVehicles;
        }

        // Populates the vehicle list in the Settings section
        function populateVehicleSettingsList() {
            console.log("Populating vehicle settings list...");
            // Correct the ID here:
            const vehicleListContainer = document.getElementById('vehiclesList'); // Changed L to l
            if (!vehicleListContainer) {
                // This warning should now only appear if the settings HTML is truly broken
                console.warn("Contenitore lista mezzi (#vehiclesList) non trovato per popolare impostazioni.");
                return; // Exit if the target element isn't present
            }

            const allVehicles = getAllVehiclesSorted();
            vehicleListContainer.innerHTML = ''; // Clear settings list

            if (allVehicles.length === 0) {
                vehicleListContainer.innerHTML = '<p>Nessun mezzo definito.</p>';
                } else {
                allVehicles.forEach(vehicle => {
                    const isDefault = DEFAULT_VEHICLES.some(dv => dv.id === vehicle.id);
                    const listItem = document.createElement('div');
                    listItem.className = 'vehicle-list-item';
                    listItem.innerHTML = `
                        <span>${escapeHtml(vehicle.name)} ${isDefault ? '<span class="default-tag">(Predefinito)</span>' : ''}</span>
                        ${!isDefault ?
                            `<button class="delete-vehicle-btn delete-btn" title="Elimina Mezzo" onclick="deleteVehicle('${vehicle.id}')">
                                 <span class="material-symbols-outlined">delete</span>
                            </button>` :
                            '<span class="delete-placeholder"></span>' // Placeholder
                        }
                         `;
                    vehicleListContainer.appendChild(listItem);
                     });
                 }
            }

        // Populates the vehicle select dropdown in the Home section form
        function populateVehicleDropdown() {
            console.log("Populating vehicle dropdown...");
            const vehicleSelectDropdown = document.getElementById('vehicleSelect');
            if (!vehicleSelectDropdown) {
                 console.warn("Menu selezione mezzo (#vehicleSelect) non trovato per popolare dropdown.");
                 return; // Exit if the target element isn't present
            }

            const allVehicles = getAllVehiclesSorted();
            const currentSelectedValue = vehicleSelectDropdown.value;
            vehicleSelectDropdown.innerHTML = '<option value="">Nessun mezzo</option>'; // Clear and add default option

            allVehicles.forEach(vehicle => {
                     const option = document.createElement('option');
                     option.value = vehicle.id; // Use ID as value
                option.textContent = vehicle.name;
                vehicleSelectDropdown.appendChild(option);
            });

            // Try to reselect the previously selected value
            if (allVehicles.some(v => v.id === currentSelectedValue)) {
               vehicleSelectDropdown.value = currentSelectedValue;
            } else {
                vehicleSelectDropdown.value = ""; // Reset if previous selection is gone
            }
        }

        // Main function to update all vehicle UI parts (call after add/delete)
        function updateVehicleUI() {
             console.log("Updating all vehicle UI elements...");
             populateVehicleSettingsList();
             populateVehicleDropdown();
        }

        function addVehicle() {
             console.log("Tentativo aggiunta mezzo...");
            const vehicleNameInput = document.getElementById('newVehicleName');
            if (!vehicleNameInput) {
                console.error("Input nome nuovo mezzo non trovato.");
                showToast("Errore interno: impossibile trovare l'input.", "error");
                return;
            }
            const vehicleName = vehicleNameInput.value.trim();

            if (!vehicleName) {
                showToast("Inserisci il nome del mezzo.", "error");
                 return;
            }

            // Check if name matches a default vehicle (case-insensitive)
            const isDefaultName = DEFAULT_VEHICLES.some(dv => dv.name.toLowerCase() === vehicleName.toLowerCase());
            if (isDefaultName) {
                showToast(`"${escapeHtml(vehicleName)}" è un mezzo predefinito e non può essere aggiunto.`, "warning");
                return;
            }

            const db = getDb();
            if (!db.vehicles) db.vehicles = [];

            // Check if vehicle with the same name already exists (case-insensitive)
            const existingVehicle = db.vehicles.find(v => v.name.toLowerCase() === vehicleName.toLowerCase());
            if (existingVehicle) {
                showToast(`Un mezzo con nome "${escapeHtml(vehicleName)}" esiste già.`, "warning");
                return;
            }

            const newVehicle = {
                id: `user_${Date.now()}`,
                name: vehicleName
            };
            db.vehicles.push(newVehicle);
            saveDb(db);
            showToast(`Mezzo "${escapeHtml(vehicleName)}" aggiunto.`, 'success');
            console.log("Mezzo aggiunto:", newVehicle);

            vehicleNameInput.value = ''; // Clear input
            updateVehicleUI(); // Call the new update function
        }

        function deleteVehicle(vehicleId) {
            console.log(`Tentativo eliminazione mezzo ID: ${vehicleId}`);

            // Check if it's a default vehicle
            const isDefault = DEFAULT_VEHICLES.some(dv => dv.id === vehicleId);
            if (isDefault) {
                showToast("I mezzi predefiniti non possono essere eliminati.", "error");
                console.warn(`Tentativo bloccato di eliminare mezzo predefinito: ${vehicleId}`);
                 return;
             }

            if (!confirm("Sei sicuro di voler eliminare questo mezzo?")) {
                 console.log("Eliminazione mezzo annullata.");
                return;
            }

            const db = getDb();
            if (!db.vehicles) {
                console.warn("Nessun mezzo utente trovato durante l'eliminazione.");
                 showToast("Mezzo non trovato.", "warning");
                updateVehicleUI(); // Refresh list in case it was already deleted
                 return;
             }

            const initialLength = db.vehicles.length;
                db.vehicles = db.vehicles.filter(v => v.id !== vehicleId);

            if (db.vehicles.length < initialLength) {
                saveDb(db);
                showToast('Mezzo eliminato.', 'success');
                 console.log(`Mezzo eliminato: ${vehicleId}`);
            } else {
                showToast('Mezzo non trovato.', 'warning');
                 console.log(`Mezzo non trovato per eliminazione: ${vehicleId}`);
            }

            updateVehicleUI(); // Refresh lists and dropdown
        }

         function getVehicleNameById(vehicleId) {
             if (!vehicleId) return '';

             // Rimuovi eventuali prefissi v_ o v_default_
             let cleanVehicleId = vehicleId;
             if (vehicleId.startsWith('v_default_')) {
                 cleanVehicleId = 'default_' + vehicleId.substring(10);
             } else if (vehicleId.startsWith('v_')) {
                 cleanVehicleId = vehicleId.substring(2);
             }

             const db = getDb();
             // Ensure vehicles exists and is an array
             const vehicles = Array.isArray(db.vehicles) ? db.vehicles : [];

             // Prima cerca per ID esatto
             let vehicle = vehicles.find(v => v && v.id === cleanVehicleId);

             // Se non trova, prova a cercare per nome (nel caso l'ID sia in realtà un nome)
             if (!vehicle) {
                 vehicle = vehicles.find(v => v && v.name === cleanVehicleId);
             }

             // Se ancora non trova, controlla se è un ID predefinito
             if (!vehicle && cleanVehicleId.startsWith('default_')) {
                 // Cerca nei veicoli predefiniti
                 const defaultVehicle = DEFAULT_VEHICLES.find(v => v.id === cleanVehicleId);
                 if (defaultVehicle) {
                     return defaultVehicle.name;
                 }

                 // Se ancora non trova, estrai il nome dal formato default_nome
                 const defaultName = cleanVehicleId.replace('default_', '').replace(/_/g, ' ');
                 return defaultName.charAt(0).toUpperCase() + defaultName.slice(1);
             }

             return vehicle ? vehicle.name : cleanVehicleId; // Ritorna il nome o l'ID stesso se non trovato
         }

        // --- Monthly Report Functions ---

         function initMonthlyReport() {
            // Aggiorniamo la lista dei file Excel
            if (typeof updateExcelFilesList === 'function') {
                updateExcelFilesList();
            }

            // Inizializziamo il toggle per la sezione dei file Excel
            initExcelFilesToggle();
             const monthSelect = document.getElementById('exportMonthSelect');
             const reportContent = document.getElementById('monthlyReportContent');
             const reportSection = document.getElementById('monthly-report-section');

              // Check if elements exist
              if (!monthSelect || !reportContent || !reportSection) {
                   console.warn("Elementi del report mensile non trovati. Skip inizializzazione.");
                  return;
              }

              // Only fully initialize and display if the section is active
              if (!reportSection.classList.contains('active')) {
                  console.log("Sezione report mensile non attiva. Skip popolamento.");
                 return;
              }

             console.log("Inizializzazione Report Mensile...");

             populateMonthSelector(monthSelect);

             // Remove previous listeners before adding new ones to prevent duplicates
             monthSelect.replaceWith(monthSelect.cloneNode(true)); // Clone to remove listeners
             const exportPdfBtn = document.getElementById('exportMonthlyPdf');
             if (exportPdfBtn) {
                 exportPdfBtn.replaceWith(exportPdfBtn.cloneNode(true));
             }

             const exportTemplateBtn = document.getElementById('exportMonthlyExcelTemplate');
             if (exportTemplateBtn) {
                 exportTemplateBtn.replaceWith(exportTemplateBtn.cloneNode(true));
             }

             // Re-acquire elements after cloning
             const newMonthSelect = document.getElementById('exportMonthSelect');
             const newExportExcelTemplateBtn = document.getElementById('exportMonthlyExcelTemplate');
             const newExportPdfBtn = document.getElementById('exportMonthlyPdf');
             const newReportContent = document.getElementById('monthlyReportContent'); // Content div doesn't need cloning


             newMonthSelect.addEventListener('change', () => {
                 console.log(`Selezione mese cambiata a: ${newMonthSelect.value}`);
                 displayMonthlyReport(newMonthSelect.value, newReportContent);
             });

             newExportExcelTemplateBtn.addEventListener('click', () => {
                 console.log(`Richiesta esportazione Excel da Template per: ${newMonthSelect.value}`);
                 exportMonthlyReportFromTemplate(newMonthSelect.value);
             });

             newExportPdfBtn.addEventListener('click', () => {
                 console.log(`Richiesta esportazione PDF per: ${newMonthSelect.value}`);
                 exportMonthlyReportToPdf(newMonthSelect.value);
             });

             // Display report for the initially selected (current) month
             if (newMonthSelect.value) {
                 displayMonthlyReport(newMonthSelect.value, newReportContent);
             } else {
                  console.log("Nessun mese selezionato inizialmente nel report.");
                 newReportContent.innerHTML = '<p class="monthly-report-empty">Seleziona un mese per visualizzare il riepilogo.</p>';
             }

             // Aggiorniamo la lista dei file Excel
             if (typeof updateExcelFilesList === 'function') {
                 updateExcelFilesList();
             }
         }

         function populateMonthSelector(selectElement) {
              console.log("Popolamento selettore mese...");
             const db = getDb();
             const months = new Set();
             const currentYearMonth = new Date().toISOString().slice(0, 7); // YYYY-MM

             // Add current month even if no data yet
             months.add(currentYearMonth);

             // Collect months from entries
             if (db.entries) {
                Object.keys(db.entries).forEach(dateStr => {
                    try {
                        const date = parseDate(dateStr);
                         if (!isNaN(date.getTime())) { // Check if date is valid
                             const yearMonth = date.toISOString().slice(0, 7);
                             months.add(yearMonth);
                         } else {
                              console.warn(`Data entry non valida trovata: ${dateStr}, skip per selettore mese.`);
                         }
                    } catch (e) { console.warn(`Errore parsing data entry ${dateStr}: ${e}`); }
                });
             }
             // Collect months from holidays/absences
             if (db.holidays) {
                Object.keys(db.holidays).forEach(dateStr => {
                     try {
                        const date = parseDate(dateStr);
                        if (!isNaN(date.getTime())) {
                             const yearMonth = date.toISOString().slice(0, 7);
                             months.add(yearMonth);
                        } else {
                             console.warn(`Data assenza non valida trovata: ${dateStr}, skip per selettore mese.`);
                        }
                    } catch (e) { console.warn(`Errore parsing data assenza ${dateStr}: ${e}`); }
                });
             }


             const sortedMonths = Array.from(months).sort().reverse(); // Most recent first

             selectElement.innerHTML = ''; // Clear existing options
              if (sortedMonths.length === 0) {
                  console.warn("Nessun mese trovato per popolare il selettore.");
                  // Add a placeholder option?
                   const option = document.createElement('option');
                   option.value = "";
                   option.textContent = "-- Nessun Mese --";
                   selectElement.appendChild(option);
                   selectElement.disabled = true;
                  return;
              }

             selectElement.disabled = false;
             sortedMonths.forEach(ym => {
                 const [year, month] = ym.split('-');
                 try {
                    const date = new Date(parseInt(year), parseInt(month) - 1, 1);
                     if (isNaN(date.getTime())) throw new Error("Data non valida creata");
                    const option = document.createElement('option');
                    option.value = ym; // YYYY-MM format
                    option.textContent = date.toLocaleDateString('it-IT', { month: 'long', year: 'numeric' });
                    // Select the current month by default
                    if (ym === currentYearMonth) {
                        option.selected = true;
                    }
                    selectElement.appendChild(option);
                 } catch(e) {
                      console.error(`Errore nella creazione dell'opzione mese per ${ym}: ${e}`);
                 }
             });
             console.log(`Selettore mese popolato con ${sortedMonths.length} opzioni.`);
         }

         function displayMonthlyReport(yearMonth, contentElement) {
              console.log(`Visualizzazione report per: ${yearMonth}`);
              contentElement.innerHTML = ''; // Clear previous content
              if (!yearMonth) {
                  contentElement.innerHTML = '<p class="monthly-report-empty">Seleziona un mese.</p>';
                  return;
              }

              const db = getDb();
              const [year, monthNum] = yearMonth.split('-').map(Number); // Month is 1-based here
              const monthIndex = monthNum - 1; // 0-based for Date object

              // --- Get all data points for the month (entries and holidays) ---
              const monthData = [];
              const daysInMonth = new Date(year, monthNum, 0).getDate();

              for (let day = 1; day <= daysInMonth; day++) {
                  try {
                     const date = new Date(year, monthIndex, day);
                      if (isNaN(date.getTime())) continue; // Skip invalid dates if any occur
                     const dateStr = formatDateForInput(date);
                     const entries = db.entries[dateStr] || [];
                     const holidayInfo = db.holidays[dateStr];

                     // Include day only if it has entries OR is an absence/holiday
                     if (entries.length > 0 || holidayInfo) {
                         monthData.push({
                             date: date,
                             dateStr: dateStr,
                             entries: entries,
                             holidayInfo: holidayInfo
                         });
                     }
                  } catch (e) {
                      console.error(`Errore processando giorno ${day} del mese ${yearMonth}: ${e}`);
                  }
              }

              // Sort data by date ascending
              monthData.sort((a, b) => a.date.getTime() - b.date.getTime());

              if (monthData.length === 0) {
                  contentElement.innerHTML = '<p class="monthly-report-empty">Nessun dato lavorativo o assenza registrata per questo mese.</p>';
                  console.log(`Nessun dato trovato per il report di ${yearMonth}`);
                  return;
              }
              console.log(`Trovati ${monthData.length} giorni con dati per il report di ${yearMonth}`);

             // --- Create Overall Monthly Stats ---
             let monthTotalHours = 0, monthTotalTransferta = 0, monthTotalNotturne = 0, monthTotalBreak = 0, monthWorkDays = 0, monthFerieDays = 0, monthMalattiaDays = 0;
              monthData.forEach(dayData => {
                 if (dayData.holidayInfo) {
                     if (dayData.holidayInfo.type === 'ferie') monthFerieDays++;
                     if (dayData.holidayInfo.type === 'malattia') monthMalattiaDays++;
                 } else if (dayData.entries.length > 0) {
                      let dayHasHours = false;
                      let dayHasTransferta = false;
                      let dayHasDescription = false;
                     dayData.entries.forEach(e => {
                         monthTotalHours += (typeof e.totalHours === 'number' ? e.totalHours : 0);
                         // Verifica se questa voce ha trasferta (sia formato booleano che numerico)
                         if (e.transferta === true || (typeof e.transferta === 'number' && e.transferta > 0)) {
                             dayHasTransferta = true;
                         }
                         monthTotalNotturne += (typeof e.notturne === 'number' ? e.notturne : 0);
                         monthTotalBreak += (typeof e.breakTime === 'number' ? e.breakTime : 0);
                         // Verifica se ci sono ore o descrizione
                         if (typeof e.totalHours === 'number' && e.totalHours > 0) dayHasHours = true;
                         if (e.description && e.description.trim() !== '') dayHasDescription = true;
                     });
                     // Incrementa il contatore dei giorni di trasferta solo una volta per giorno
                     if (dayHasTransferta) {
                         monthTotalTransferta += 1;
                     }
                     // Conta come giorno lavorato se ci sono ore o descrizione
                     if (dayHasHours || dayHasDescription) monthWorkDays++;
                 }
              });

              const statsHtml = `
                 <div class="monthly-report-stats card" style="background-color: var(--md-sys-color-surface-variant); padding: 1rem; margin-bottom: 1.5rem;">
                     <div class="monthly-stat-item" style="background-color: var(--md-sys-color-surface);">
                         <span class="monthly-stat-value">${monthTotalHours.toFixed(1)}h</span>
                         <span class="monthly-stat-label">Ore Lavorate</span>
                     </div>
                      <div class="monthly-stat-item" style="background-color: var(--md-sys-color-surface);">
                         <span class="monthly-stat-value">${monthWorkDays}</span>
                         <span class="monthly-stat-label">Giorni Lavorati</span>
                     </div>

                     <div class="monthly-stat-item" style="background-color: var(--md-sys-color-surface);">
                         <span class="monthly-stat-value">${monthTotalTransferta}</span>
                         <span class="monthly-stat-label">Giorni Trasferta</span>
                     </div>
                     <div class="monthly-stat-item" style="background-color: var(--md-sys-color-surface);">
                         <span class="monthly-stat-value">${monthTotalNotturne.toFixed(1)}h</span>
                         <span class="monthly-stat-label">Ore Notturne</span>
                     </div>
                     ${monthFerieDays > 0 ? `
                      <div class="monthly-stat-item" style="background-color: var(--md-sys-color-tertiary-container); color: var(--md-sys-color-on-tertiary-container);">
                         <span class="monthly-stat-value" style="color: var(--md-sys-color-tertiary);">${monthFerieDays}</span>
                         <span class="monthly-stat-label">Giorni Ferie</span>
                     </div>` : ''}
                     ${monthMalattiaDays > 0 ? `
                      <div class="monthly-stat-item" style="background-color: var(--md-sys-color-secondary-container); color: var(--md-sys-color-on-secondary-container);">
                         <span class="monthly-stat-value" style="color: var(--md-sys-color-secondary);">${monthMalattiaDays}</span>
                         <span class="monthly-stat-label">Giorni Malattia</span>
                     </div>` : ''}
                 </div>
              `;
              contentElement.innerHTML = statsHtml; // Use '=' to replace previous content, starting with stats

              // --- Create Detailed Daily List ---
              const listContainer = document.createElement('div'); // Container for list items
              monthData.forEach(dayData => {
                 const itemDiv = document.createElement('div');
                 itemDiv.className = 'monthly-report-item';

                 const dateDisplay = dayData.date.toLocaleDateString('it-IT', { weekday: 'short', day: 'numeric', month: 'short' });
                 let contentHtml = `<div class="monthly-report-date">${dateDisplay}</div>`;

                 if (dayData.holidayInfo) {
                      // --- Absence Entry ---
                      const typeText = dayData.holidayInfo.type === 'ferie' ? 'Ferie' : 'Malattia';
                      const icon = dayData.holidayInfo.type === 'ferie' ? 'beach_access' : 'sick';
                       itemDiv.classList.add(dayData.holidayInfo.type === 'ferie' ? 'ferie-entry' : 'malattia-entry'); // Add class for styling
                      contentHtml += `
                         <div class="monthly-report-details">
                              <span class="monthly-report-detail" style="background-color: inherit; color: inherit; font-weight: 500;">
                                 <span class="material-symbols-outlined" style="font-size: 1.1em; vertical-align: text-bottom;">${icon}</span>
                                 ${typeText}
                              </span>
                         </div>`;
                       if (dayData.holidayInfo.note) {
                           contentHtml += `<p class="monthly-report-description">${escapeHtml(dayData.holidayInfo.note)}</p>`;
                       }

                 } else if (dayData.entries.length > 0) {
                     // --- Work Entries ---
                     let dayTotalHours = 0, dayTotalTransferta = 0, dayTotalNotturne = 0, dayTotalBreak = 0;
                     let entryDetailsHtml = ''; // Accumulate details for individual entries
                     // Raccogliamo i mezzi utilizzati nel giorno
                     const vehiclesUsed = new Set();

                     dayData.entries.forEach(entry => {
                         dayTotalHours += (typeof entry.totalHours === 'number' ? entry.totalHours : 0);
                         dayTotalTransferta += (typeof entry.transferta === 'number' ? entry.transferta : 0);
                         dayTotalNotturne += (typeof entry.notturne === 'number' ? entry.notturne : 0);
                         dayTotalBreak += (typeof entry.breakTime === 'number' ? entry.breakTime : 0);

                         // Aggiungiamo il mezzo alla lista dei mezzi utilizzati nel giorno
                         const vehicleName = getVehicleNameById(entry.vehicle);
                         if (vehicleName) {
                             vehiclesUsed.add(vehicleName);
                         }

                          // Add individual entry details
                          const entryTime = `${entry.startTime || '?'} - ${entry.endTime || '?'}`;
                          const entryHours = typeof entry.totalHours === 'number' ? ` (${entry.totalHours.toFixed(1)}h)` : '';
                          const entryDesc = entry.description ? `<p class="monthly-report-description" style="margin-top: 0;">${escapeHtml(entry.description)}</p>` : '';

                          // Aggiungiamo le informazioni sul mezzo utilizzato in modo più evidente
                          const entryVehicle = vehicleName ? `<p class="monthly-report-vehicle" style="margin-top: 0.25rem; margin-bottom: 0.25rem; font-weight: 500; color: var(--md-sys-color-primary);"><span class="material-symbols-outlined" style="font-size: 1.1em; vertical-align: text-bottom;">directions_car</span> <strong>Mezzo:</strong> ${escapeHtml(vehicleName)}</p>` : '';

                          // Aggiungiamo le informazioni sulla pausa
                          const breakTime = typeof entry.breakTime === 'number' ? entry.breakTime : 0;
                          const entryBreak = `<p class="monthly-report-break" style="margin-top: 0.25rem; margin-bottom: 0.25rem;"><span class="material-symbols-outlined" style="font-size: 1em; vertical-align: text-bottom;">timer</span> <strong>Pausa:</strong> ${breakTime.toFixed(1)}h</p>`;

                         entryDetailsHtml += `<div style="margin-left: 1rem; margin-top: 0.5rem; padding-left: 0.5rem; border-left: 2px solid var(--md-sys-color-outline-variant); font-size: 0.9em;">
                                                <span style="color: var(--md-sys-color-on-surface-variant);">${entryTime}${entryHours}</span>
                                                ${entryDesc}
                                                ${entryVehicle}
                                                ${entryBreak}
                                            </div>`;
                     });

                      // Summary details for the day
                      contentHtml += `<div class="monthly-report-details">
                                      <span class="monthly-report-detail"><strong>${dayTotalHours.toFixed(1)}h</strong> Totali</span>`;

                      // Aggiungiamo i mezzi utilizzati nel riepilogo giornaliero in modo più evidente
                      if (vehiclesUsed.size > 0) {
                          const vehiclesList = Array.from(vehiclesUsed).join(', ');
                          contentHtml += `<span class="monthly-report-detail" style="background-color: var(--md-sys-color-primary-container); color: var(--md-sys-color-on-primary-container); font-weight: 500; border: 2px solid var(--md-sys-color-primary); padding: 4px 10px;"><span class="material-symbols-outlined" style="font-size: 1.2em; vertical-align: text-bottom;">directions_car</span> ${escapeHtml(vehiclesList)}</span>`;
                      }

                      if (dayTotalBreak > 0) contentHtml += `<span class="monthly-report-detail"><span class="material-symbols-outlined">timer</span> ${dayTotalBreak.toFixed(1)}h Pausa</span>`;
                      if (dayTotalTransferta > 0) contentHtml += `<span class="monthly-report-detail"><span class="material-symbols-outlined">local_shipping</span> ${dayTotalTransferta.toFixed(1)}h Trasf.</span>`;
                      if (dayTotalNotturne > 0) contentHtml += `<span class="monthly-report-detail"><span class="material-symbols-outlined">dark_mode</span> ${dayTotalNotturne.toFixed(1)}h Nott.</span>`;
                      contentHtml += `</div>`;
                      // Append individual entry details
                      contentHtml += entryDetailsHtml;
                 }

                 itemDiv.innerHTML = contentHtml;
                 listContainer.appendChild(itemDiv); // Add to container
                 // Add a blank row AFTER processing all entries/holidays for the current day, IF data was added
                 if (dayData.entries.length > 0 || dayData.holidayInfo) {
                     listContainer.appendChild(document.createElement('div')); // Blank row
                 }
             });
             contentElement.appendChild(listContainer); // Append the whole list at once
             console.log("Report mensile visualizzato.");
         }

        // Funzioni per gestire i file Excel esportati
        function getExcelFiles() {
            try {
                const files = localStorage.getItem('excelFiles');
                return files ? JSON.parse(files) : [];
            } catch (error) {
                console.error("Errore nel recupero dei file Excel:", error);
                return [];
            }
        }

        function saveExcelFiles(files) {
            try {
                // Limitiamo il numero di file salvati a 5 per evitare di riempire il localStorage
                const filesToSave = files.slice(0, 5);

                // Verifica se il file è troppo grande (>1MB)
                const jsonData = JSON.stringify(filesToSave);
                const sizeInMB = (new Blob([jsonData]).size) / (1024 * 1024);

                if (sizeInMB > 1) {
                    console.warn(`File Excel troppo grandi (${sizeInMB.toFixed(2)}MB). Rimozione dei dati binari...`);

                    // Rimuovi i dati binari dai file più vecchi, mantenendoli solo per il più recente
                    const cleanedFiles = filesToSave.map((file, index) => {
                        if (index === 0) return file; // Mantieni i dati solo per il file più recente

                        // Per gli altri file, rimuovi i dati binari ma mantieni i metadati
                        const { data, ...metadata } = file;
                        return {
                            ...metadata,
                            dataRemoved: true
                        };
                    });

                    localStorage.setItem('excelFiles', JSON.stringify(cleanedFiles));
                    showToast("Alcuni dati Excel sono stati compressi per risparmiare spazio", "info");
                } else {
                    localStorage.setItem('excelFiles', jsonData);
                }
            } catch (error) {
                console.error("Errore nel salvataggio dei file Excel:", error);
                showToast("Errore nel salvataggio dei file Excel", "error");

                // In caso di errore, prova a salvare solo i metadati
                try {
                    const metadataOnly = files.slice(0, 5).map(file => {
                        const { data, ...metadata } = file;
                        return {
                            ...metadata,
                            dataRemoved: true
                        };
                    });
                    localStorage.setItem('excelFiles', JSON.stringify(metadataOnly));
                    showToast("Salvati solo i metadati dei file Excel per problemi di spazio", "warning");
                } catch (e) {
                    console.error("Errore anche nel salvataggio dei metadati:", e);
                }
            }
        }

        function saveExcelFileMetadata(fileData) {
            try {
                // Convertiamo il buffer in una stringa base64 per salvarlo nel localStorage
                const base64Data = arrayBufferToBase64(fileData.data);

                // Creiamo l'oggetto con i metadati e i dati del file
                const fileMetadata = {
                    id: fileData.id,
                    name: fileData.name,
                    date: fileData.date,
                    month: fileData.month,
                    year: fileData.year,
                    data: base64Data
                };

                // Recuperiamo i file esistenti
                const files = getExcelFiles();

                // Controlliamo se esiste già un file per lo stesso mese e anno
                const existingFileIndex = files.findIndex(file =>
                    file.month === fileData.month && file.year === fileData.year
                );

                if (existingFileIndex !== -1) {
                    // Se esiste già un file per lo stesso mese e anno, lo sovrascriviamo
                    console.log(`Sovrascrittura file esistente per ${fileData.month} ${fileData.year}`);
                    files[existingFileIndex] = fileMetadata;
                } else {
                    // Altrimenti aggiungiamo il nuovo file all'inizio dell'array
                    files.unshift(fileMetadata);
                }

                // Salviamo l'array aggiornato
                saveExcelFiles(files);

                // Aggiorniamo solo la lista dei file senza reinizializzare il toggle
                updateExcelFilesList();

                console.log("Metadati del file Excel salvati con successo");
            } catch (error) {
                console.error("Errore nel salvataggio dei metadati del file Excel:", error);
                showToast("Errore nel salvataggio dei metadati del file Excel", "error");
            }
        }

        function deleteExcelFile(fileId) {
            try {
                // Recuperiamo i file esistenti
                const files = getExcelFiles();

                // Rimuoviamo il file con l'ID specificato
                const updatedFiles = files.filter(file => file.id !== fileId);

                // Salviamo l'array aggiornato
                saveExcelFiles(updatedFiles);

                // Aggiorniamo solo la lista dei file senza reinizializzare il toggle
                updateExcelFilesList();

                // Se non ci sono più file, chiudiamo la sezione
                if (updatedFiles.length === 0) {
                    const toggleButton = document.getElementById('toggleExcelFiles');
                    const container = document.getElementById('excelFilesContainer');

                    if (toggleButton && container) {
                        toggleButton.setAttribute('aria-expanded', 'false');
                        container.classList.add('collapsed');
                    }
                }

                showToast("File Excel rimosso dalla lista", "success");
                console.log("File Excel rimosso dalla lista:", fileId);
            } catch (error) {
                console.error("Errore nella rimozione del file Excel:", error);
                showToast("Errore nella rimozione del file Excel", "error");
            }
        }

        function downloadExcelFile(fileId) {
            try {
                // Recuperiamo i file esistenti
                const files = getExcelFiles();

                // Troviamo il file con l'ID specificato
                const file = files.find(file => file.id === fileId);

                if (!file) {
                    showToast("File Excel non trovato", "error");
                    return;
                }

                // Convertiamo la stringa base64 in un ArrayBuffer
                const buffer = base64ToArrayBuffer(file.data);

                // Creiamo un Blob dal buffer
                const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });

                // Scarichiamo il file
                saveAs(blob, file.name);

                showToast("Download del file Excel avviato", "success");
                console.log("Download del file Excel avviato:", file.name);
            } catch (error) {
                console.error("Errore nel download del file Excel:", error);
                showToast("Errore nel download del file Excel", "error");
            }
        }

        function initExcelFilesToggle() {
            const toggleButton = document.getElementById('toggleExcelFiles');
            const container = document.getElementById('excelFilesContainer');

            if (!toggleButton || !container) {
                console.error("Elementi per il toggle dei file Excel non trovati");
                return;
            }

            // Rimuoviamo eventuali listener precedenti per evitare duplicati
            // Cloniamo il pulsante per rimuovere tutti gli event listener
            const newToggleButton = toggleButton.cloneNode(true);
            toggleButton.parentNode.replaceChild(newToggleButton, toggleButton);

            // Funzione per gestire il toggle
            function toggleExcelFiles(event) {
                // Preveniamo il comportamento predefinito del pulsante
                event.preventDefault();

                // Otteniamo lo stato corrente
                const isExpanded = newToggleButton.getAttribute('aria-expanded') === 'true';

                // Log per debug
                console.log("Toggle cliccato. Stato attuale:", isExpanded ? "aperto" : "chiuso");

                // Invertiamo lo stato
                const newState = !isExpanded;
                newToggleButton.setAttribute('aria-expanded', newState);

                // Aggiorniamo la classe del container e l'icona
                if (newState) {
                    // Apriamo il container
                    container.classList.remove('collapsed');
                    newToggleButton.querySelector('.toggle-icon').textContent = 'expand_less';
                    console.log("Container aperto");
                } else {
                    // Chiudiamo il container
                    container.classList.add('collapsed');
                    newToggleButton.querySelector('.toggle-icon').textContent = 'expand_more';
                    console.log("Container chiuso");
                }

                return false; // Preveniamo la propagazione dell'evento
            }

            // Aggiungiamo l'event listener per il toggle
            newToggleButton.addEventListener('click', toggleExcelFiles);

            // Impostiamo lo stato iniziale (chiuso)
            newToggleButton.setAttribute('aria-expanded', 'false');
            container.classList.add('collapsed');
            newToggleButton.querySelector('.toggle-icon').textContent = 'expand_more';

            console.log("Toggle dei file Excel inizializzato correttamente");

            // Manteniamo la sezione sempre chiusa di default, indipendentemente dal numero di file
            // L'utente potrà espanderla manualmente quando desidera
        }

        function updateExcelFilesList() {
            try {
                // Recuperiamo l'elemento della lista
                const excelFilesList = document.getElementById('excelFilesList');
                const container = document.getElementById('excelFilesContainer');

                if (!excelFilesList) {
                    console.error("Elemento excelFilesList non trovato");
                    return;
                }

                // Non forziamo più la chiusura del container qui
                // Lasciamo che lo stato del toggle sia gestito dalla funzione initExcelFilesToggle

                // Recuperiamo i file esistenti
                const files = getExcelFiles();

                // Svuotiamo la lista
                excelFilesList.innerHTML = '';

                // Se non ci sono file, mostriamo un messaggio
                if (files.length === 0) {
                    excelFilesList.innerHTML = '<div class="empty-list-message">Nessun file Excel esportato</div>';
                    return;
                }

                // Aggiungiamo i file alla lista
                files.forEach(file => {
                    // Formattiamo la data
                    const fileDate = new Date(file.date);
                    const formattedDate = fileDate.toLocaleDateString('it-IT', {
                        day: '2-digit',
                        month: '2-digit',
                        year: 'numeric',
                        hour: '2-digit',
                        minute: '2-digit'
                    });

                    // Controlliamo se il file è stato aggiornato (confrontando l'ID con il nome del file)
                    // Se l'ID è diverso dalla data nel nome del file, significa che è stato aggiornato
                    const isUpdated = !file.name.includes(file.id);

                    // Creiamo l'elemento della lista
                    const fileItem = document.createElement('div');
                    fileItem.className = 'excel-file-item';
                    fileItem.innerHTML = `
                        <div class="excel-file-info">
                            <span class="excel-file-icon material-symbols-outlined">description</span>
                            <div class="excel-file-details">
                                <span class="excel-file-name">${file.name}</span>
                                <span class="excel-file-date">
                                    ${isUpdated ? 'Aggiornato' : 'Esportato'} il ${formattedDate}
                                </span>
                            </div>
                        </div>
                        <div class="excel-file-actions">
                            <button class="excel-file-download" title="Scarica file">
                                <span class="material-symbols-outlined">download</span>
                            </button>
                            <button class="excel-file-delete" title="Rimuovi dalla lista">
                                <span class="material-symbols-outlined">delete</span>
                            </button>
                        </div>
                    `;

                    // Aggiungiamo gli event listener ai pulsanti
                    const downloadButton = fileItem.querySelector('.excel-file-download');
                    const deleteButton = fileItem.querySelector('.excel-file-delete');

                    downloadButton.addEventListener('click', () => downloadExcelFile(file.id));
                    deleteButton.addEventListener('click', () => {
                        if (confirm(`Sei sicuro di voler rimuovere il file "${file.name}" dalla lista?`)) {
                            deleteExcelFile(file.id);
                        }
                    });

                    // Aggiungiamo l'elemento alla lista
                    excelFilesList.appendChild(fileItem);
                });

                console.log("Lista dei file Excel aggiornata");
            } catch (error) {
                console.error("Errore nell'aggiornamento della lista dei file Excel:", error);
            }
        }

        // Funzione segnaposto per la retrocompatibilità - Promemoria rimossi
        function initReminderSettings() {
            console.log("Funzionalità promemoria disabilitata");

            // Rimuovi eventuali dati di promemoria dal localStorage per liberare spazio
            if (localStorage.getItem('reminderSettings')) {
                localStorage.removeItem('reminderSettings');
                console.log("Dati dei promemoria rimossi dal localStorage");
            }
        }



        // Funzione rimossa - Notifiche non più utilizzate

        // Registrazione del Service Worker per PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js')
                    .then(registration => {
                        console.log('Service Worker registrato con successo:', registration.scope);
                        // Salva il riferimento alla registrazione
                        window.swRegistration = registration;

                        // Verifica se periodicSync è supportato
                        if ('periodicSync' in registration) {
                            // Verifica se l'app è installata (in modalità standalone o fullscreen)
                            const isInstalled = window.matchMedia('(display-mode: standalone)').matches ||
                                               window.matchMedia('(display-mode: fullscreen)').matches;

                            if (!isInstalled) {
                                console.log('L\'app non è installata come PWA. Alcune funzionalità come periodicSync potrebbero non essere disponibili.');
                                // Non mostriamo messaggi all'utente per non disturbarlo
                            }
                        }
                    })
                    .catch(error => {
                        console.error('Errore nella registrazione del Service Worker:', error);
                    });
            });
        }

        // Funzione per ottenere il percorso base per GitHub Pages
        function getBasePath() {
            // Ottieni il percorso base dalla location corrente
            const path = window.location.pathname;
            // Se termina con un file (es. index.html), rimuovilo
            if (path.endsWith('.html')) {
                return path.substring(0, path.lastIndexOf('/') + 1);
            }
            // Se non termina con uno slash, aggiungi uno slash
            if (!path.endsWith('/')) {
                return path + '/';
            }
            return path;
        }





        // Funzioni di utilità per la conversione tra ArrayBuffer e Base64
        function arrayBufferToBase64(buffer) {
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        // Helper function per convertire time string in formato Excel
        function parseTimeToExcel(timeStr) {
            if (!timeStr) return null;

            // Se è già un numero (ore decimali)
            if (!isNaN(timeStr) && timeStr !== "") {
                const hours = parseFloat(timeStr);
                // Converti in minuti per il formato Excel time
                return new Date(1900, 0, 1, Math.floor(hours), Math.round((hours % 1) * 60), 0);
            }

            // Se è nel formato HH:MM
            if (timeStr.includes(':')) {
                const [hours, minutes] = timeStr.split(':').map(Number);
                return new Date(1900, 0, 1, hours, minutes, 0);
            }

            return null;
        }

        // Funzione per esportare da template

        // Funzione per esportare da template
        async function exportMonthlyReportFromTemplate(yearMonth) {
            try {
                console.log(`Iniziando esportazione da template per mese: ${yearMonth}`);
                
                const [yearStr, monthStr] = yearMonth.split('-');
                const year = parseInt(yearStr); // Converti a numero
                const month = parseInt(monthStr); // Converti a numero
                const db = getDb();
                
                console.log(`📊 Database entries:`, db.entries);
                console.log(`📅 Cercando dati per mese: ${year}-${month}`);
                
                // Carica il template
                const response = await fetch('./templates/template.xlsx');
                if (!response.ok) {
                    throw new Error(`Errore nel caricamento del template: ${response.statusText}`);
                }
                
                const arrayBuffer = await response.arrayBuffer();
                
                // Leggi il workbook dal template
                const workbook = new ExcelJS.Workbook();
                await workbook.xlsx.load(arrayBuffer);
                
                const worksheet = workbook.worksheets[0]; // Prendi il primo foglio
                console.log(`📝 Template caricato, foglio: ${worksheet.name}, righe: ${worksheet.rowCount}`);
                
                // Itera tutti i giorni del mese
                const daysInMonth = new Date(year, month, 0).getDate();
                console.log(`📆 Giorni nel mese: ${daysInMonth}`);
                
                // Array per memorizzare dayOfWeek di ogni giorno (index = day numero)
                const dayOfWeekMap = {};
                
                for (let day = 1; day <= daysInMonth; day++) {
                    const dateObj = new Date(year, month - 1, day);
                    
                    // Salva il dayOfWeek per il secondo loop
                    const dayOfWeek = dateObj.getDay();
                    dayOfWeekMap[day] = dayOfWeek;
                    
                    // Formato corretto per cercare nel DB: DD/MM/YYYY
                    const dateStr = `${String(day).padStart(2, '0')}/${String(month).padStart(2, '0')}/${year}`;
                    
                    // Calcola la riga (righe da 6 a 36)
                    const rowIndex = 5 + day; // riga 6 per day 1, riga 7 per day 2, ecc.
                    const row = worksheet.getRow(rowIndex);
                    
                    // --- COLONNA A: Giorno ---
                    const dayName = dateObj.toLocaleDateString('it-IT', { weekday: 'long' });
                    const dayFormatted = dateObj.toLocaleDateString('it-IT', { month: 'long', day: 'numeric', year: 'numeric' });
                    row.getCell(1).value = `${dayName.charAt(0).toUpperCase() + dayName.slice(1)}, ${dayFormatted}`;
                    
                    // 🎨 COLORA SABATI E DOMENICHE di grigio chiaro
                    if (dayOfWeek === 6 || dayOfWeek === 0) {
                        const grayFill = {
                            type: 'pattern',
                            pattern: 'solid',
                            fgColor: { argb: 'FFD9D9D9' }
                        };
                        // Colonne A-H (1-8)
                        for (let col = 1; col <= 8; col++) {
                            row.getCell(col).fill = grayFill;
                        }
                        // Salta I (9), Colonne J-V (10-22)
                        for (let col = 10; col <= 22; col++) {
                            row.getCell(col).fill = grayFill;
                        }
                    }
                    
                    // Recupera i dati per questo giorno
                    const entries = db.entries[dateStr] || [];
                    const holidayInfo = db.holidays ? db.holidays[dateStr] : null;
                    
                    if (entries.length > 0 || holidayInfo) {
                        console.log(`🗓️ ${dateStr}: ${entries.length} entries, holiday: ${holidayInfo?.type || 'none'}`);
                    }
                    
                    // Controlla se è ferie o malattia
                    const isFerie = holidayInfo?.type === 'ferie';
                    const isMalattia = holidayInfo?.type === 'malattia';
                    
                    // --- COLONNA S: Ferie ---
                    if (isFerie) {
                        row.getCell(19).value = 8; // S = 19
                        continue; // Salta agli altri giorni
                    }
                    
                    // --- COLONNA U: Malattia ---
                    if (isMalattia) {
                        row.getCell(21).value = 8; // U = 21
                        continue; // Salta agli altri giorni
                    }
                    
                    // Se non ci sono entry, salta
                    if (entries.length === 0) continue;
                    
                    // Usa la prima entry del giorno
                    const firstEntry = entries[0];
                    
                    // --- COLONNA B: PWS Sede ---
                    const description = (firstEntry.description || '').toLowerCase();
                    const hasPWS = description.includes('pws');
                    const hasUfficio = description.includes('ufficio');
                    if (hasPWS || hasUfficio) {
                        row.getCell(2).value = 'X'; // B = 2
                    }
                    
                    // --- COLONNE C-D: Località Lavori ---
                    const locations = firstEntry.description
                        ? firstEntry.description
                            .split(/[,.\-\/:]+|\n+/)
                            .map(d => d.trim())
                            .filter(d => d.length > 0 && !d.toLowerCase().includes('pws') && !d.toLowerCase().includes('ufficio'))
                        : [];
                    
                    if (locations.length > 0) {
                        row.getCell(3).value = locations[0]; // C = 3
                    }
                    if (locations.length > 1) {
                        row.getCell(4).value = locations.slice(1).join(' -- '); // D = 4
                    }
                    
                    // --- COLONNE E-G: Orari (inizio, pausa, fine) ---
                    if (firstEntry.startTime) {
                        row.getCell(5).value = firstEntry.startTime; // E = 5
                    }
                    if (firstEntry.breakTime) {
                        row.getCell(6).value = firstEntry.breakTime; // F = 6
                    }
                    if (firstEntry.endTime) {
                        row.getCell(7).value = firstEntry.endTime; // G = 7
                    }
                    
                    // Calcola le ore totali
                    let totalHours = firstEntry.totalHours || 0;
                    
                    // Usa il dayOfWeek già salvato (no redichiaro!)
                    const isSaturday = dayOfWeek === 6;
                    const isSunday = dayOfWeek === 0;
                    const isHoliday = isHolidayDate(dateObj);
                    
                    const hasNightHours = firstEntry.notturne && firstEntry.notturne > 0;
                    const nightHours = hasNightHours ? parseFloat(firstEntry.notturne) : 0;
                    const hasTransfer = firstEntry.transferta === true || firstEntry.transferta === 'true';
                    const hasIGPBrescia = hasNightHours && description.includes('igp brescia');
                    
                    // --- LOGICA DISTRIBUZIONE ORE ---
                    if (isFerie || isMalattia) {
                        // Già gestito sopra
                    } else if (hasNightHours) {
                        // Se ha ore notturne, vanno nelle colonne M/N/O/P (non in H)
                        if (hasIGPBrescia) {
                            row.getCell(16).value = nightHours; // P = 16
                        } else if (isSaturday) {
                            row.getCell(14).value = nightHours; // N = 14
                        } else if (isSunday || isHoliday) {
                            row.getCell(15).value = nightHours; // O = 15
                        } else {
                            row.getCell(13).value = nightHours; // M = 13
                        }
                    } else if (isSaturday) {
                        // Sabato: ore in colonna K (non in H)
                        row.getCell(11).value = totalHours; // K = 11
                    } else if (isSunday || isHoliday) {
                        // Domenica/Festivo: ore in colonna L (non in H)
                        row.getCell(12).value = totalHours; // L = 12
                    } else {
                        // Feriale ordinario: dividi tra ore ordinarie (H) e straordinari (J)
                        const ordinaryHours = Math.min(totalHours, 8);
                        const overtimeHours = Math.max(0, totalHours - 8);
                        
                        row.getCell(8).value = ordinaryHours; // H = 8
                        if (overtimeHours > 0) {
                            row.getCell(10).value = overtimeHours; // J = 10
                        }
                    }
                    
                    // --- COLONNA Q: Trasferta ---
                    if (hasTransfer) {
                        row.getCell(17).value = 'X'; // Q = 17
                    }
                }
                
                // Genera il buffer e scarica
                const buffer = await workbook.xlsx.writeBuffer();
                const blob = new Blob([buffer], {
                    type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
                });
                
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `FAC_SIMILE_ORE_${yearMonth}_DA_TEMPLATE.xlsx`;
                link.click();
                URL.revokeObjectURL(link.href);
                
                showToast('Report Excel da Template generato con successo!', 'success');
                console.log(`Esportazione da template completata: FAC_SIMILE_ORE_${yearMonth}_DA_TEMPLATE.xlsx`);
                
            } catch (error) {
                console.error('Errore durante la generazione del report da template:', error);
                showToast('Errore durante la generazione del report da template: ' + error.message, 'error');
            }
        }

        // --- Cash Functions ---

        function initCashSection() {
            console.log("Inizializzazione sezione Cash...");

            // Elementi DOM
            const cashMonthSelect = document.getElementById('cashMonthSelect');
            const saveRatesBtn = document.getElementById('saveRatesBtn');

            // Input tariffe
            const normalHourRateInput = document.getElementById('normalHourRate');
            const nightHourRateInput = document.getElementById('nightHourRate');
            const holidayHourRateInput = document.getElementById('holidayHourRate');
            const transferDayRateInput = document.getElementById('transferDayRate');
            const sickDayRateInput = document.getElementById('sickDayRate');
            const vacationDayRateInput = document.getElementById('vacationDayRate');
            const igpBresciaRateInput = document.getElementById('igpBresciaRate');

            // Verifica che tutti gli elementi esistano
            if (!cashMonthSelect || !saveRatesBtn || !normalHourRateInput || !nightHourRateInput ||
                !holidayHourRateInput || !transferDayRateInput || !sickDayRateInput ||
                !vacationDayRateInput || !igpBresciaRateInput) {
                console.warn("Elementi Cash mancanti. Skip inizializzazione.");
                return;
            }

            // Popola il selettore dei mesi
            populateMonthSelect(cashMonthSelect);

            // Carica le tariffe salvate
            loadSavedRates();

            // Calcola la busta paga per il mese selezionato (se c'è un valore)
            if (cashMonthSelect.value) {
                calculatePayForMonth(cashMonthSelect.value);
            } else {
                // Se non ci sono mesi disponibili, mostra un messaggio
                showToast("Non ci sono dati disponibili per calcolare la busta paga", "info");
            }

            // Event listeners
            cashMonthSelect.addEventListener('change', function() {
                calculatePayForMonth(this.value);
            });

            saveRatesBtn.addEventListener('click', function() {
                saveRates();
                calculatePayForMonth(cashMonthSelect.value);
                showToast('Tariffe salvate con successo', 'success');
            });

            // Funzione per popolare il selettore dei mesi
            function populateMonthSelect(selectElement) {
                if (!selectElement) return;

                // Svuota il selettore
                selectElement.innerHTML = '';

                const db = getDb();
                const months = getAvailableMonths(db);

                console.log(`Mesi disponibili: ${months.length}`);

                if (months.length === 0) {
                    // Se non ci sono mesi disponibili, aggiungi un'opzione vuota
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = '-- Nessun mese disponibile --';
                    selectElement.appendChild(option);
                    return;
                }

                // Aggiungi un'opzione vuota all'inizio
                const emptyOption = document.createElement('option');
                emptyOption.value = '';
                emptyOption.textContent = '-- Seleziona un mese --';
                selectElement.appendChild(emptyOption);

                // Aggiungi le opzioni al selettore
                months.forEach(month => {
                    const option = document.createElement('option');
                    option.value = month.value;
                    option.textContent = month.label;
                    selectElement.appendChild(option);
                });

                // Seleziona il mese più recente (il primo nell'elenco, dato che sono ordinati in ordine decrescente)
                if (selectElement.options.length > 1) {
                    selectElement.selectedIndex = 1; // Seleziona il primo mese (dopo l'opzione vuota)
                }

                console.log(`Mese selezionato: ${selectElement.value}`);
            }

            // Funzione per caricare le tariffe salvate
            function loadSavedRates() {
                const db = getDb();

                console.log("Database prima del caricamento delle tariffe:", JSON.stringify(db, null, 2));

                // Se non esiste la sezione rates nel db, la creiamo
                if (!db.rates) {
                    db.rates = {
                        normalHour: 0,
                        nightHour: 0,
                        holidayHour: 0,
                        transferDay: 0,
                        sickDay: 0,
                        vacationDay: 0,
                        igpBrescia: 0
                    };
                    saveDb(db);
                }

                // Assicuriamoci che tutte le proprietà esistano e siano numeri validi
                const rates = {
                    normalHour: parseFloat(db.rates.normalHour) || 0,
                    nightHour: parseFloat(db.rates.nightHour) || 0,
                    holidayHour: parseFloat(db.rates.holidayHour) || 0,
                    transferDay: parseFloat(db.rates.transferDay) || 0,
                    sickDay: parseFloat(db.rates.sickDay) || 0,
                    vacationDay: parseFloat(db.rates.vacationDay) || 0,
                    igpBrescia: parseFloat(db.rates.igpBrescia) || 0
                };

                // Aggiorniamo il db con i valori convertiti
                if (!db.rates) {
                    db.rates = {};
                }

                // Assegniamo ogni proprietà individualmente per assicurarci che vengano salvate correttamente
                db.rates.normalHour = rates.normalHour;
                db.rates.nightHour = rates.nightHour;
                db.rates.holidayHour = rates.holidayHour;
                db.rates.transferDay = rates.transferDay;
                db.rates.sickDay = rates.sickDay;
                db.rates.vacationDay = rates.vacationDay;
                db.rates.igpBrescia = rates.igpBrescia;

                // Salviamo il database
                saveDb(db);

                // Impostiamo i valori nei campi input
                normalHourRateInput.value = rates.normalHour;
                nightHourRateInput.value = rates.nightHour;
                holidayHourRateInput.value = rates.holidayHour;
                transferDayRateInput.value = rates.transferDay;
                sickDayRateInput.value = rates.sickDay;
                vacationDayRateInput.value = rates.vacationDay;
                igpBresciaRateInput.value = rates.igpBrescia;

                console.log("Tariffe caricate:", rates);
            }

            // Funzione per salvare le tariffe
            function saveRates() {
                const db = getDb();

                // Aggiorniamo le tariffe nel db, assicurandoci che siano numeri validi
                const rates = {
                    normalHour: parseFloat(normalHourRateInput.value) || 0,
                    nightHour: parseFloat(nightHourRateInput.value) || 0,
                    holidayHour: parseFloat(holidayHourRateInput.value) || 0,
                    transferDay: parseFloat(transferDayRateInput.value) || 0,
                    sickDay: parseFloat(sickDayRateInput.value) || 0,
                    vacationDay: parseFloat(vacationDayRateInput.value) || 0,
                    igpBrescia: parseFloat(igpBresciaRateInput.value) || 0
                };

                // Aggiorniamo i valori nei campi input per mostrare i valori effettivamente salvati
                normalHourRateInput.value = rates.normalHour;
                nightHourRateInput.value = rates.nightHour;
                holidayHourRateInput.value = rates.holidayHour;
                transferDayRateInput.value = rates.transferDay;
                sickDayRateInput.value = rates.sickDay;
                vacationDayRateInput.value = rates.vacationDay;
                igpBresciaRateInput.value = rates.igpBrescia;

                // Salviamo le tariffe nel db
                if (!db.rates) {
                    db.rates = {};
                }

                // Assegniamo ogni proprietà individualmente per assicurarci che vengano salvate correttamente
                db.rates.normalHour = rates.normalHour;
                db.rates.nightHour = rates.nightHour;
                db.rates.holidayHour = rates.holidayHour;
                db.rates.transferDay = rates.transferDay;
                db.rates.sickDay = rates.sickDay;
                db.rates.vacationDay = rates.vacationDay;
                db.rates.igpBrescia = rates.igpBrescia;

                // Salviamo il database
                saveDb(db);

                // Verifichiamo che le tariffe siano state salvate correttamente
                const dbAfterSave = getDb();
                console.log("Tariffe salvate:", dbAfterSave.rates);

                // Ricalcoliamo la busta paga con le nuove tariffe
                if (cashMonthSelect.value) {
                    console.log("Ricalcolo busta paga dopo il salvataggio delle tariffe");
                    calculatePayForMonth(cashMonthSelect.value);
                }
            }

            // Utilizziamo la funzione globale calculatePayForMonth
            // che è stata definita a livello globale per poter essere utilizzata anche da altre parti dell'applicazione
        }

        // --- Ferie/Malattie Functions ---

        function initFerieMalattieSection() {
            // Get elements needed for initialization
            const multipleDaysCheckbox = document.getElementById('multipleDays');
            const singleDateGroup = document.getElementById('singleDateGroup');
            const dateRangeGroup = document.getElementById('dateRangeGroup');
            const saveBtn = document.getElementById('saveFerieMalattie');
            const section = document.getElementById('ferie-malattie-section');

            if (!multipleDaysCheckbox || !singleDateGroup || !dateRangeGroup || !saveBtn || !section) {
                console.warn("Elementi Ferie/Malattie mancanti. Skip inizializzazione listener.");
                return;
            }

             // Only init fully if section is active
            if (!section.classList.contains('active')) {
                 console.log("Sezione Ferie/Malattie non attiva. Skip inizializzazione completa.");
                 return;
            }
             console.log("Inizializzazione Sezione Ferie/Malattie...");

             // Initialize datepickers specifically for this section
             initFerieMalattieDatepickers();

             // Use replaceWith clone to ensure listeners are fresh if section is revisited
             const freshCheckbox = multipleDaysCheckbox.cloneNode(true);
             multipleDaysCheckbox.parentNode.replaceChild(freshCheckbox, multipleDaysCheckbox);
             freshCheckbox.addEventListener('change', () => {
                singleDateGroup.style.display = freshCheckbox.checked ? 'none' : 'block';
                dateRangeGroup.style.display = freshCheckbox.checked ? 'block' : 'none';
                // Reset dates when toggling
                 if (typeof flatpickr !== 'undefined') {
                    document.querySelectorAll('.datepicker-ferie').forEach(input => {
                        if(input._flatpickr) input._flatpickr.clear();
                    });
                 } else {
                      document.querySelectorAll('.datepicker-ferie').forEach(input => input.value = '');
                 }
            });

            // Initial state based on checkbox (might be pre-checked if navigating back)
             singleDateGroup.style.display = freshCheckbox.checked ? 'none' : 'block';
             dateRangeGroup.style.display = freshCheckbox.checked ? 'block' : 'none';


             const freshSaveBtn = saveBtn.cloneNode(true);
             saveBtn.parentNode.replaceChild(freshSaveBtn, saveBtn);
             freshSaveBtn.addEventListener('click', saveFerieMalattieEntry);


             // Initial load of entries list
             loadFerieMalattieEntries();
        }

        function initFerieMalattieDatepickers() {
            // Rileva iOS per gestione speciale
const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
if (isIOS) {
    // Aggiungi un elemento invisibile per prevenire problemi con la tastiera iOS
    const keyboardFix = document.createElement('input');
    keyboardFix.className = 'ios-keyboard-fix';
    keyboardFix.type = 'text';
    document.body.appendChild(keyboardFix);
}

             // Ensure flatpickr is loaded
             if (typeof flatpickr !== 'function') {
                 console.error("Flatpickr non caricato. Impossibile inizializzare datepicker Ferie/Malattie.");
                 return;
             }

             const commonOptions = {
                 dateFormat: "d/m/Y",
                 locale: "it",
                 allowInput: true, // Allow manual input
                 appendTo: document.body,
                 disableMobile: true, // Use styled picker
                 errorHandler: (error) => { // Handle flatpickr errors
                     console.error("Errore Flatpickr (Ferie/Malattie):", error);
                     showToast(`Errore calendario: ${error.message}`, "error");
                 }
             };

             // Function to initialize or re-initialize a picker
             const setupPicker = (selector) => {
                 const el = document.querySelector(selector);
                 if (!el) {
                      console.warn(`Elemento datepicker non trovato: ${selector}`);
                      return;
                 }
                 // Destroy previous instance if it exists
                 if (el._flatpickr) {
                     try { el._flatpickr.destroy(); } catch(e) { console.warn(`Errore distruggendo istanza ${selector}: ${e}`); }
                 }
                 // Initialize new instance
                 flatpickr(el, commonOptions);
             };


             // Initialize pickers
             setupPicker('#ferieMalattieDate');
             setupPicker('#ferieMalattieStartDate');
             setupPicker('#ferieMalattieEndDate');

              console.log("Datepicker Ferie/Malattie inizializzati.");
         }

        function saveFerieMalattieEntry() {
             console.log("Tentativo salvataggio Ferie/Malattia...");
            const db = getDb();
            const typeSelect = document.getElementById('ferieMalattieType');
            const multipleDaysCheckbox = document.getElementById('multipleDays');
            const singleDateInput = document.getElementById('ferieMalattieDate');
            const startDateInput = document.getElementById('ferieMalattieStartDate');
            const endDateInput = document.getElementById('ferieMalattieEndDate');
            const noteInput = document.getElementById('ferieMalattieNote');

             // Validate elements exist
             if (!typeSelect || !multipleDaysCheckbox || !singleDateInput || !startDateInput || !endDateInput || !noteInput) {
                 console.error("Elementi form Ferie/Malattie mancanti.");
                  showToast("Errore interno: Elementi form mancanti.", "error");
                 return;
             }

            const type = typeSelect.value;
            const isMultiple = multipleDaysCheckbox.checked;
            const note = noteInput.value.trim();

            let datesToAdd = [];
            let errorOccurred = false;

            if (isMultiple) {
                // --- Multiple Days ---
                const startDateStr = startDateInput.value;
                const endDateStr = endDateInput.value;
                if (!startDateStr || !endDateStr) {
                    showToast("Seleziona le date di inizio e fine.", "error");
                    return;
                }
                const startDate = parseDate(startDateStr);
                const endDate = parseDate(endDateStr);
                if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                    showToast("Date di inizio o fine non valide.", "error");
                    return;
                }
                if (endDate < startDate) {
                    showToast("La data di fine non può essere precedente alla data di inizio.", "error");
                    return;
                }

                 // Limit range to prevent accidental large additions? (e.g., 90 days)
                 const maxRangeDays = 90;
                 const diffTime = Math.abs(endDate - startDate);
                 const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1; // +1 to include start date
                 if (diffDays > maxRangeDays) {
                     showToast(`L'intervallo selezionato (${diffDays} giorni) è troppo lungo (max ${maxRangeDays}).`, "error");
                     return;
                 }


                // Generate all dates in the range, skipping weekends
                console.log(`Salvataggio ${type} da ${startDateStr} a ${endDateStr} (esclusi weekend)`);
                let currentDate = new Date(startDate);
                let skippedWeekendCount = 0;
                while (currentDate <= endDate) {
                     if (isNaN(currentDate.getTime())) { // Safety check inside loop
                          console.error("Data non valida generata nel ciclo range:", currentDate);
                          errorOccurred = true;
                          break;
                     }

                    const dayOfWeek = currentDate.getDay(); // 0 = Sunday, 6 = Saturday
                    if (dayOfWeek === 0 || dayOfWeek === 6) {
                        // Skip weekends
                        console.log(`Skipping weekend: ${formatDateForInput(currentDate)}`);
                        skippedWeekendCount++;
                    } else {
                        // Add non-weekend days
                    datesToAdd.push(formatDateForInput(currentDate));
                    }

                    // Move to the next day
                    currentDate.setDate(currentDate.getDate() + 1);
                }
                if (skippedWeekendCount > 0) {
                    console.log(`Skipped ${skippedWeekendCount} weekend days.`);
                    // Optionally show a message to the user about skipped weekends?
                    // showToast(`${skippedWeekendCount} giorni di weekend sono stati esclusi.`, 'info');
                }

            } else {
                // --- Single Day ---
                const singleDateStr = singleDateInput.value;
                if (!singleDateStr) {
                    showToast("Seleziona una data.", "error");
                    return;
                }
                const singleDate = parseDate(singleDateStr);
                 if (isNaN(singleDate.getTime())) {
                    showToast("Data selezionata non valida.", "error");
                    return;
                }
                 console.log(`Salvataggio ${type} per ${singleDateStr}`);
                datesToAdd.push(singleDateStr);
            }

             if (errorOccurred) {
                 showToast("Errore nella generazione delle date. Salvataggio annullato.", "error");
                 return;
             }
            if (datesToAdd.length === 0) {
                 showToast("Nessuna data valida da salvare.", "warning");
                 return;
            }

            if (!db.holidays) db.holidays = {};

            let conflicts = [];
            let addedCount = 0;
            datesToAdd.forEach(dateStr => {
                 // Check if there's already a work entry - confirm overwrite
                 if (db.entries[dateStr] && db.entries[dateStr].length > 0) {
                     conflicts.push(dateStr);
                 } else if (db.holidays[dateStr] && db.holidays[dateStr].type !== type) {
                     // Allow overwriting same type, but warn if changing type (e.g., ferie -> malattia)
                     conflicts.push(dateStr);
                 } else {
                     // Add or overwrite absence
                      db.holidays[dateStr] = { type: type, note: note };
                      addedCount++;
                 }
            });

            // Handle conflicts
             if (conflicts.length > 0) {
                 const conflictMsg = `Attenzione: I seguenti giorni hanno già voci di lavoro o un diverso tipo di assenza: ${conflicts.join(', ')}. Vuoi sovrascrivere e impostarli come ${type}? Le ore lavorate verranno ignorate nei totali.`;
                 if (confirm(conflictMsg)) {
                      console.log("Conflitti confermati dall'utente, sovrascrittura...");
                     conflicts.forEach(dateStr => {
                         db.holidays[dateStr] = { type: type, note: note };
                         // Optionally delete work entries for this day?
                         // if (db.entries[dateStr]) delete db.entries[dateStr];
                         addedCount++;
                     });
                 } else {
                      showToast("Salvataggio parziale o annullato a causa di conflitti.", "info");
                 }
             }


            if (addedCount > 0) {
                saveDb(db);
                const typeText = type === 'ferie' ? (addedCount > 1 ? 'Ferie salvate' : 'Ferie salvata') : (addedCount > 1 ? 'Malattie salvate' : 'Malattia salvata');
                showToast(`${typeText} per ${addedCount} giorn${addedCount > 1 ? 'i' : 'o'}.`, 'success');
                console.log(`Salvat* ${addedCount} giorni come ${type}.`);

                // Reload relevant views
                if (typeof loadFerieMalattieEntries === 'function') loadFerieMalattieEntries();
                 if (document.getElementById('calendar-section')?.classList.contains('active') && typeof loadCalendarData === 'function') loadCalendarData();
                 if (document.getElementById('monthly-report-section')?.classList.contains('active') && typeof displayMonthlyReport === 'function') {
                      const monthSelect = document.getElementById('exportMonthSelect');
                      if (monthSelect) displayMonthlyReport(monthSelect.value, document.getElementById('monthlyReportContent'));
                 }

                 // Reset form fields only if something was actually saved
                 multipleDaysCheckbox.checked = false;
                 if (singleDateInput._flatpickr) singleDateInput._flatpickr.clear(); else singleDateInput.value = '';
                 if (startDateInput._flatpickr) startDateInput._flatpickr.clear(); else startDateInput.value = '';
                 if (endDateInput._flatpickr) endDateInput._flatpickr.clear(); else endDateInput.value = '';
                 noteInput.value = '';
                 // Trigger checkbox change to reset visibility
                 const event = new Event('change');
                 multipleDaysCheckbox.dispatchEvent(event);

            } else if (conflicts.length > 0 && addedCount === 0) {
                 console.log("Nessuna voce aggiunta a causa di conflitti non risolti.");
            } else {
                 console.log("Nessuna voce da aggiungere o sovrascrivere.");
                 // No toast needed if nothing changed
            }


        }

        function loadFerieMalattieEntries() {
            const entriesContainer = document.getElementById('ferieMalattieEntries');
            if (!entriesContainer) {
                console.warn("Contenitore lista Ferie/Malattie non trovato.");
                return;
            }
            console.log("Caricamento lista Ferie/Malattie...");
            const db = getDb();
            entriesContainer.innerHTML = ''; // Clear list

            const allHolidayEntries = Object.entries(db.holidays || {})
                .map(([dateStr, info]) => {
                    // Basic validation of the entry structure
                    if (typeof info !== 'object' || !info.type) {
                        console.warn(`Voce assenza non valida per ${dateStr}:`, info);
                        return null; // Skip invalid entries
                    }
                    return { dateStr, ...info };
                })
                .filter(entry => entry !== null) // Remove null entries
                .sort((a, b) => parseDate(b.dateStr).getTime() - parseDate(a.dateStr).getTime()); // Sort descending by date

            if (allHolidayEntries.length === 0) {
                entriesContainer.innerHTML = '<p style="text-align: center; color: var(--md-sys-color-on-surface-variant); padding: 1rem;">Nessuna voce di ferie o malattia inserita.</p>';
                console.log("Nessuna voce Ferie/Malattie trovata.");
                return;
            }

            console.log(`Visualizzazione ${allHolidayEntries.length} voci Ferie/Malattie.`);
            allHolidayEntries.forEach(entry => {
                const div = document.createElement('div');
                div.className = 'ferie-malattie-entry';
                const date = parseDate(entry.dateStr);
                if (isNaN(date.getTime())) {
                    console.warn(`Data non valida ${entry.dateStr} nella lista assenze, skip.`);
                    return; // Skip if date is invalid
                }
                const typeText = entry.type === 'ferie' ? 'Ferie' : 'Malattia';
                const icon = entry.type === 'ferie' ? 'beach_access' : 'sick';

                div.innerHTML = `
                    <div class="ferie-malattie-info">
                        <div class="ferie-malattie-header">
                            <span class="ferie-malattie-type">
                                <span class="material-symbols-outlined">${icon}</span>
                                ${typeText}
                            </span>
                            <span class="ferie-malattie-date">${date.toLocaleDateString('it-IT', { day: '2-digit', month: '2-digit', year: 'numeric' })}</span>
                        </div>
                        ${entry.note ? `<p class="ferie-malattie-note">${escapeHtml(entry.note)}</p>` : ''}
                    </div>
                    <div class="ferie-malattie-actions">
                        <button class="delete-ferie-btn delete-btn" title="Elimina Assenza" onclick="deleteFerieMalattieEntry('${entry.dateStr}')">
                            <span class="material-symbols-outlined">delete</span>
                        </button>
                    </div>
                `;
                entriesContainer.appendChild(div);
            });
        }

        function deleteFerieMalattieEntry(dateStr) {
            console.log(`Richiesta eliminazione assenza per ${dateStr}`);
            const db = getDb();
            const holidayInfo = db.holidays ? db.holidays[dateStr] : null;

            if (!holidayInfo) {
                console.warn(`Assenza non trovata per ${dateStr} per l'eliminazione.`);
                showToast("Voce di assenza non trovata.", "warning");
                loadFerieMalattieEntries(); // Refresh list
                return;
            }

            const typeText = holidayInfo.type === 'ferie' ? 'Ferie' : 'Malattia';
            if (confirm(`Sei sicuro di voler eliminare la voce di ${typeText} per il ${dateStr}?`)) {
                if (db.holidays && db.holidays[dateStr]) { // Double check it exists before deleting
                    delete db.holidays[dateStr];
                    saveDb(db);
                    showToast(`${typeText} eliminata per ${dateStr}.`, 'success');
                    console.log(`Assenza eliminata per ${dateStr}.`);
                    // Reload relevant views
                    loadFerieMalattieEntries(); // Reload list
                    if (document.getElementById('calendar-section')?.classList.contains('active') && typeof loadCalendarData === 'function') loadCalendarData();
                    if (document.getElementById('monthly-report-section')?.classList.contains('active') && typeof displayMonthlyReport === 'function') {
                        const monthSelect = document.getElementById('exportMonthSelect');
                        if (monthSelect) displayMonthlyReport(monthSelect.value, document.getElementById('monthlyReportContent'));
                    }
                } else {
                    // Should not happen due to check above, but handle defensively
                    console.warn(`Assenza per ${dateStr} scomparsa prima dell'eliminazione effettiva.`);
                    showToast("Voce di assenza non trovata (potrebbe essere già stata eliminata).", "warning");
                    loadFerieMalattieEntries();
                }
            } else {
                console.log("Eliminazione assenza annullata.");
            }
        }

        function loadFerieMalattieTypes() {
            // Currently types are hardcoded in select. This function is a placeholder.
            console.log("Tipi Ferie/Malattie caricati (staticamente).");
        }


        // --- Utility Functions ---

        /**
         * Parses a date string in dd/mm/yyyy format into a Date object.
         * Returns Invalid Date object if parsing fails.
         */
        function parseDate(dateStr) {
             if (!dateStr || typeof dateStr !== 'string') {
                 return new Date(NaN); // Return Invalid Date
             }
             const parts = dateStr.split('/');
             if (parts.length === 3) {
                 const day = parseInt(parts[0], 10);
                 const month = parseInt(parts[1], 10) - 1; // Month is 0-indexed in Date
                 const year = parseInt(parts[2], 10);
                 // Basic validation of parts
                 if (!isNaN(day) && !isNaN(month) && !isNaN(year) && year > 1900 && year < 3000 && month >= 0 && month <= 11 && day > 0 && day <= 31) {
                     // Use local timezone, not UTC
                     const date = new Date(year, month, day);
                     // Final check to catch invalid dates like 31/04/2023 and ensure parts match using local date methods
                     if (!isNaN(date.getTime()) && date.getFullYear() === year && date.getMonth() === month && date.getDate() === day) {
                          return date;
                      }
                 }
             }
             return new Date(NaN); // Return Invalid Date if format is wrong or date invalid
        }

         /**
         * Formats a Date object into a dd/mm/yyyy string.
         * Returns empty string if date is invalid.
         */
        function formatDateForInput(date) {
            if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
                // console.warn('formatDateForInput: data non valida', date);
                return '';
            }
            try {
                const day = date.getDate().toString().padStart(2, '0'); // Use local day
                const month = (date.getMonth() + 1).toString().padStart(2, '0'); // Use local month
                const year = date.getFullYear(); // Use local year
                return `${day}/${month}/${year}`;
            } catch (error) {
                console.error('Errore nella formattazione della data per input:', error);
                return '';
            }
        }

        /**
         * Formats a Date object into a "Giorno GG/MM" string for Excel export.
         * Returns empty string if date is invalid.
         */
        function formatDateForExcel(date) {
            if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
                return '';
            }
            try {
                const weekdays = ['Domenica', 'Lunedì', 'Martedì', 'Mercoledì', 'Giovedì', 'Venerdì', 'Sabato'];
                const weekday = weekdays[date.getDay()];
                const day = date.getDate().toString().padStart(2, '0');
                const month = (date.getMonth() + 1).toString().padStart(2, '0');

                // Controlla se è un giorno festivo speciale (non weekend)
                const isWeekend = date.getDay() === 0 || date.getDay() === 6;

                // Verifica se è una festività speciale (non weekend)
                let isSpecialHoliday = false;

                // Festività fisse in Italia
                const fixedHolidays = [
                    { day: 1, month: 1 },    // Capodanno
                    { day: 6, month: 1 },    // Epifania
                    { day: 25, month: 4 },   // Festa della Liberazione
                    { day: 1, month: 5 },    // Festa del Lavoro
                    { day: 2, month: 6 },    // Festa della Repubblica
                    { day: 15, month: 8 },   // Ferragosto
                    { day: 1, month: 11 },   // Tutti i Santi
                    { day: 8, month: 12 },   // Immacolata Concezione
                    { day: 25, month: 12 },  // Natale
                    { day: 26, month: 12 }   // Santo Stefano
                ];

                // Verifica festività fisse
                if (fixedHolidays.some(holiday =>
                    holiday.day === date.getDate() &&
                    holiday.month === (date.getMonth() + 1)
                )) {
                    isSpecialHoliday = true;
                }

                // Calcola la Pasqua e Lunedì dell'Angelo
                const easterDate = getEasterDate(date.getFullYear());
                if (easterDate) {
                    // Pasqua
                    if (date.getTime() === easterDate.getTime()) {
                        isSpecialHoliday = true;
                    }

                    // Lunedì dell'Angelo (Pasquetta) - giorno dopo Pasqua
                    const easterMonday = new Date(easterDate);
                    easterMonday.setDate(easterDate.getDate() + 1);
                    if (date.getTime() === easterMonday.getTime()) {
                        isSpecialHoliday = true;
                    }
                }

                // Aggiungi la stella gialla solo se è una festività speciale
                if (isSpecialHoliday) {
                    return `⭐ ${weekday} ${day}/${month}`;
                } else {
                    return `${weekday} ${day}/${month}`;
                }
            } catch (error) {
                console.error('Errore nella formattazione della data per Excel:', error);
                return '';
            }
        }

        /**
         * Formats a date (string dd/mm/yyyy or Date object) for display.
         * Returns input string if already formatted, or formatted string, or empty string on error.
         */
        function formatDate(date) {
            if (!date) return '';
            if (typeof date === 'string' && /^\d{2}\/\d{2}\/\d{4}$/.test(date)) {
                return date; // Already correct format
            }
             let dateObj = date;
             if (typeof date === 'string') {
                  dateObj = parseDate(date); // Attempt to parse if string but wrong format
             }

            if (dateObj instanceof Date && !isNaN(dateObj.getTime())) {
                return formatDateForInput(dateObj); // Reuse the input formatter
            } else {
                 console.warn('formatDate: impossibile formattare data', date);
                return '';
            }
        }


        /**
         * Checks if a date is an Italian holiday (fixed + Easter based).
         */
        function isItalianHoliday(date) {
            if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
                return false;
            }

            // Use local date components
            const day = date.getDate();
            const month = date.getMonth() + 1; // Month is 1-based for checks
            const year = date.getFullYear();

            // Fixed holidays (day/month)
            const fixedHolidays = [
                "1/1", "6/1", "25/4", "1/5", "2/6", "15/8", "1/11", "8/12", "25/12", "26/12"
            ];
            if (fixedHolidays.includes(`${day}/${month}`)) {
                return true;
            }

            // Easter calculation (Gauss algorithm - simpler version)
            const a = year % 19;
            const b = year % 4;
            const c = year % 7;
            const k = Math.floor(year / 100);
            const p = Math.floor((13 + 8 * k) / 25);
            const q = Math.floor(k / 4);
            const M = (15 - p + k - q) % 30;
            const N = (4 + k - q) % 7;
            const d = (19 * a + M) % 30;
            const e = (2 * b + 4 * c + 6 * d + N) % 7;

            let easterDay, easterMonth;
            if (d === 29 && e === 6) {
                easterDay = 19; easterMonth = 4; // April 19
            } else if (d === 28 && e === 6 && (11 * M + 11) % 30 < 19) {
                easterDay = 18; easterMonth = 4; // April 18
            } else {
                const dayOffset = d + e;
                if (dayOffset < 10) {
                    easterDay = dayOffset + 22; easterMonth = 3; // March
                } else {
                    easterDay = dayOffset - 9; easterMonth = 4; // April
                }
            }

            // Check Easter Sunday
             if (day === easterDay && month === easterMonth) {
                 return true;
             }

            // Check Easter Monday (Pasquetta)
            // Create Easter date using local components now for consistency
            // Note: This might slightly affect accuracy if Easter calculation assumes UTC, but less likely to cause day shift
            const easterDate = new Date(year, easterMonth - 1, easterDay);
             const easterMonday = new Date(easterDate);
            easterMonday.setDate(easterDate.getDate() + 1); // Use setDate for local day increment
             if (day === easterMonday.getDate() && month === easterMonday.getMonth() + 1) {
                  return true;
              }

            return false;
        }

        /**
         * Gets the name of an Italian holiday for a specific date.
         */
        function getHolidayName(date) {
            if (!date || !(date instanceof Date) || isNaN(date.getTime())) {
                return '';
            }

            // Use local date components
            const day = date.getDate();
            const month = date.getMonth() + 1; // 1-based
            const year = date.getFullYear();

            // Fixed holidays names
            const holidayNames = {
                '1/1': 'Capodanno', '6/1': 'Epifania', '25/4': 'Liberazione',
                '1/5': 'Festa Lavoro', '2/6': 'Festa Repubblica', '15/8': 'Ferragosto',
                '1/11': 'Tutti i Santi', '8/12': 'Immacolata', '25/12': 'Natale', '26/12': 'S. Stefano'
            };
            if (holidayNames[`${day}/${month}`]) {
                return holidayNames[`${day}/${month}`];
            }

            // Calculate Easter date again (or reuse calculation if optimized)
             const a = year % 19, b = year % 4, c = year % 7, k = Math.floor(year / 100), p = Math.floor((13 + 8 * k) / 25), q = Math.floor(k / 4);
             const M = (15 - p + k - q) % 30, N = (4 + k - q) % 7;
             const d = (19 * a + M) % 30, e = (2 * b + 4 * c + 6 * d + N) % 7;
             let easterDay, easterMonth;
             if (d === 29 && e === 6) { easterDay = 19; easterMonth = 4; }
             else if (d === 28 && e === 6 && (11 * M + 11) % 30 < 19) { easterDay = 18; easterMonth = 4; }
             else { const dayOffset = d + e; if (dayOffset < 10) { easterDay = dayOffset + 22; easterMonth = 3; } else { easterDay = dayOffset - 9; easterMonth = 4; } }

            if (day === easterDay && month === easterMonth) return 'Pasqua';

            // Create Easter date using local components
            const easterDate = new Date(year, easterMonth - 1, easterDay);
             const easterMonday = new Date(easterDate);
            easterMonday.setDate(easterDate.getDate() + 1); // Use setDate
             if (day === easterMonday.getDate() && month === easterMonday.getMonth() + 1) return 'Pasquetta';

            return '';
        }


        /**
         * Inizializza i controlli per incrementare/decrementare i campi orari
         */
        function initTimeControls() {
            console.log("Inizializzazione controlli orari...");
            const timeControlButtons = document.querySelectorAll('.time-control-btn');

            // Prima rimuoviamo tutti gli event listener esistenti
            timeControlButtons.forEach(button => {
                // Clona e sostituisci il pulsante per rimuovere tutti gli event listener
                const newButton = button.cloneNode(true);
                button.parentNode.replaceChild(newButton, button);
            });

            // Ora aggiungiamo i nuovi event listener
            document.querySelectorAll('.time-control-btn').forEach(button => {
                button.addEventListener('click', function() {
                    const action = this.getAttribute('data-action');
                    const targetId = this.getAttribute('data-target');
                    const targetInput = document.getElementById(targetId);

                    if (!targetInput) return;

                    let currentValue = parseFloat(targetInput.value.replace(',', '.')) || 0;

                    if (action === 'increase') {
                        currentValue += 0.5;
                    } else if (action === 'decrease') {
                        currentValue -= 0.5;
                        if (currentValue < 0) currentValue = 0;
                    }

                    // Formatta il valore per mostrare .5 invece di .0
                    targetInput.value = currentValue % 1 === 0 ? currentValue.toString() : currentValue.toFixed(1);

                    // Ricalcola le ore totali
                    calculateTotalHours();
                });
            });
        }

        /**
         * Calculates total work hours based on start, end, and break times.
         * Handles overnight shifts.
         */
        function calculateTotalHours() {
            const startTimeInput = document.getElementById('startTime');
            const endTimeInput = document.getElementById('endTime');
            const breakTimeInput = document.getElementById('breakTime');
            const totalHoursInput = document.getElementById('totalHours');

             if (!startTimeInput || !endTimeInput || !breakTimeInput || !totalHoursInput) {
                 // console.warn("Elementi mancanti per calcolo ore totali.");
                 return; // Don't proceed if elements are missing
             }

            try {
                 // Use parseFloat for decimal hours, default to NaN if invalid
                 const startStr = startTimeInput.value.replace(',', '.'); // Allow comma decimal
                 const endStr = endTimeInput.value.replace(',', '.');
                 const breakStr = breakTimeInput.value.replace(',', '.');

                 const startTime = parseFloat(startStr);
                 const endTime = parseFloat(endStr);
                 const breakTime = parseFloat(breakStr) || 0; // Default break to 0 if invalid

                 // Verifica se entrambi i campi orari sono vuoti
                 if (startTimeInput.value === '' && endTimeInput.value === '') {
                     // Se entrambi i campi sono vuoti, imposta le ore totali a 0
                     totalHoursInput.value = '0.0';
                     return;
                 }

                 // Se solo uno dei due campi è compilato, non possiamo calcolare le ore
                 if ((startTimeInput.value === '' && endTimeInput.value !== '') ||
                     (startTimeInput.value !== '' && endTimeInput.value === '')) {
                     totalHoursInput.value = '';
                     return;
                 }

                 // Only calculate if start and end times are valid numbers
                 if (!isNaN(startTime) && !isNaN(endTime)) {
                     let totalHours = 0;

                      // Normalize times (e.g., handle 24 as 0 for calculation, but maybe allow 24 as input?)
                      // Let's assume input is 0-23.99 range, or integer hours 0-24
                      let start = startTime;
                      let end = endTime;

                      // Simple check for overnight: if end time is numerically smaller than start time
                      if (end < start) {
                          // Overnight shift
                          totalHours = (24 - start) + end;
                      } else if (end === start) {
                           // Could be 24 hours or 0 hours. Assume 0 unless explicitly 24?
                           // If start is 0 and end is 0, it's 0 hours. If start is 7 end is 7, likely error or 0.
                           // Let's assume 0 if times are equal.
                           totalHours = 0;
                      }
                       else {
                          // Same day shift
                          totalHours = end - start;
                      }

                     // Subtract break time, ensure result is not negative
                     totalHours = Math.max(0, totalHours - breakTime);

                     // Update the totalHours field, formatted to one decimal place
                     totalHoursInput.value = totalHours.toFixed(1);
                 } else {
                     // If start or end time is not a valid number, clear the total
                     totalHoursInput.value = '';
                 }

            } catch (error) {
                console.error('Errore nel calcolo delle ore totali:', error);
                totalHoursInput.value = ''; // Clear total on error
            }
        }

         /**
         * Simple HTML escaping function
         */
         function escapeHtml(unsafe) {
             if (typeof unsafe !== 'string') return unsafe; // Return non-strings as is
             return unsafe
                  .replace(/&/g, "&amp;")
                  .replace(/</g, "&lt;")
                  .replace(/>/g, "&gt;")
                  .replace(/"/g, "&quot;")
                  .replace(/'/g, "&#039;");
         }


        // --- QR Code Generation ---
         function generateQRCodes() {
             console.log("Generazione QR Code...");
             const websiteUrl = "https://www.pwsgroup.eu/";
             // Simplified VCard for better compatibility
             const contactsVCard = `BEGIN:VCARD
VERSION:3.0
FN:PWS Group
ORG:PWS Group
TEL;TYPE=WORK,VOICE:0293219393
ADR;TYPE=WORK:;;Via G. Boccaccio, 95/c;Trezzano S.N;MI;20090;Italy
URL:${websiteUrl}
END:VCARD`;

             const qrWebsiteContainer = document.getElementById('qrcode');
             const qrContactsContainer = document.getElementById('contacts-qrcode');

              // Ensure QRCode library is loaded
             if (typeof QRCode === 'undefined') {
                 console.error("Libreria QRCode.js non caricata. Impossibile generare QR code.");
                 // Optionally display a message in the containers
                  if(qrWebsiteContainer) qrWebsiteContainer.innerHTML = '<p style="font-size:0.8rem; color: var(--md-sys-color-error);">Errore caricamento QR</p>';
                  if(qrContactsContainer) qrContactsContainer.innerHTML = '<p style="font-size:0.8rem; color: var(--md-sys-color-error);">Errore caricamento QR</p>';
                 return;
             }

             try {
                 // Generate Website QR
                 if (qrWebsiteContainer) {
                     qrWebsiteContainer.innerHTML = ''; // Clear previous/static content
                     new QRCode(qrWebsiteContainer, {
                         text: websiteUrl,
                         width: 180,
                         height: 180,
                         colorDark : "#000000",
                         colorLight : "#ffffff",
                         correctLevel : QRCode.CorrectLevel.H // High correction for reliability
                     });
                      console.log("QR Code sito web generato.");
                 } else { console.warn("Contenitore QR code sito web (#qrcode) non trovato."); }

                 // Generate Contacts QR
                 if (qrContactsContainer) {
                     qrContactsContainer.innerHTML = ''; // Clear previous/static content
                     new QRCode(qrContactsContainer, {
                         text: contactsVCard,
                         width: 180,
                         height: 180,
                         colorDark : "#000000",
                         colorLight : "#ffffff",
                         correctLevel : QRCode.CorrectLevel.M // Medium correction for VCard data
                     });
                      console.log("QR Code contatti generato.");
                  } else { console.warn("Contenitore QR code contatti (#contacts-qrcode) non trovato."); }

             } catch (e) {
                 console.error("Errore durante la generazione dei QR code con QRCode.js:", e);
                 showToast("Errore nella generazione dei QR code.", "error");
                  // Optionally display error message in containers
             }
         }

         // Add alias functions to match orepw2.0.html
         function exportAllData() {
             console.log("Alias exportAllData chiamato, utilizzo exportData");
             exportData();
         }

         function importAllData() {
             console.log("Alias importAllData chiamato, utilizzo triggerImport");
             triggerImport();
         }

        // --- New functions to handle marking day as Ferie/Malattia ---
        function markDayAsAbsence(dateStr, type) {
            console.log(`Tentativo di segnare ${dateStr} come ${type}`);
            const db = getDb();
            if (!db.holidays) db.holidays = {};

            // Check for existing work entries
            const existingWorkEntries = db.entries[dateStr] || [];
            if (existingWorkEntries.length > 0) {
                if (!confirm(`Il giorno ${dateStr} ha già delle ore lavorate inserite. Sei sicuro di volerlo segnare come ${type}? Le ore verranno ignorate nei totali.`)) {
                    showToast('Operazione annullata.', 'info');
                    return;
                }
            }

            // Add/overwrite the absence entry
            db.holidays[dateStr] = { type: type, note: '' }; // Add empty note by default
            saveDb(db);

            const typeText = type === 'ferie' ? 'Ferie' : 'Malattia';
            showToast(`Giorno ${dateStr} segnato come ${typeText}.`, 'success');

            // Close the modal
            const modal = document.getElementById('dayModal');
            if (modal) {
                modal.style.display = 'none';
                modal.style.opacity = '0';
                modal.style.visibility = 'hidden';
                modal.classList.remove('visible');
                console.log("Modale chiuso dopo aver segnato assenza");
            }

            // Refresh relevant views
            if (typeof loadCalendarData === 'function') loadCalendarData();
            if (typeof updateMonthlySummary === 'function') {
                 const currentMonth = window.currentCalendarDate || new Date();
                 updateMonthlySummary(currentMonth.getFullYear(), currentMonth.getMonth(), getDb());
            }
            if (typeof loadFerieMalattieEntries === 'function') loadFerieMalattieEntries();
            if (document.getElementById('monthly-report-section')?.classList.contains('active') && typeof displayMonthlyReport === 'function') {
                 const monthSelect = document.getElementById('exportMonthSelect');
                 if (monthSelect) displayMonthlyReport(monthSelect.value, document.getElementById('monthlyReportContent'));
            }
        }

        // --- Utility Functions ---

        function formatTime(date) {
            if (!(date instanceof Date) || isNaN(date)) {
                console.warn("formatTime received an invalid date:", date);
                return "--:--"; // Return a placeholder for invalid dates
            }
            const hours = date.getHours().toString().padStart(2, '0');
            const minutes = date.getMinutes().toString().padStart(2, '0');
            return `${hours}:${minutes}`;
         }

         // Interattività per il logo rimbalzante
         document.addEventListener('DOMContentLoaded', function() {
             // Rimuovi l'overlay del troll se presente (per evitare che blocchi i click)
             const trollOverlay = document.getElementById('trollOverlay');
             if (trollOverlay) {
                 trollOverlay.classList.remove('visible');
                 console.log("Overlay troll resettato all'avvio per evitare blocchi");
             }

             // Rimuovi eventuali contenitori di esplosione rimasti
             const explosionContainer = document.getElementById('explosion-container');
             if (explosionContainer) {
                 explosionContainer.remove();
                 console.log("Contenitore esplosione rimosso all'avvio");
             }

             // Rimuovi eventuali animazioni dal body
             document.body.style.animation = 'none';
             console.log("Animazioni body resettate all'avvio");

             const logo = document.getElementById('pws-logo');
             if (logo) {
                 // Quando l'utente clicca sul logo, aggiungiamo un'animazione più vivace
                 logo.addEventListener('click', function(e) {
                     // Rimuoviamo temporaneamente la classe per resettare l'animazione
                     this.classList.remove('bouncing-logo');

                     // Forziamo un reflow per assicurarci che l'animazione si resetti
                     void this.offsetWidth;

                     // Aggiungiamo una classe per un'animazione più vivace
                     this.classList.add('bouncing-logo-excited');

                     // Dopo l'animazione, torniamo all'animazione normale
                     setTimeout(() => {
                         this.classList.remove('bouncing-logo-excited');
                         this.classList.add('bouncing-logo');
                     }, 2000); // Durata dell'animazione speciale

                     // Mostriamo un messaggio divertente
                     showToast('Ciao! 👋 Sono il logo PWS!', 'success');
                 });

                 // Funzione per inizializzare il Gratta e Vinci
                 function initScratchCard() {
                     console.log("Inizializzazione Gratta e Vinci...");
                     const scratchCardBtn = document.getElementById('scratchCardBtn');
                     const scratchCardOverlay = document.getElementById('scratchCardOverlay');
                     const scratchCardCover = document.getElementById('scratchCardCover');
                     const closeScratchCard = document.getElementById('closeScratchCard');

                     console.log("Elementi trovati:", {
                         scratchCardBtn: !!scratchCardBtn,
                         scratchCardOverlay: !!scratchCardOverlay,
                         scratchCardCover: !!scratchCardCover,
                         closeScratchCard: !!closeScratchCard
                     });

                     if (!scratchCardBtn || !scratchCardOverlay || !scratchCardCover || !closeScratchCard) {
                         console.error("Elementi del Gratta e Vinci non trovati");
                         return;
                     }

                     // Apri il Gratta e Vinci quando si clicca sul pulsante
                     scratchCardBtn.onclick = function() {
                         console.log("Pulsante Gratta e Vinci cliccato");
                         scratchCardOverlay.classList.add('visible');
                         document.body.style.overflow = 'hidden'; // Blocca lo scroll
                     };

                     // Chiudi il Gratta e Vinci quando si clicca sul pulsante di chiusura
                     closeScratchCard.onclick = function() {
                         console.log("Pulsante di chiusura Gratta e Vinci cliccato");
                         scratchCardOverlay.classList.remove('visible');
                         document.body.style.overflow = ''; // Ripristina lo scroll
                     };

                     // Gestisci il grattamento
                     let isScratching = false;
                     let scratchedPercentage = 0;
                     const totalArea = scratchCardCover.offsetWidth * scratchCardCover.offsetHeight;
                     const scratchedPixels = new Set();

                     // Funzione per calcolare la percentuale grattata
                     function calculateScratchedPercentage(x, y, radius) {
                         const pixelRadius = radius * 5; // Aumenta l'area grattata

                         for (let i = -pixelRadius; i <= pixelRadius; i++) {
                             for (let j = -pixelRadius; j <= pixelRadius; j++) {
                                 if (i*i + j*j <= pixelRadius*pixelRadius) {
                                     const pixelX = Math.floor(x + i);
                                     const pixelY = Math.floor(y + j);
                                     const pixelKey = `${pixelX},${pixelY}`;

                                     if (!scratchedPixels.has(pixelKey)) {
                                         scratchedPixels.add(pixelKey);
                                     }
                                 }
                             }
                         }

                         return (scratchedPixels.size / totalArea) * 100;
                     }

                     // Funzione per grattare
                     function scratch(e) {
                         if (!isScratching) return;

                         const rect = scratchCardCover.getBoundingClientRect();
                         let x, y;

                         // Supporto per touch e mouse
                         if (e.type.includes('touch')) {
                             const touch = e.touches[0] || e.changedTouches[0];
                             x = touch.clientX - rect.left;
                             y = touch.clientY - rect.top;
                         } else {
                             x = e.clientX - rect.left;
                             y = e.clientY - rect.top;
                         }

                         // Crea un effetto di trasparenza dove si gratta
                         const radius = 20;
                         scratchCardCover.style.background = `radial-gradient(circle at ${x}px ${y}px, transparent ${radius}px, rgba(255, 215, 0, 0.9) ${radius + 1}px)`;

                         // Aggiorna la percentuale grattata
                         scratchedPercentage = calculateScratchedPercentage(x, y, radius);

                         // Se è stato grattato abbastanza, rivela il contenuto
                         if (scratchedPercentage > 30) {
                             scratchCardCover.style.opacity = '0';
                             setTimeout(() => {
                                 scratchCardCover.style.display = 'none';
                             }, 500);

                             // Rimuovi gli event listener
                             scratchCardCover.removeEventListener('mousedown', startScratching);
                             scratchCardCover.removeEventListener('mousemove', scratch);
                             scratchCardCover.removeEventListener('mouseup', stopScratching);
                             scratchCardCover.removeEventListener('mouseleave', stopScratching);
                             scratchCardCover.removeEventListener('touchstart', startScratching);
                             scratchCardCover.removeEventListener('touchmove', scratch);
                             scratchCardCover.removeEventListener('touchend', stopScratching);
                         }
                     }

                     // Funzione per iniziare a grattare
                     function startScratching(e) {
                         isScratching = true;
                         scratch(e);
                     }

                     // Funzione per smettere di grattare
                     function stopScratching() {
                         isScratching = false;
                     }

                     // Aggiungi gli event listener per il grattamento
                     scratchCardCover.addEventListener('mousedown', startScratching);
                     scratchCardCover.addEventListener('mousemove', scratch);
                     scratchCardCover.addEventListener('mouseup', stopScratching);
                     scratchCardCover.addEventListener('mouseleave', stopScratching);

                     // Supporto per dispositivi touch
                     scratchCardCover.addEventListener('touchstart', startScratching);
                     scratchCardCover.addEventListener('touchmove', scratch);
                     scratchCardCover.addEventListener('touchend', stopScratching);
                 }

                 // Funzione per mostrare l'overlay del supereroe
                 function showSuperheroOverlay() {
                     console.log("Attivazione overlay supereroe");
                     const overlay = document.getElementById('superheroOverlay');
                     if (!overlay) {
                         console.error("Overlay del supereroe non trovato!");
                         return;
                     }

                     // Non mostriamo più messaggi di caricamento
                     console.log('Caricamento supereroe in corso senza notifiche');

                     // Crea un nuovo oggetto Image per precaricare la GIF
                     const preloadImg = new Image();
                     const gifUrl = "https://raw.githubusercontent.com/lyakhu955/ore-pws/main/freepik__wide-shot-a-stylized-cartoon-superhero-stands-tall__79694.gif";

                     // Aggiungi un timestamp per evitare la cache
                     preloadImg.src = gifUrl + "?t=" + new Date().getTime();

                     // Quando l'immagine è caricata, aggiorna l'overlay
                     preloadImg.onload = function() {
                         console.log("GIF precaricata con successo");

                         // Trova l'elemento immagine nell'overlay
                         const superheroGif = overlay.querySelector('.superhero-gif');
                         if (superheroGif) {
                             // Aggiorna l'src dell'immagine con quella precaricata
                             superheroGif.src = preloadImg.src;
                         }

                      // Forza la visibilità dell'overlay
                            overlay.style.opacity = "1";
                         overlay.style.visibility = "visible";
                         overlay.style.display = "flex";
                         overlay.classList.add('visible');

                         // Blocca lo scroll della pagina quando l'overlay è visibile
                         document.body.style.overflow = 'hidden';
                     };

                     // In caso di errore nel caricamento della GIF
                     preloadImg.onerror = function() {
                         console.error("Errore nel caricamento della GIF");

                         // Mostra comunque l'overlay
                         overlay.style.opacity = "1";
                         overlay.style.visibility = "visible";
                         overlay.style.display = "flex";
                         overlay.classList.add('visible');

                         // Mostra un messaggio di errore nell'overlay
                         const container = overlay.querySelector('.superhero-container');
                         if (container) {
                             container.innerHTML = '<div style="color: white; font-size: 24px; text-align: center; padding: 20px;">Impossibile caricare il supereroe.<br>Riprova più tardi!</div>';
                         }

                         // Blocca lo scroll della pagina quando l'overlay è visibile
                         document.body.style.overflow = 'hidden';
                     };
                 }

                 // La funzione showSuperheroOverlayDirect è stata rimossa

                 // Gestione del pulsante di chiusura con scherzo
                 const closeBtn = document.getElementById('closeSuperhero');
                 if (closeBtn) {
                     // Contatore per tenere traccia dei tentativi di click
                     let clickCount = 0;
                     let isEscaping = false;
                     let isAudioPlaying = false; // Flag per tracciare se un audio è in riproduzione

                     // Funzione per fermare tutti gli audio (compatibile con iOS)
                     function stopAllAudio() {
                         audioElements.forEach(audioEl => {
                             if (audioEl) {
                                 try {
                                     audioEl.pause();
                                     audioEl.currentTime = 0;
                                 } catch (e) {
                                     console.error("Errore nel fermare l'audio:", e);
                                 }
                             }
                         });

                         // Resetta il flag audio
                         isAudioPlaying = false;
                     }

                     // Array di messaggi da mostrare
                     const messages = [
                         "Perchè mi vuoi schiacciare???",
                         "Hey guarda che fa male!!!",
                         "Ti prego ho una famiglia!!!",
                         "Va bene facciamola finita sono stanco di correre"
                     ];

                     // Rileva se il dispositivo è iOS
                     const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                     console.log("Rilevato dispositivo iOS:", isIOS);

                     // Fonti audio
                     const audioSources = [
                         "https://raw.githubusercontent.com/lyakhu955/ore-pws/main/audio/help.mp3",
                         "https://raw.githubusercontent.com/lyakhu955/ore-pws/main/audio/r2d2.mp3",
                         "https://raw.githubusercontent.com/lyakhu955/ore-pws/main/audio/cry.mp3",
                         "https://raw.githubusercontent.com/lyakhu955/ore-pws/main/audio/germano.mp3"
                     ];

                     // Crea elementi audio compatibili con iOS
                     const audioElements = [];

                     // Funzione per creare un elemento audio
                     function createAudioElement(src, index) {
                         const audio = new Audio(src);
                         audio.preload = "auto";
                         // Attributi per iOS
                         audio.setAttribute("playsinline", "");
                         audio.setAttribute("webkit-playsinline", "");
                         return audio;
                     }

                     // Crea gli elementi audio
                     audioSources.forEach((src, index) => {
                         audioElements.push(createAudioElement(src, index));
                     });

                     // Funzione per far scappare il pulsante in una posizione casuale con effetti cartoon
                     function escapeTo(button) {
                         // Ottieni le dimensioni della finestra
                         const windowWidth = window.innerWidth;
                         const windowHeight = window.innerHeight;

                         // Calcola una posizione casuale all'interno della finestra
                         // Lascia un margine più piccolo per movimenti più ampi
                         const margin = 50;
                         const randomX = Math.max(margin, Math.min(windowWidth - margin, Math.random() * windowWidth));
                         const randomY = Math.max(margin, Math.min(windowHeight - margin, Math.random() * windowHeight));

                         // Aggiungi effetti casuali di stile cartoon
                         const effects = [
                             'escape-animation 0.4s infinite',
                             'escape-animation 0.3s infinite, squash-stretch 0.5s infinite',
                             'escape-animation 0.2s infinite, shake 0.3s infinite',
                             'escape-animation 0.4s infinite linear'
                         ];

                         // Scegli un effetto casuale
                         const randomEffect = effects[Math.floor(Math.random() * effects.length)];
                         button.style.animation = randomEffect;

                         // Colori casuali per l'ombra
                         const colors = ['rgba(255,0,0,0.7)', 'rgba(0,255,0,0.7)', 'rgba(0,0,255,0.7)', 'rgba(255,255,0,0.7)'];
                         const randomColor = colors[Math.floor(Math.random() * colors.length)];
                         button.style.boxShadow = `0 0 15px ${randomColor}`;

                         // Applica la nuova posizione con un leggero ritardo per effetto cartoon
                         setTimeout(() => {
                             button.style.top = randomY + 'px';
                             button.style.left = randomX + 'px';
                             button.style.right = 'auto'; // Rimuovi right per evitare conflitti
                         }, 50);
                     }

                     // Funzione per mostrare il messaggio RIP
                     function showRIPMessage() {
                         // Crea l'elemento per il messaggio RIP
                         const ripMessage = document.createElement('div');
                         ripMessage.className = 'rip-message';

                         // Ottieni la data attuale
                         const today = new Date();
                         const day = today.getDate();
                         const month = today.getMonth() + 1; // I mesi partono da 0
                         const year = today.getFullYear();

                         // Formatta la data come DD/MM/YYYY
                         const formattedDate = `${day.toString().padStart(2, '0')}/${month.toString().padStart(2, '0')}/${year}`;

                         // Imposta il contenuto del messaggio
                         ripMessage.innerHTML = `RIP Mr.X ${formattedDate}`;

                         // Aggiungi il messaggio all'header per integrarlo nella barra in alto
                         const header = document.querySelector('header');
                         if (header) {
                             header.appendChild(ripMessage);
                         } else {
                             // Fallback al body se l'header non esiste
                             document.body.appendChild(ripMessage);
                         }

                         // Riproduci l'audio funebre immediatamente quando appare il messaggio RIP
                         console.log("Tentativo di riproduzione dell'audio funebre");

                         // Crea un nuovo elemento audio compatibile con iOS
                         const funeralAudio = new Audio("https://raw.githubusercontent.com/lyakhu955/ore-pws/main/audio/funeral.mp3");
                         funeralAudio.volume = 1.0; // Volume massimo

                         // Aggiungi attributi per iOS
                         funeralAudio.setAttribute("playsinline", "");
                         funeralAudio.setAttribute("webkit-playsinline", "");

                         // Funzione per riprodurre l'audio con gestione degli errori
                         function playFuneralAudio() {
                             console.log("Tentativo di riproduzione audio funebre");
                             const playPromise = funeralAudio.play();

                             if (playPromise !== undefined) {
                                 playPromise
                                     .then(() => {
                                         console.log("Audio funebre riprodotto con successo");
                                     })
                                     .catch(error => {
                                         console.error("Errore nella riproduzione dell'audio funebre:", error);

                                         // Su iOS, l'audio può essere riprodotto solo dopo un'interazione dell'utente
                                         const playOnUserInteraction = function() {
                                             funeralAudio.play()
                                                 .then(() => console.log("Audio funebre riprodotto dopo interazione utente"))
                                                 .catch(e => console.error("Ancora errori nella riproduzione:", e));

                                             document.removeEventListener('click', playOnUserInteraction);
                                             document.removeEventListener('touchstart', playOnUserInteraction);
                                         };

                                         // Aggiungi gestori sia per click che per touch
                                         document.addEventListener('click', playOnUserInteraction, { once: true });
                                         document.addEventListener('touchstart', playOnUserInteraction, { once: true });
                                     });
                             }
                         }

                         // Su iOS, attendiamo che l'audio sia pronto
                         if (isIOS) {
                             funeralAudio.addEventListener('canplaythrough', function onCanPlay() {
                                 console.log("Audio funebre pronto per la riproduzione (iOS)");
                                 setTimeout(playFuneralAudio, 100);
                                 funeralAudio.removeEventListener('canplaythrough', onCanPlay);
                             });
                         } else {
                             // Su altri dispositivi, riproduciamo direttamente
                             setTimeout(playFuneralAudio, 100);
                         }

                         // Forza il caricamento dell'audio
                         funeralAudio.load();

                         // Rendi visibile il messaggio
                         setTimeout(() => {
                             ripMessage.classList.add('visible');
                         }, 100);

                         // Rimuovi il messaggio dopo 5 secondi
                         setTimeout(() => {
                             ripMessage.classList.remove('visible');
                             setTimeout(() => {
                                 const parent = ripMessage.parentNode;
                                 if (parent && parent.contains(ripMessage)) {
                                     parent.removeChild(ripMessage);
                                 }
                             }, 500);
                         }, 5000);
                     }

                     // Variabili per gestire la pressione prolungata
                     let pressTimer;
                     let isPressing = false;
                     let wasLongPress = false; // Flag per tracciare se c'è stata una pressione prolungata

                     // Funzione per chiudere direttamente l'overlay
                     function closeOverlayDirectly() {
                         console.log("Chiusura diretta dell'overlay dopo pressione prolungata");
                         // Imposta il flag per indicare che c'è stata una pressione prolungata
                         wasLongPress = true;

                         const overlay = document.getElementById('superheroOverlay');
                         if (overlay) {
                             // Forza la chiusura dell'overlay
                             overlay.classList.remove('visible');
                             overlay.style.opacity = "0";
                             overlay.style.visibility = "hidden";
                             overlay.style.display = "none";

                             // Ripristina lo scroll della pagina
                             document.body.style.overflow = '';

                             // Mostra un messaggio di conferma
                             showToast("Supiroman torna alla base!", "success", 2000);
                         }
                     }

                     // Aggiungiamo uno stile per l'animazione di pressione prolungata
                     const style = document.createElement('style');
                     style.textContent = `
                         @keyframes longPressAnimation {
                             0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.7); }
                             50% { transform: scale(1.1); box-shadow: 0 0 0 10px rgba(255, 255, 255, 0); }
                             100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 255, 255, 0); }
                         }
                         .long-press-active {
                             animation: longPressAnimation 1s infinite;
                             background-color: rgba(255, 0, 0, 0.7) !important;
                         }
                         /* Previeni la selezione del testo su iOS */
                         .close-btn, .close-btn * {
                             -webkit-touch-callout: none !important;
                             -webkit-user-select: none !important;
                             -moz-user-select: none !important;
                             -ms-user-select: none !important;
                             user-select: none !important;
                             touch-action: manipulation !important;
                             -webkit-tap-highlight-color: transparent !important;
                         }
                     `;

                     // Aggiungiamo un listener globale per prevenire la selezione del testo sul pulsante
                     document.addEventListener('selectionchange', function() {
                         const selection = window.getSelection();
                         if (selection.rangeCount > 0) {
                             const range = selection.getRangeAt(0);
                             const closeBtn = document.getElementById('closeSuperhero');
                             if (closeBtn && closeBtn.contains(range.commonAncestorContainer)) {
                                 selection.removeAllRanges();
                             }
                         }
                     });
                     document.head.appendChild(style);

                     // Gestione dell'evento mousedown/touchstart
                     closeBtn.addEventListener('mousedown', function(e) {
                         isPressing = true;

                         // Aggiungi l'animazione dopo un breve ritardo
                         setTimeout(() => {
                             if (isPressing) {
                                 this.classList.add('long-press-active');
                             }
                         }, 500); // Inizia l'animazione dopo 0.5 secondi

                         pressTimer = setTimeout(() => {
                             if (isPressing) {
                                 this.classList.remove('long-press-active');
                                 closeOverlayDirectly();
                                 isPressing = false;
                             }
                         }, 3000); // 3 secondi di pressione
                     });

                     // Variabili per gestire i tap su dispositivi touch
                     let touchStartTime = 0;
                     let touchStartX = 0;
                     let touchStartY = 0;

                     // Gestione dell'evento touchstart per dispositivi mobili
                     closeBtn.addEventListener('touchstart', function(e) {
                         // Registra il tempo e la posizione del tocco iniziale
                         touchStartTime = new Date().getTime();
                         if (e.touches && e.touches[0]) {
                             touchStartX = e.touches[0].clientX;
                             touchStartY = e.touches[0].clientY;
                         }

                         // NON preveniamo il comportamento predefinito per permettere il click
                         // Usiamo preventDefault solo per prevenire la selezione del testo
                         if (e.touches && e.touches.length > 1) {
                             e.preventDefault(); // Previeni solo per multi-touch
                         }

                         isPressing = true;

                         // Aggiungi l'animazione dopo un breve ritardo
                         setTimeout(() => {
                             if (isPressing) {
                                 this.classList.add('long-press-active');
                             }
                         }, 500); // Inizia l'animazione dopo 0.5 secondi

                         pressTimer = setTimeout(() => {
                             if (isPressing) {
                                 this.classList.remove('long-press-active');
                                 closeOverlayDirectly();
                                 isPressing = false;
                             }
                         }, 3000); // 3 secondi di pressione
                     }, { passive: false }); // Importante: passive: false permette di usare preventDefault

                     // Cancella il timer se l'utente rilascia il pulsante prima dei 3 secondi
                     closeBtn.addEventListener('mouseup', function() {
                         clearTimeout(pressTimer);
                         isPressing = false;
                         this.classList.remove('long-press-active');
                         // Resettiamo il flag wasLongPress dopo un breve ritardo
                         // per permettere all'evento click di verificare il suo stato
                         setTimeout(() => {
                             wasLongPress = false;
                         }, 100);
                     });

                     closeBtn.addEventListener('mouseleave', function() {
                         clearTimeout(pressTimer);
                         isPressing = false;
                         this.classList.remove('long-press-active');
                     });

                     closeBtn.addEventListener('touchend', function(e) {
                         // Calcola la durata del tocco
                         const touchEndTime = new Date().getTime();
                         const touchDuration = touchEndTime - touchStartTime;

                         // Calcola la distanza del movimento
                         let touchEndX = 0;
                         let touchEndY = 0;
                         if (e.changedTouches && e.changedTouches[0]) {
                             touchEndX = e.changedTouches[0].clientX;
                             touchEndY = e.changedTouches[0].clientY;
                         }
                         const touchDistance = Math.sqrt(
                             Math.pow(touchEndX - touchStartX, 2) +
                             Math.pow(touchEndY - touchStartY, 2)
                         );

                         // Se è un tap rapido (meno di 300ms) e senza movimento significativo (meno di 10px)
                         if (touchDuration < 300 && touchDistance < 10 && !wasLongPress) {
                             console.log("Tap rapido rilevato, simuliamo un click");

                             // Simula un click manualmente
                             if (!isEscaping && !isAudioPlaying) {
                                 // Ferma tutti gli audio prima di iniziare
                                 stopAllAudio();

                                 // Log per debug
                                 console.log("Attivazione comportamento troll da tap - clickCount:", clickCount);

                                 // Riproduci l'audio corrispondente
                                 const audio = audioElements[clickCount];
                                 if (audio) {
                                     // Mostra il messaggio toast con priorità alta
                                     const currentMessage = messages[clickCount];
                                     console.log("Mostrando messaggio:", currentMessage);

                                     // Forziamo la visualizzazione del toast con stile inline
                                     const container = document.getElementById('toast-container');
                                     if (container) {
                                         // Assicuriamoci che il container sia visibile
                                         container.style.zIndex = "10000";
                                     }

                                     // Mostra il toast con durata più lunga
                                     showToast(currentMessage, 'warning', 5000);

                                     // Aggiungi la classe per l'animazione
                                     this.classList.add('escaping');
                                     isEscaping = true;

                                     // Riproduci l'audio
                                     // Funzione per riprodurre l'audio (compatibile con iOS)
                                     const playAudio = (audioElement) => {
                                         // Ferma tutti gli altri audio prima di riprodurre quello nuovo
                                         audioElements.forEach(audioEl => {
                                             if (audioEl && audioEl !== audioElement) {
                                                 try {
                                                     audioEl.pause();
                                                     audioEl.currentTime = 0;
                                                 } catch (e) {
                                                     console.error("Errore nel fermare l'audio:", e);
                                                 }
                                             }
                                         });

                                         // Imposta il volume e riproduci l'audio
                                         audioElement.volume = 1.0;

                                         try {
                                             audioElement.currentTime = 0;
                                         } catch (e) {
                                             console.warn("Impossibile reimpostare currentTime:", e);
                                         }

                                         // Avvia l'audio
                                         const playPromise = audioElement.play();

                                         // Gestisci eventuali errori di riproduzione
                                         if (playPromise !== undefined) {
                                             playPromise.then(() => {
                                                 console.log("Audio riprodotto con successo");
                                             }).catch(error => {
                                                 console.error("Audio playback failed:", error);
                                             });
                                         }
                                     };

                                     playAudio(audio);

                                     // Fai scappare il pulsante
                                     const escapeInterval = setInterval(() => {
                                         escapeTo(this);
                                     }, 300);

                                     // Imposta un flag per indicare che l'audio è in riproduzione
                                     isAudioPlaying = true;

                                     // Durata fissa per ogni audio
                                     const audioDurations = [3000, 3500, 6000, 5000];
                                     const currentDuration = audioDurations[clickCount];

                                     // Ferma l'animazione dopo un tempo fisso
                                     setTimeout(() => {
                                         clearInterval(escapeInterval);
                                         this.classList.remove('escaping');
                                         this.style.animation = 'none';
                                         this.style.transform = 'none';
                                         this.style.transition = 'none';

                                         // Riposiziona il pulsante
                                         const buttonRect = this.getBoundingClientRect();
                                         this.style.position = 'fixed';
                                         this.style.top = buttonRect.top + 'px';
                                         this.style.left = buttonRect.left + 'px';
                                         this.style.right = 'auto';
                                         this.style.boxShadow = 'none';

                                         // Resetta i flag
                                         isEscaping = false;
                                         isAudioPlaying = false;
                                         clickCount++;
                                     }, currentDuration);
                                 }

                                 // Previeni il comportamento predefinito per evitare doppi click
                                 e.preventDefault();
                                 e.stopPropagation();
                             }
                         }

                         // Solo se è stata una pressione prolungata, preveniamo il click successivo
                         if (wasLongPress) {
                             e.preventDefault();
                             e.stopPropagation();
                         }

                         clearTimeout(pressTimer);
                         isPressing = false;
                         this.classList.remove('long-press-active');

                         // Resettiamo il flag wasLongPress dopo un breve ritardo
                         setTimeout(() => {
                             wasLongPress = false;
                         }, 100);
                     }, { passive: false });

                     closeBtn.addEventListener('touchcancel', function(e) {
                         // NON preveniamo il comportamento predefinito per permettere il click
                         clearTimeout(pressTimer);
                         isPressing = false;
                         this.classList.remove('long-press-active');

                         // Resettiamo il flag wasLongPress
                         wasLongPress = false;
                     }, { passive: false });

                     // Funzione per gestire il click sul pulsante
                     closeBtn.addEventListener('click', function(e) {
                         // Log per debug
                         console.log("Evento click rilevato sul pulsante X");

                         // Se c'è stata una pressione prolungata, ignora il click
                         if (wasLongPress) {
                             console.log("Click ignorato perché c'è stata una pressione prolungata");
                             return;
                         }

                         // Se il pulsante sta già scappando o un audio è in riproduzione, ignora il click
                         if (isEscaping || isAudioPlaying) {
                             console.log("Click ignorato perché il pulsante sta già scappando o un audio è in riproduzione");
                             return;
                         }

                         // Log per debug
                         console.log("Attivazione comportamento troll - clickCount:", clickCount);

                         // Ferma tutti gli audio prima di iniziare
                         stopAllAudio();

                         // Se è il quinto click, esegui l'animazione di morte prima di chiudere
                         if (clickCount >= 4) {
                             // Crea un clone del pulsante per l'animazione di morte
                             // Questo evita conflitti con altre classi e stili
                             const buttonRect = this.getBoundingClientRect();
                             const deathButton = document.createElement('div');

                             // Copia lo stile e il contenuto del pulsante originale
                             deathButton.innerHTML = this.innerHTML;
                             deathButton.style.position = 'fixed';
                             deathButton.style.top = buttonRect.top + 'px';
                             deathButton.style.left = buttonRect.left + 'px';
                             deathButton.style.width = buttonRect.width + 'px';
                             deathButton.style.height = buttonRect.height + 'px';
                             deathButton.style.backgroundColor = window.getComputedStyle(this).backgroundColor;
                             deathButton.style.color = window.getComputedStyle(this).color;
                             deathButton.style.borderRadius = window.getComputedStyle(this).borderRadius;
                             deathButton.style.display = 'flex';
                             deathButton.style.alignItems = 'center';
                             deathButton.style.justifyContent = 'center';
                             deathButton.style.zIndex = '10001';

                             // Aggiungi la classe per l'animazione di morte
                             deathButton.classList.add('dying-button');

                             // Aggiungi il pulsante al body
                             document.body.appendChild(deathButton);

                             // Nascondi il pulsante originale
                             this.style.opacity = '0';

                             console.log("Animazione di morte applicata al pulsante clone");

                             // Aggiungi effetti visivi extra (flash dello schermo)
                             const flashEffect = document.createElement('div');
                             flashEffect.style.position = 'fixed';
                             flashEffect.style.top = '0';
                             flashEffect.style.left = '0';
                             flashEffect.style.width = '100%';
                             flashEffect.style.height = '100%';
                             flashEffect.style.backgroundColor = 'white';
                             flashEffect.style.opacity = '0.8';
                             flashEffect.style.zIndex = '9998';
                             flashEffect.style.pointerEvents = 'none';
                             document.body.appendChild(flashEffect);

                             // Rimuovi il flash dopo un breve periodo
                             setTimeout(() => {
                                 if (flashEffect.parentNode) {
                                     flashEffect.parentNode.removeChild(flashEffect);
                                 }
                             }, 100);

                             // Attendi che l'animazione di morte finisca prima di chiudere
                             setTimeout(() => {
                                 const overlay = document.getElementById('superheroOverlay');
                                 if (overlay) {
                                     // Forza la chiusura dell'overlay
                                     overlay.classList.remove('visible');
                                     overlay.style.opacity = "0";
                                     overlay.style.visibility = "hidden";
                                     overlay.style.display = "none";

                                     // Ripristina lo scroll della pagina
                                     document.body.style.overflow = '';

                                     // Mostra il messaggio RIP
                                     showRIPMessage();

                                     console.log("Overlay chiuso con successo dopo il quinto click");

                                     // Tentativo aggiuntivo di riproduzione dell'audio funebre (compatibile con iOS)
                                     setTimeout(() => {
                                         console.log("Tentativo aggiuntivo di riproduzione dell'audio funebre");
                                         const backupAudio = new Audio("https://raw.githubusercontent.com/lyakhu955/ore-pws/main/audio/funeral.mp3");
                                         backupAudio.volume = 1.0;

                                         // Aggiungi attributi per iOS
                                         backupAudio.setAttribute("playsinline", "");
                                         backupAudio.setAttribute("webkit-playsinline", "");

                                         // Su iOS, l'audio può essere riprodotto solo dopo un'interazione dell'utente
                                         const playPromise = backupAudio.play();
                                         if (playPromise !== undefined) {
                                             playPromise.catch(error => {
                                                 console.error("Backup audio playback failed:", error);

                                                 // Tentativo di riproduzione dopo interazione utente
                                                 const playOnUserInteraction = function() {
                                                     backupAudio.play().catch(e => console.error("Still failed:", e));
                                                     document.removeEventListener('click', playOnUserInteraction);
                                                     document.removeEventListener('touchstart', playOnUserInteraction);
                                                 };

                                                 document.addEventListener('click', playOnUserInteraction, { once: true });
                                                 document.addEventListener('touchstart', playOnUserInteraction, { once: true });
                                             });
                                         }
                                     }, 500);
                                 }
                             }, 2000); // Durata dell'animazione di morte

                             return;
                         }

                         // Previeni la propagazione dell'evento
                         e.preventDefault();
                         e.stopPropagation();

                         // Riproduci l'audio corrispondente
                         const audio = audioElements[clickCount];
                         if (audio) {
                             // Mostra il messaggio toast con priorità alta
                             const currentMessage = messages[clickCount];
                             console.log("Mostrando messaggio:", currentMessage);

                             // Forziamo la visualizzazione del toast con stile inline
                             const container = document.getElementById('toast-container');
                             if (container) {
                                 // Assicuriamoci che il container sia visibile
                                 container.style.zIndex = "10000";
                             }

                             // Mostra il toast con durata più lunga
                             showToast(currentMessage, 'warning', 5000);

                             // Aggiungi la classe per l'animazione
                             this.classList.add('escaping');
                             isEscaping = true;

                             // Durata fissa per ogni audio (in millisecondi)
                             // Aumentiamo significativamente le durate per assicurarci che gli audio vengano riprodotti completamente
                             // Il terzo audio è più lungo e ha bisogno di più tempo
                             const audioDurations = [3000, 3500, 6000, 5000];
                             const currentDuration = audioDurations[clickCount];

                             // Funzione per riprodurre l'audio (compatibile con iOS)
                             const playAudio = () => {
                                 // Ferma tutti gli altri audio prima di riprodurre quello nuovo
                                 audioElements.forEach(audioEl => {
                                     if (audioEl && audioEl !== audio) {
                                         try {
                                             audioEl.pause();
                                             audioEl.currentTime = 0;
                                         } catch (e) {
                                             console.error("Errore nel fermare l'audio:", e);
                                         }
                                     }
                                 });

                                 // Imposta il volume e riproduci l'audio
                                 audio.volume = 1.0;

                                 try {
                                     audio.currentTime = 0;
                                 } catch (e) {
                                     console.warn("Impossibile reimpostare currentTime:", e);
                                 }

                                 // Avvia l'audio
                                 const playPromise = audio.play();

                                 // Gestisci eventuali errori di riproduzione
                                 if (playPromise !== undefined) {
                                     playPromise.then(() => {
                                         console.log("Audio riprodotto con successo");
                                         isAudioPlaying = true;
                                     }).catch(error => {
                                         console.error("Audio playback failed:", error);

                                         // Su iOS, l'audio può essere riprodotto solo dopo un'interazione dell'utente
                                         if (isIOS) {
                                             const playOnUserInteraction = function() {
                                                 audio.play()
                                                     .then(() => {
                                                         console.log("Audio riprodotto dopo interazione utente");
                                                         isAudioPlaying = true;
                                                     })
                                                     .catch(e => console.error("Ancora errori nella riproduzione:", e));

                                                 document.removeEventListener('click', playOnUserInteraction);
                                                 document.removeEventListener('touchstart', playOnUserInteraction);
                                             };

                                             document.addEventListener('click', playOnUserInteraction, { once: true });
                                             document.addEventListener('touchstart', playOnUserInteraction, { once: true });
                                         }
                                     });
                                 }
                             };

                             // Verifica se l'audio è pronto per essere riprodotto
                             if (audio.readyState >= 2) { // HAVE_CURRENT_DATA o superiore
                                 playAudio();
                             } else {
                                 // Se l'audio non è ancora caricato, aggiungiamo un listener
                                 audio.addEventListener('canplaythrough', function playWhenReady() {
                                     playAudio();
                                     // Rimuovi il listener dopo l'uso
                                     audio.removeEventListener('canplaythrough', playWhenReady);
                                 });

                                 // Forza il caricamento
                                 audio.load();
                             }

                             // Fai scappare il pulsante per un tempo fisso ma con velocità maggiore
                             const escapeInterval = setInterval(() => {
                                 escapeTo(this);
                             }, 300); // Cambia posizione ogni 300ms per un movimento più frenetico

                             // Imposta un flag per indicare che l'audio è in riproduzione
                             isAudioPlaying = true;

                             // Ferma l'animazione dopo un tempo fisso invece di aspettare l'evento onended
                             setTimeout(() => {
                                 // Ferma completamente tutte le animazioni
                                 clearInterval(escapeInterval);
                                 this.classList.remove('escaping');

                                 // Rimuovi tutti gli stili inline che potrebbero causare movimenti
                                 this.style.animation = 'none';
                                 this.style.transform = 'none';
                                 this.style.transition = 'none';

                                 // Riposiziona il pulsante in una posizione fissa
                                 const buttonRect = this.getBoundingClientRect();
                                 this.style.position = 'fixed';
                                 this.style.top = buttonRect.top + 'px';
                                 this.style.left = buttonRect.left + 'px';
                                 this.style.right = 'auto';
                                 this.style.boxShadow = 'none';

                                 // Resetta i flag
                                 isEscaping = false;
                                 isAudioPlaying = false;
                                 clickCount++;

                                 // Non ripristinare lo stile originale, mantieni la posizione attuale

                                 // Non mostrare messaggi aggiuntivi quando il pulsante smette di scappare
                             }, currentDuration);
                         } else {
                             // Fallback se l'audio non è disponibile
                             const currentMessage = messages[clickCount];
                             console.log("Mostrando messaggio (fallback):", currentMessage);

                             // Forziamo la visualizzazione del toast con stile inline
                             const container = document.getElementById('toast-container');
                             if (container) {
                                 // Assicuriamoci che il container sia visibile
                                 container.style.zIndex = "10000";
                             }

                             // Mostra il toast con durata più lunga
                             showToast(currentMessage, 'warning', 5000);

                             // Simula un breve movimento del pulsante
                             this.classList.add('escaping');
                             isEscaping = true;

                             // Imposta un flag per indicare che l'audio è in riproduzione
                             isAudioPlaying = true;

                             setTimeout(() => {
                                 // Ferma completamente tutte le animazioni
                                 this.classList.remove('escaping');

                                 // Rimuovi tutti gli stili inline che potrebbero causare movimenti
                                 this.style.animation = 'none';
                                 this.style.transform = 'none';
                                 this.style.transition = 'none';

                                 // Riposiziona il pulsante in una posizione fissa
                                 const buttonRect = this.getBoundingClientRect();
                                 this.style.position = 'fixed';
                                 this.style.top = buttonRect.top + 'px';
                                 this.style.left = buttonRect.left + 'px';
                                 this.style.right = 'auto';
                                 this.style.boxShadow = 'none';

                                 // Resetta i flag
                                 isEscaping = false;
                                 isAudioPlaying = false;
                                 clickCount++;

                                 // Non ripristinare lo stile originale, mantieni la posizione attuale
                             }, 2000);
                         }
                     });

                     // Chiudi anche quando si clicca fuori dall'immagine (ma dentro l'overlay)
                     const superheroOverlay = document.getElementById('superheroOverlay');
                     if (superheroOverlay) {
                         superheroOverlay.addEventListener('click', function(e) {
                             // Chiudi solo se il click è sull'overlay e non sull'immagine o sul pulsante
                             if (e.target === this && clickCount >= 4) {
                                 // Forza la chiusura dell'overlay
                                 this.classList.remove('visible');
                                 this.style.opacity = "0";
                                 this.style.visibility = "hidden";
                                 this.style.display = "none";
                                 document.body.style.overflow = '';
                                 showRIPMessage();
                                 console.log("Overlay chiuso con successo dopo click sull'overlay");
                             } else if (e.target === this) {
                                 showToast("Devi prima cliccare sul pulsante X!", 'info');
                             }
                         });
                     }
                 }
             }

             // Nota: L'inizializzazione del tema scuro è già gestita nel DOMContentLoaded
             // Questo blocco è stato rimosso per evitare duplicazioni




             // Inizializza il Gratta e Vinci
             setTimeout(() => {
                 console.log("Inizializzazione ritardata del Gratta e Vinci...");

                 // Inizializzazione del Gratta e Vinci realistico
                 const scratchCardBtn = document.getElementById('scratchCardBtn');
                 const scratchCardOverlay = document.getElementById('scratchCardOverlay');
                 const canvas = document.getElementById('scratchCanvas');
                 const closeScratchCard = document.getElementById('closeScratchCard');

                 console.log("Elementi trovati:", {
                     scratchCardBtn: !!scratchCardBtn,
                     scratchCardOverlay: !!scratchCardOverlay,
                     canvas: !!canvas,
                     closeScratchCard: !!closeScratchCard
                 });

                 if (scratchCardBtn && scratchCardOverlay && canvas) {
                     // Apri il Gratta e Vinci quando si clicca sul pulsante
                     scratchCardBtn.onclick = function() {
                         console.log("Pulsante Gratta e Vinci cliccato");
                         scratchCardOverlay.classList.add('visible');
                         document.body.style.overflow = 'hidden'; // Blocca lo scroll

                         // Assicurati che il canvas sia visibile
                         canvas.style.opacity = '1';
                         canvas.style.display = 'block';

                         // Inizializza il canvas per il grattamento
                         initScratchCanvas();
                     };

                     // Chiudi il Gratta e Vinci quando si clicca sul pulsante di chiusura
                     if (closeScratchCard) {
                         closeScratchCard.onclick = function() {
                             console.log("Pulsante di chiusura Gratta e Vinci cliccato");
                             scratchCardOverlay.classList.remove('visible');
                             document.body.style.overflow = ''; // Ripristina lo scroll

                             // Reset del canvas per la prossima apertura
                             // Rimuoviamo il canvas esistente
                             if (canvas) {
                                 // Ripristina la visualizzazione del canvas
                                 canvas.style.opacity = '1';
                                 canvas.style.display = 'block';
                             }
                         };
                     }

                     // Funzione per inizializzare il canvas per il grattamento
                     function initScratchCanvas() {
                         console.log("Inizializzazione canvas per grattamento");

                         // Variabile per tenere traccia se il dispositivo è iOS
                         const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                         console.log("Rilevato dispositivo iOS:", isIOS);

                         // Crea un effetto sonoro per il grattamento (compatibile con iOS)
                         let scratchSound = null;
                         let audioEnabled = false;

                         // Su iOS, l'audio Web Audio API potrebbe non funzionare bene
                         // Utilizziamo un approccio più semplice e compatibile
                         if (isIOS) {
                             console.log("Utilizzo modalità audio compatibile per iOS");
                             // Non utilizziamo l'audio per il grattamento su iOS per evitare problemi
                             audioEnabled = false;
                         } else {
                             try {
                                 // Crea un oscillatore per simulare il suono del grattamento
                                 const audioContext = new (window.AudioContext || window.webkitAudioContext)();

                                 // Funzione per creare un suono di grattamento
                                 function createScratchSound() {
                                     try {
                                         // Crea un oscillatore con rumore bianco
                                         const noise = audioContext.createBufferSource();
                                         const bufferSize = audioContext.sampleRate * 0.5; // mezzo secondo di rumore
                                         const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                                         const data = buffer.getChannelData(0);

                                         // Riempi il buffer con rumore bianco
                                         for (let i = 0; i < bufferSize; i++) {
                                             data[i] = Math.random() * 2 - 1;
                                         }

                                         noise.buffer = buffer;

                                         // Crea un filtro per modellare il suono
                                         const filter = audioContext.createBiquadFilter();
                                         filter.type = 'bandpass';
                                         filter.frequency.value = 2000;
                                         filter.Q.value = 1;

                                         // Crea un gain node per controllare il volume
                                         const gainNode = audioContext.createGain();
                                         gainNode.gain.value = 0.03; // Volume molto basso

                                         // Collega i nodi
                                         noise.connect(filter);
                                         filter.connect(gainNode);
                                         gainNode.connect(audioContext.destination);

                                         return {
                                             play: function() {
                                                 try {
                                                     noise.start();
                                                 } catch (e) {
                                                     console.log("Errore nell'avvio del suono:", e);
                                                 }
                                             },
                                             stop: function() {
                                                 try {
                                                     noise.stop();
                                                 } catch (e) {
                                                     console.log("Errore nel fermare il suono:", e);
                                                 }
                                             }
                                         };
                                     } catch (e) {
                                         console.log("Errore nella creazione del suono:", e);
                                         return null;
                                     }
                                 }

                                 scratchSound = createScratchSound();
                                 audioEnabled = scratchSound !== null;
                             } catch (e) {
                                 console.log("Audio non supportato:", e);
                                 audioEnabled = false;
                             }
                         }

                         // Rimuovi eventuali event listener precedenti
                         canvas.removeEventListener('mousedown', startDrawing);
                         canvas.removeEventListener('mousemove', scratch);
                         canvas.removeEventListener('mouseup', stopDrawing);
                         canvas.removeEventListener('mouseleave', stopDrawing);
                         canvas.removeEventListener('touchstart', startDrawing);
                         canvas.removeEventListener('touchmove', scratch);
                         canvas.removeEventListener('touchend', stopDrawing);

                         // Ottieni il contenitore del gratta e vinci
                         const container = canvas.parentElement;

                         // Imposta le dimensioni del canvas
                         canvas.width = container.offsetWidth;
                         canvas.height = container.offsetHeight;

                         // Ottieni il contesto 2D del canvas
                         const ctx = canvas.getContext('2d');

                         // Crea un gradiente dorato per il gratta e vinci
                         const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                         gradient.addColorStop(0, '#DFBD69'); // Oro chiaro
                         gradient.addColorStop(1, '#926F34'); // Oro scuro

                         // Riempi il canvas con il gradiente
                         ctx.fillStyle = gradient;
                         ctx.fillRect(0, 0, canvas.width, canvas.height);

                         // Aggiungi una texture per rendere più realistico il grattamento
                         // Crea un pattern di piccoli punti casuali
                         for (let i = 0; i < canvas.width; i += 4) {
                             for (let j = 0; j < canvas.height; j += 4) {
                                 if (Math.random() > 0.5) {
                                     ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                                     ctx.fillRect(i, j, 2, 2);
                                 }
                             }
                         }

                         // Aggiungi testo "GRATTA QUI"
                         ctx.font = 'bold 24px Arial';
                         ctx.fillStyle = '#333';
                         ctx.textAlign = 'center';
                         ctx.textBaseline = 'middle';
                         ctx.fillText('GRATTA QUI', canvas.width / 2, canvas.height / 2);

                         // Aggiungi il logo PWS
                         ctx.font = 'bold 14px Arial';
                         ctx.fillStyle = '#333';
                         ctx.fillText('PWS', canvas.width / 2, 30);

                         // Aggiungi decorazioni
                         for (let i = 0; i < 20; i++) {
                             const x = Math.random() * canvas.width;
                             const y = Math.random() * canvas.height;
                             const size = Math.random() * 5 + 2;

                             ctx.beginPath();
                             ctx.arc(x, y, size, 0, Math.PI * 2);
                             ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                             ctx.fill();
                         }

                         // Variabili per il grattamento
                         let isDrawing = false;
                         let scratchedPercentage = 0;
                         let scratchedPixels = 0;
                         const totalPixels = canvas.width * canvas.height;

                         // Variabili per tracciare la posizione precedente
                         let lastX = 0;
                         let lastY = 0;

                         // Funzione per grattare - ottimizzata per iOS
                         function scratch(e) {
                             if (!isDrawing) return;

                             // Previeni il comportamento predefinito (come lo scroll)
                             e.preventDefault();

                             // Ottieni la posizione del mouse/touch relativa al canvas
                             const rect = canvas.getBoundingClientRect();
                             let x, y;

                             // Gestione speciale per eventi touch (importante per iOS)
                             if (e.type.includes('touch')) {
                                 // Previeni esplicitamente lo scroll su iOS
                                 e.stopPropagation();

                                 // Su iOS, dobbiamo essere più precisi nell'ottenere le coordinate touch
                                 const touch = e.touches[0] || e.changedTouches[0];
                                 if (!touch) {
                                     console.log("Nessun punto di contatto trovato nell'evento touch");
                                     return;
                                 }

                                 // Calcola le coordinate relative al canvas
                                 x = touch.clientX - rect.left;
                                 y = touch.clientY - rect.top;

                                 // Verifica che le coordinate siano all'interno del canvas
                                 if (x < 0 || x > canvas.width || y < 0 || y > canvas.height) {
                                     console.log("Touch fuori dal canvas:", x, y);
                                     return;
                                 }
                             } else {
                                 // Gestione standard per mouse
                                 x = e.clientX - rect.left;
                                 y = e.clientY - rect.top;
                             }

                             // Imposta l'operazione di composizione per "cancellare" il canvas
                             // Questo deve essere fatto prima di ogni operazione di disegno
                             ctx.globalCompositeOperation = 'destination-out';

                             // Se abbiamo una posizione precedente, disegniamo una linea tra i punti
                             // per evitare "buchi" nel grattamento quando si muove velocemente
                             if (lastX && lastY && (Math.abs(x - lastX) > 5 || Math.abs(y - lastY) > 5)) {
                                 // Calcola quanti punti intermedi disegnare in base alla distanza
                                 const distance = Math.sqrt(Math.pow(x - lastX, 2) + Math.pow(y - lastY, 2));
                                 const steps = Math.ceil(distance / 5); // Un punto ogni 5 pixel

                                 for (let i = 1; i < steps; i++) {
                                     const stepX = lastX + (x - lastX) * (i / steps);
                                     const stepY = lastY + (y - lastY) * (i / steps);

                                     // Disegna un cerchio in questa posizione intermedia
                                     ctx.beginPath();
                                     ctx.arc(stepX, stepY, 12, 0, Math.PI * 2, false);
                                     ctx.fill();

                                     // Aggiorna la percentuale grattata
                                     scratchedPixels += Math.PI * 12 * 12 * 0.3;
                                 }
                             }

                             // Aggiorna l'ultima posizione
                             lastX = x;
                             lastY = y;

                             // Disegna un cerchio di dimensione media per simulare il grattamento
                             // Abbastanza grande da essere visibile ma non troppo per mantenere la sfida
                             const radius = 12;
                             ctx.beginPath();
                             ctx.arc(x, y, radius, 0, Math.PI * 2, false);
                             ctx.fill();

                             // Aggiorna la percentuale grattata (approssimazione)
                             // Usiamo un valore molto piccolo per rendere il grattamento più lungo
                             scratchedPixels += Math.PI * radius * radius * 0.3;
                             scratchedPercentage = (scratchedPixels / totalPixels) * 100;

                             // Limita la percentuale massima al 100%
                             scratchedPercentage = Math.min(scratchedPercentage, 100);

                             console.log("Percentuale grattata:", scratchedPercentage.toFixed(2) + "%");

                             // Mostra la percentuale sul canvas
                             // Salva lo stato corrente del contesto
                             ctx.save();
                             // Ripristina l'operazione di composizione normale
                             ctx.globalCompositeOperation = 'source-over';
                             // Disegna un rettangolo semi-trasparente in basso a destra
                             ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                             ctx.fillRect(canvas.width - 60, canvas.height - 30, 60, 30);
                             // Disegna la percentuale
                             ctx.fillStyle = 'white';
                             ctx.font = '12px Arial';
                             ctx.textAlign = 'center';
                             ctx.fillText(Math.floor(scratchedPercentage) + '%', canvas.width - 30, canvas.height - 15);
                             // Ripristina lo stato precedente
                             ctx.restore();

                             // Se è stato grattato abbastanza (95%), rivela completamente il contenuto
                             if (scratchedPercentage > 95) {
                                 console.log("Grattamento completato!");
                                 // Rimuovi il canvas con una transizione
                                 canvas.style.opacity = '0';
                                 setTimeout(() => {
                                     canvas.style.display = 'none';
                                 }, 500);

                                 // Rimuovi gli event listener
                                 canvas.removeEventListener('mousedown', startDrawing);
                                 canvas.removeEventListener('mousemove', scratch);
                                 canvas.removeEventListener('mouseup', stopDrawing);
                                 canvas.removeEventListener('mouseleave', stopDrawing);
                                 canvas.removeEventListener('touchstart', startDrawing);
                                 canvas.removeEventListener('touchmove', scratch);
                                 canvas.removeEventListener('touchend', stopDrawing);
                             }
                         }

                         // Funzioni per gestire l'inizio e la fine del grattamento
                         function startDrawing(e) {
                             isDrawing = true;
                             // Resetta le coordinate precedenti quando si inizia un nuovo tratto
                             // per evitare di collegare tratti separati
                             lastX = 0;
                             lastY = 0;

                             // Avvia il suono di grattamento solo se non siamo su iOS
                             if (audioEnabled && scratchSound) {
                                 try {
                                     scratchSound.play();
                                 } catch (e) {
                                     console.log("Errore nell'avvio del suono:", e);
                                 }
                             }

                             scratch(e);
                         }

                         function stopDrawing() {
                             isDrawing = false;
                             // Resetta le coordinate precedenti quando si finisce un tratto
                             lastX = 0;
                             lastY = 0;

                             // Ferma il suono di grattamento solo se non siamo su iOS
                             if (audioEnabled && scratchSound) {
                                 try {
                                     scratchSound.stop();
                                     // Ricrea il suono per il prossimo grattamento
                                     if (typeof createScratchSound === 'function') {
                                         scratchSound = createScratchSound();
                                     }
                                 } catch (e) {
                                     console.log("Errore nel fermare il suono:", e);
                                 }
                             }
                         }

                         // Aggiungi gli event listener per il grattamento
                         canvas.addEventListener('mousedown', startDrawing);
                         canvas.addEventListener('mousemove', scratch);
                         canvas.addEventListener('mouseup', stopDrawing);
                         canvas.addEventListener('mouseleave', stopDrawing);

                         // Supporto per dispositivi touch (ottimizzato per iOS)
                         canvas.addEventListener('touchstart', startDrawing, { passive: false });
                         canvas.addEventListener('touchmove', scratch, { passive: false });
                         canvas.addEventListener('touchend', stopDrawing, { passive: false });
                         canvas.addEventListener('touchcancel', stopDrawing, { passive: false });

                         // Previeni lo scroll della pagina quando si interagisce con il canvas su iOS
                         function preventScroll(e) {
                             e.preventDefault();
                             e.stopPropagation();
                         }

                         // Aggiungi questi listener al contenitore del canvas per iOS
                         // Riutilizziamo la variabile container già dichiarata sopra
                         if (container) {
                             container.addEventListener('touchstart', preventScroll, { passive: false });
                             container.addEventListener('touchmove', preventScroll, { passive: false });
                         }
                     }
                 }
             }, 1000);

             // Fine inizializzazione
         });

    </script>

    <!-- Script per la gestione del backup cloud -->
    <script>
        // Carica le API di Google (nuova versione con Google Identity Services)
        function loadGoogleApi() {
            return new Promise((resolve, reject) => {
                console.log('Avvio caricamento delle API Google...');

                // Verifica se le API sono già caricate
                if (window.gapi && window.google && window.google.accounts) {
                    console.log('API Google già caricate, inizializzazione...');
                    initializeGoogleApis()
                        .then(resolve)
                        .catch(reject);
                    return;
                }

                // Carica prima lo script di Google Identity Services
                const gisScript = document.createElement('script');
                gisScript.src = 'https://accounts.google.com/gsi/client';
                gisScript.async = true;
                gisScript.defer = true;
                gisScript.onload = () => {
                    console.log('Google Identity Services caricato');

                    // Poi carica l'API client per Google Drive
                    const gapiScript = document.createElement('script');
                    gapiScript.src = 'https://apis.google.com/js/api.js';
                    gapiScript.onload = () => {
                       console.log('Google API client caricato, inizializzazione...');
                        initializeGoogleApis()
                            .then(resolve)
                            .catch(reject);
                    };
                    gapiScript.onerror = () => {
                        console.error('Impossibile caricare lo script delle API di Google');
                        reject(new Error('Impossibile caricare le API di Google'));
                    };
                    document.head.appendChild(gapiScript);
                };
                gisScript.onerror = () => {
                    console.error('Impossibile caricare Google Identity Services');
                    reject(new Error('Impossibile caricare Google Identity Services'));
                };
                document.head.appendChild(gisScript);
            });
        }

        // Funzione separata per inizializzare le API Google
        async function initializeGoogleApis() {
            return new Promise((resolve, reject) => {
                gapi.load('client', async () => {
                    try {
                        console.log('Inizializzazione del client Google API...');

                         await gapi.client.init({
                            discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest']
                        });

                        console.log('Google API client inizializzato con successo');

                        // Configura Google Identity Services
                        window.googleAuthClient = google.accounts.oauth2.initTokenClient({
                            client_id: '990017681774-kmghq0vajmb8lbv7gqv2qsi7fn1rbp4f.apps.googleusercontent.com',
                            scope: 'https://www.googleapis.com/auth/drive openid profile email',
                            prompt: 'consent',  // Mostra sempre il consenso per garantire il refresh token
                            auto_select: false,  // Lascia che l'utente scelga l'account
                            // Richiedi un token con scadenza più lunga (massimo consentito)
                            access_type: 'offline',  // Richiedi un refresh token
                            include_granted_scopes: true,  // Include tutti gli scope già concessi
                            callback: (tokenResponse) => {
                                if (tokenResponse && tokenResponse.access_token) {
                                    // Imposta il token di accesso per le richieste API
                                    gapi.client.setToken(tokenResponse);
                                    console.log('Token di accesso ottenuto con successo');
                                }
                            },
                            error_callback: (error) => {
                                console.error('Errore durante l\'autenticazione:', error);
                            }
                        });

                        console.log('Client di autenticazione Google inizializzato con successo');
                        resolve();
                   } catch (error) {
                        console.error('Errore nell\'inizializzazione delle Google API:', error);
                        reject(error);
                     }
                });
            });
        }

        // Funzione per caricare le API Google Identity Services
        function loadGoogleIdentityServices() {
            return new Promise((resolve, reject) => {
                console.log('Caricamento delle API Google Identity Services...');

                // Verifica se le API sono già caricate
                if (window.google && window.google.accounts && window.google.accounts.oauth2) {
                    console.log('API Google Identity Services già caricate');
                    resolve();
                    return;
                }

                // Carica le API Google Identity Services
                const gisScript = document.createElement('script');
                gisScript.src = 'https://accounts.google.com/gsi/client';
                gisScript.async = true;
                gisScript.defer = true;
                gisScript.onload = () => {
                    console.log('API Google Identity Services caricate con successo');
                    resolve();
                };
                gisScript.onerror = (error) => {
                    console.error('Impossibile caricare le API Google Identity Services:', error);
                    reject(new Error('Impossibile caricare le API Google Identity Services'));
                };

                document.head.appendChild(gisScript);
            });
        }

        // Funzione per inizializzare il client di autenticazione Google
        async function initGoogleAuth() {
            return new Promise((resolve, reject) => {
                try {
                    if (!window.google || !window.google.accounts || !window.google.accounts.oauth2) {
                        reject(new Error('Google Identity Services non disponibili'));
                        return;
                    }

                    // Configura Google Identity Services
                    window.googleAuthClient = google.accounts.oauth2.initTokenClient({
                        client_id: '990017681774-kmghq0vajmb8lbv7gqv2qsi7fn1rbp4f.apps.googleusercontent.com',
                        scope: 'https://www.googleapis.com/auth/drive openid profile email',
                        prompt: 'consent',  // Mostra sempre il consenso per garantire il refresh token
                        auto_select: false,  // Lascia che l'utente scelga l'account
                        // Richiedi un token con scadenza più lunga (massimo consentito)
                        access_type: 'offline',  // Richiedi un refresh token
                        include_granted_scopes: true,  // Include tutti gli scope già concessi
                        callback: (tokenResponse) => {
                            if (tokenResponse && tokenResponse.access_token) {
                                // Imposta il token di accesso per le richieste API
                                gapi.client.setToken(tokenResponse);
                                console.log('Token di accesso ottenuto con successo');
                            }
                        },
                        error_callback: (error) => {
                            console.error('Errore durante l\'autenticazione:', error);
                        }
                    });

                    console.log('Client di autenticazione Google inizializzato con successo');
                    resolve();
                } catch (error) {
                    console.error('Errore nell\'inizializzazione del client di autenticazione Google:', error);
                    reject(error);
                }
            });
        }

        // Carica le API di Microsoft
        function loadMicrosoftApi() {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://alcdn.msauth.net/browser/2.30.0/js/msal-browser.min.js';
                script.onload = () => {
                    resolve();
                };
                script.onerror = () => reject(new Error('Impossibile caricare le API di Microsoft'));
                document.head.appendChild(script);
            });
        }

        // Carica le API di Apple
        function loadAppleApi() {
            return new Promise((resolve, reject) => {
                // Apple Sign In JS non è disponibile come CDN pubblico
                // In una implementazione reale, dovresti utilizzare il Sign in with Apple JS
                // https://developer.apple.com/documentation/sign_in_with_apple/sign_in_with_apple_js
                resolve();
            });
        }

        // Classe base per tutti i provider cloud
        class CloudProvider {
            constructor(name, logoUrl) {
                this.name = name;
                this.logoUrl = logoUrl;
                this.isLoggedIn = false;
                this.userData = null;
            }

            // Metodi che ogni provider deve implementare
            async login() { throw new Error("Non implementato"); }
            async logout() { throw new Error("Non implementato"); }
            async backup(data, showLoginPrompt = true) { throw new Error("Non implementato"); }
            async restore() { throw new Error("Non implementato"); }

            // Metodi comuni a tutti i provider
            getUserInfo() {
                return this.userData;
            }
        }

        // Implementazione per Google Drive (reale) con Google Identity Services
        class GoogleDriveProvider extends CloudProvider {
            constructor() {
                // Utilizziamo un'icona Material invece dell'URL esterno
                super("Google Drive", "");
                this.iconClass = "material-symbols-outlined";
                this.iconName = "cloud";
                this.iconColor = "#4285F4"; // Colore blu di Google
                this.apiLoaded = false;
                this.backupFileName = 'Ore PWS - Backup Dati.json';
                this.accessToken = null;
                this.tokenExpiry = null;
                this.tokenRefreshTimer = null; // Timer per il rinnovo automatico del token
            }

            async ensureApiLoaded() {
                if (!this.apiLoaded) {
                    try {
                        await loadGoogleApi();
                        this.apiLoaded = true;
                        console.log('API Google caricate con successo');
                    } catch (error) {
                        console.error('Errore nel caricamento delle API Google:', error);
                        throw new Error(`Impossibile caricare le API Google: ${error.message}`);
                    }
                }
            }

            // Verifica se l'utente è già autenticato
            async checkAuthStatus() {
                try {
                    await this.ensureApiLoaded();

                    // Verifica se abbiamo un token valido
                    const token = gapi.client.getToken();

                    // Verifica se abbiamo un token salvato in localStorage
                    const savedToken = localStorage.getItem('googleAuthToken');
                    const tokenExpiry = localStorage.getItem('googleTokenExpiry');

                    // Verifica se il token è scaduto
                    let isTokenExpired = false;
                    if (tokenExpiry) {
                        const expiryTime = parseInt(tokenExpiry, 10);
                        // Considera il token scaduto se mancano meno di 5 minuti alla scadenza
                        isTokenExpired = Date.now() > (expiryTime - (5 * 60 * 1000));

                        if (isTokenExpired) {
                            console.log('Token scaduto o in scadenza, necessario refresh');
                        } else {
                            console.log(`Token valido fino a: ${new Date(expiryTime).toLocaleString()}`);
                        }
                    }

                    // Se non abbiamo un token attivo ma abbiamo un token salvato, proviamo a usarlo
                    if ((!token || !token.access_token || isTokenExpired) && savedToken) {
                        try {
                            console.log('Trovato token salvato, tentativo di ripristino sessione...');
                            const parsedToken = JSON.parse(savedToken);

                            // Se il token è scaduto, tentiamo un refresh
                            if (isTokenExpired) {
                                console.log('Tentativo di refresh del token scaduto...');
                                try {
                                    // Imposta temporaneamente il token per poter fare il refresh
                                    gapi.client.setToken(parsedToken);
                                    await this.refreshToken();
                                    console.log('Token refreshato con successo');
                                    return true; // Il refresh ha già impostato tutto
                                } catch (refreshError) {
                                    console.warn('Errore nel refresh del token:', refreshError);
                                    // Continua con il flusso normale
                                }
                            } else {
                                // Imposta il token salvato
                                gapi.client.setToken(parsedToken);
                                console.log('Token ripristinato da localStorage');
                            }
                        } catch (e) {
                            console.warn('Errore nel ripristino del token da localStorage:', e);
                            localStorage.removeItem('googleAuthToken');
                            localStorage.removeItem('googleTokenExpiry');
                        }
                    }

                    // Ottieni il token aggiornato (potrebbe essere quello appena ripristinato)
                    const currentToken = gapi.client.getToken();

                    if (currentToken && currentToken.access_token) {
                        // Ottieni informazioni sull'utente
                        try {
                            const response = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
                                headers: {
                                    'Authorization': `Bearer ${currentToken.access_token}`
                                }
                            });

                            if (response.ok) {
                                const userInfo = await response.json();

                                this.isLoggedIn = true;
                                this.userData = {
                                    id: userInfo.sub,
                                    name: userInfo.name,
                                    email: userInfo.email,
                                    picture: userInfo.picture,
                                    provider: "google"
                                };

                                // Salva i dati utente
                                localStorage.setItem('cloudUserData', JSON.stringify(this.userData));

                                // Salva il token aggiornato
                                localStorage.setItem('googleAuthToken', JSON.stringify(currentToken));

                                // Imposta il rinnovo automatico del token
                                this.setupTokenRefresh(currentToken);

                                console.log('Utente autenticato con Google:', this.userData.email);
                                return true;
                            } else {
                                // Token non valido o scaduto
                                console.warn('Token non valido o scaduto, status:', response.status);

                                // Se il token è scaduto (401), proviamo a rinnovarlo
                                if (response.status === 401) {
                                    console.log('Token scaduto, tentativo di rinnovo...');
                                    try {
                                        await this.refreshToken();
                                        // Riprova la verifica dopo il refresh
                                        return this.checkAuthStatus();
                                    } catch (refreshError) {
                                        console.error('Impossibile rinnovare il token:', refreshError);
                                        // Pulisci i token salvati
                                        localStorage.removeItem('googleAuthToken');
                                        gapi.client.setToken(null);
                                    }
                                }
                            }
                        } catch (error) {
                            console.warn('Errore nel recupero delle informazioni utente:', error);
                            // Pulisci i token salvati in caso di errore
                            if (error.message.includes('401') || error.message.includes('403')) {
                                localStorage.removeItem('googleAuthToken');
                                gapi.client.setToken(null);
                            }
                        }
                    }

                    return false;
                } catch (error) {
                    console.warn('Errore durante la verifica dello stato di autenticazione Google:', error);
                    return false;
                }
            }

            // Metodo per impostare il rinnovo automatico del token
            setupTokenRefresh(tokenResponse) {
                // Cancella eventuali timer esistenti
                if (this.tokenRefreshTimer) {
                    clearTimeout(this.tokenRefreshTimer);
                }

                // Se non abbiamo un token valido, non fare nulla
                if (!tokenResponse || !tokenResponse.access_token) {
                    return;
                }

                // Salva la data di scadenza del token
                const expiresIn = tokenResponse.expires_in || 3600;
                const expiryTime = Date.now() + (expiresIn * 1000);

                // Salva la data di scadenza in localStorage
                localStorage.setItem('googleTokenExpiry', expiryTime.toString());

                // Calcola quando tentare il rinnovo automatico (10 minuti prima della scadenza)
                const refreshTime = (expiresIn - 600) * 1000; // Converti in millisecondi e sottrai 10 minuti

                // Assicurati che il tempo di rinnovo sia almeno 5 minuti (per evitare rinnovi troppo frequenti)
                const minRefreshTime = 5 * 60 * 1000; // 5 minuti in millisecondi
                const actualRefreshTime = Math.max(refreshTime, minRefreshTime);

                console.log(`Token valido per ${expiresIn} secondi. Programmato rinnovo automatico tra ${actualRefreshTime/1000} secondi.`);
                console.log(`Token scadrà il: ${new Date(expiryTime).toLocaleString()}`);

                // Imposta il timer per il rinnovo automatico del token
                this.tokenRefreshTimer = setTimeout(async () => {
                    console.log('Token in scadenza, tentativo di rinnovo automatico...');

                    try {
                        // Tenta il rinnovo silenzioso del token
                        await this.silentRefreshToken();
                        console.log('Token rinnovato automaticamente con successo');

                        // Mostra un messaggio solo se l'utente è attivo sulla pagina
                        if (document.visibilityState === 'visible') {
                            showToast("Sessione Google rinnovata automaticamente", "success", 2000);
                        }
                    } catch (error) {
                        console.error('Errore durante il rinnovo automatico del token:', error);

                        // Se il rinnovo silenzioso fallisce, mostra un messaggio all'utente solo se è attivo sulla pagina
                        if (document.visibilityState === 'visible') {
                            // Funzione per gestire il rinnovo manuale del token
                            const handleManualTokenRenewal = async () => {
                                try {
                                    await this.refreshToken();
                                    showToast("Sessione Google rinnovata con successo", "success", 3000);
                                    console.log('Token rinnovato con successo');
                                } catch (refreshError) {
                                    console.error('Errore durante il rinnovo manuale del token:', refreshError);
                                    showToast("Impossibile rinnovare la sessione. Prova ad effettuare nuovamente l'accesso.", "error", 5000);
                                }
                            };

                            showToast("Impossibile rinnovare automaticamente la sessione Google. Clicca su 'Rinnova' per continuare a utilizzare le funzionalità di backup.", "warning", 0, [
                                {
                                    text: "Rinnova",
                                    onClick: handleManualTokenRenewal
                                },
                                {
                                    text: "Ignora",
                                    onClick: () => {
                                        showToast("La sessione scadrà a breve. Alcune funzionalità potrebbero non essere disponibili.", "info", 3000);
                                    }
                                }
                            ]);
                        }
                    }
                }, actualRefreshTime);
            }

            // Metodo per il rinnovo silenzioso del token senza interazione dell'utente
            async silentRefreshToken() {
                return new Promise((resolve, reject) => {
                    console.log('Avvio procedura di rinnovo silenzioso del token...');

                    // Salva il token corrente prima di tentare il refresh
                    const currentToken = gapi.client.getToken();

                    // Verifica se abbiamo un client di autenticazione Google
                    if (!window.googleAuthClient) {
                        console.error('Client di autenticazione Google non disponibile per il rinnovo silenzioso');
                        reject(new Error('Client di autenticazione Google non disponibile'));
                        return;
                    }

                    // Configura il callback per il refresh del token
                    const originalCallback = window.googleAuthClient.callback;

                    // Imposta un timeout più breve per il rinnovo silenzioso (10 secondi)
                    let timeoutId = setTimeout(() => {
                        console.warn('Timeout durante il rinnovo silenzioso del token');

                        // Ripristina il callback originale
                        window.googleAuthClient.callback = originalCallback;

                        // Se il rinnovo silenzioso fallisce, manteniamo il token corrente
                        if (currentToken && currentToken.access_token) {
                            console.log('Mantenimento del token corrente dopo timeout del rinnovo silenzioso');
                            gapi.client.setToken(currentToken);
                            resolve(currentToken); // Continuiamo con il token precedente
                        } else {
                            reject(new Error('Timeout durante il rinnovo silenzioso del token'));
                        }
                    }, 10000); // 10 secondi di timeout

                    // Configura il callback temporaneo
                    window.googleAuthClient.callback = (tokenResponse) => {
                        // Cancella il timeout
                        clearTimeout(timeoutId);

                        // Ripristina il callback originale
                        window.googleAuthClient.callback = originalCallback;

                        if (tokenResponse && tokenResponse.access_token) {
                            console.log('Token rinnovato silenziosamente con successo');

                            // Imposta il nuovo token
                            gapi.client.setToken(tokenResponse);

                            // Salva il token in localStorage
                            localStorage.setItem('googleAuthToken', JSON.stringify(tokenResponse));

                            // Salva la data di scadenza del token
                            const expiresIn = tokenResponse.expires_in || 3600;
                            const expiryTime = Date.now() + (expiresIn * 1000);
                            localStorage.setItem('googleTokenExpiry', expiryTime.toString());

                            // Imposta il timer per il prossimo rinnovo automatico
                            this.setupTokenRefresh(tokenResponse);

                            // Mantieni lo stato di login attivo
                            this.isLoggedIn = true;

                            resolve(tokenResponse);
                        } else {
                            console.warn('Nessun token ricevuto durante il rinnovo silenzioso');

                            // Se il rinnovo silenzioso fallisce, manteniamo il token corrente
                            if (currentToken && currentToken.access_token) {
                                console.log('Mantenimento del token corrente dopo fallimento del rinnovo silenzioso');
                                gapi.client.setToken(currentToken);
                                resolve(currentToken); // Continuiamo con il token precedente
                            } else {
                                reject(new Error('Rinnovo silenzioso fallito: nessun token ricevuto'));
                            }
                        }
                    };

                    // Tenta il refresh silenzioso del token
                    try {
                        // Configura un client temporaneo con auto_select: true per il rinnovo silenzioso
                        const tempClient = google.accounts.oauth2.initTokenClient({
                            client_id: '990017681774-kmghq0vajmb8lbv7gqv2qsi7fn1rbp4f.apps.googleusercontent.com',
                            scope: 'https://www.googleapis.com/auth/drive openid profile email',
                            prompt: 'none',  // Non mostrare alcun prompt all'utente
                            auto_select: true,  // Seleziona automaticamente l'account
                            access_type: 'offline',
                            callback: window.googleAuthClient.callback,
                            error_callback: (error) => {
                                // Cancella il timeout
                                clearTimeout(timeoutId);

                                // Ripristina il callback originale
                                window.googleAuthClient.callback = originalCallback;

                                console.error('Errore durante il rinnovo silenzioso:', error);

                                // Se il rinnovo silenzioso fallisce, manteniamo il token corrente
                                if (currentToken && currentToken.access_token) {
                                    console.log('Mantenimento del token corrente dopo errore di rinnovo silenzioso');
                                    gapi.client.setToken(currentToken);
                                    resolve(currentToken); // Continuiamo con il token precedente
                                } else {
                                    reject(error);
                                }
                            }
                        });

                        // Richiedi un nuovo token senza mostrare alcun prompt
                        tempClient.requestAccessToken({
                            prompt: 'none',
                            login_hint: this.userData?.email || '',
                        });
                    } catch (error) {
                        // Cancella il timeout in caso di errore
                        clearTimeout(timeoutId);

                        // Ripristina il callback originale
                        window.googleAuthClient.callback = originalCallback;

                        console.error('Errore durante la richiesta del token silenzioso:', error);

                        // Se il rinnovo silenzioso fallisce, manteniamo il token corrente
                        if (currentToken && currentToken.access_token) {
                            console.log('Mantenimento del token corrente dopo errore di richiesta');
                            gapi.client.setToken(currentToken);
                            resolve(currentToken); // Continuiamo con il token precedente
                        } else {
                            reject(error);
                        }
                    }
                });
            }

            async login(manualTrigger = false) {
                try {
                    await this.ensureApiLoaded();

                    // Verifica se l'utente è già autenticato
                    if (await this.checkAuthStatus()) {
                        return this.userData;
                    }

                    console.log('Avvio procedura di login Google...');

                    // Se non è stato attivato manualmente e non siamo in risposta a un clic dell'utente,
                    // mostra un messaggio e interrompi il processo
                    if (!manualTrigger) {
                        console.log('Login richiesto. Utilizzare il pulsante di accesso.');
                        showToast("Per sincronizzare con Google Drive, effettua l'accesso usando il pulsante dedicato.", "info", 5000);
                        return null;
                    }

                    // Reinizializza il client di autenticazione per assicurarsi che sia aggiornato
                    window.googleAuthClient = google.accounts.oauth2.initTokenClient({
                        client_id: '990017681774-kmghq0vajmb8lbv7gqv2qsi7fn1rbp4f.apps.googleusercontent.com',
                        scope: 'https://www.googleapis.com/auth/drive openid profile email',
                        prompt: 'consent',  // Mostra sempre il consenso per garantire il refresh token
                        auto_select: false,  // Lascia che l'utente scelga l'account
                        // Richiedi un token con scadenza più lunga (massimo consentito)
                        access_type: 'offline',  // Richiedi un refresh token
                        include_granted_scopes: true,  // Include tutti gli scope già concessi
                        callback: (tokenResponse) => {
                            console.log('Callback di autenticazione chiamato');
                            if (tokenResponse && tokenResponse.access_token) {
                                gapi.client.setToken(tokenResponse);
                                console.log('Token di accesso impostato nel client');

                                // Imposta esplicitamente lo stato di login
                                this.isLoggedIn = true;

                                // Salva il token in localStorage per mantenerlo tra i refresh
                                localStorage.setItem('googleAuthToken', JSON.stringify(tokenResponse));

                                // Imposta il rinnovo automatico del token
                                this.setupTokenRefresh(tokenResponse);

                                // Aggiorna l'interfaccia utente
                                if (typeof updateCloudAccountUI === 'function') {
                                    updateCloudAccountUI();
                                }

                                // Mostra un messaggio di successo
                                showToast("Accesso effettuato con successo!", "success");
                            }
                        },
                        error_callback: (error) => {
                            console.error('Errore durante l\'autenticazione:', error);
                            showToast("Errore durante l'accesso: " + (error.message || "Errore sconosciuto"), "error");
                        }
                    });

                    // Utilizziamo la nuova API di Google Identity Services
                    return new Promise((resolve, reject) => {
                        if (!window.googleAuthClient) {
                            reject(new Error('Client di autenticazione Google non inizializzato'));
                            return;
                        }

                        // Salva il callback originale
                        const originalCallback = window.googleAuthClient.callback;

                        // Imposta un nuovo callback temporaneo
                        window.googleAuthClient.callback = async (tokenResponse) => {
                            // Ripristina il callback originale
                            window.googleAuthClient.callback = originalCallback;

                            if (tokenResponse && tokenResponse.access_token) {
                                // Imposta il token di accesso per le richieste API
                                gapi.client.setToken(tokenResponse);
                                console.log('Token di accesso ottenuto:', tokenResponse.access_token.substring(0, 10) + '...');

                                // Salva il token in localStorage per mantenerlo tra i refresh
                                localStorage.setItem('googleAuthToken', JSON.stringify(tokenResponse));

                                try {
                                    // Ottieni informazioni sull'utente
                                    const response = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
                                        headers: {
                                            'Authorization': `Bearer ${tokenResponse.access_token}`
                                        }
                                    });

                                    if (response.ok) {
                                        const userInfo = await response.json();

                                        this.isLoggedIn = true;
                                        this.userData = {
                                            id: userInfo.sub,
                                            name: userInfo.name,
                                            email: userInfo.email,
                                            picture: userInfo.picture,
                                            provider: "google"
                                        };

                                        localStorage.setItem('cloudUserData', JSON.stringify(this.userData));

                                        console.log('Login Google completato con successo:', this.userData.email);

                                        // Imposta il rinnovo automatico del token
                                        this.setupTokenRefresh(tokenResponse);

                                        // Chiama anche il callback originale
                                        if (originalCallback) {
                                            originalCallback(tokenResponse);
                                        }

                                        resolve(this.userData);
                                    } else {
                                        console.error('Errore nella risposta userinfo:', await response.text());
                                        reject(new Error('Impossibile ottenere le informazioni utente'));
                                    }
                                } catch (error) {
                                    console.error('Errore nel recupero delle informazioni utente:', error);
                                    reject(new Error(`Errore nel recupero delle informazioni utente: ${error.message}`));
                                }
                            } else {
                                console.error('Nessun token ricevuto durante il login');
                                reject(new Error('Autenticazione fallita: nessun token ricevuto'));
                            }
                        };

                        // Avvia il flusso di autenticazione
                        try {
                            console.log('Richiesta token di accesso...');
                            // Utilizziamo un timeout per assicurarci che il popup venga aperto in risposta all'azione dell'utente
                            setTimeout(() => {
                                try {
                                    window.googleAuthClient.requestAccessToken({
                                        prompt: 'consent',  // Mostra sempre il consenso per evitare problemi
                                        hint: '',  // Non suggerire account specifici
                                        access_type: 'offline'  // Richiedi un refresh token
                                    });
                                } catch (error) {
                                    console.error('Errore durante la richiesta del token:', error);
                                    showToast("Errore durante l'apertura della finestra di accesso. Verifica che i popup non siano bloccati.", "error", 5000);
                                    // Ripristina il callback originale in caso di errore
                                    window.googleAuthClient.callback = originalCallback;
                                    reject(error);
                                }
                            }, 100);
                        } catch (error) {
                            console.error('Errore durante la richiesta del token:', error);
                            // Ripristina il callback originale in caso di errore
                            window.googleAuthClient.callback = originalCallback;
                            reject(error);
                        }
                    });
                } catch (error) {
                    console.error('Errore durante login Google:', error);
                    throw new Error(`Errore durante il login Google: ${error.message || 'Errore sconosciuto'}`);
                }
            }

            async logout() {
                try {
                    await this.ensureApiLoaded();

                    // Revoca il token di accesso
                    const token = gapi.client.getToken();
                    if (token && token.access_token) {
                        // Revoca il token
                        await fetch(`https://oauth2.googleapis.com/revoke?token=${token.access_token}`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/x-www-form-urlencoded'
                            }
                        });

                        // Rimuovi il token
                        gapi.client.setToken(null);
                    }

                    this.isLoggedIn = false;
                    this.userData = null;

                    // Rimuovi i dati utente e il token da localStorage
                    localStorage.removeItem('cloudUserData');
                    localStorage.removeItem('googleAuthToken');

                    console.log('Logout Google completato');
                    return true;
                } catch (error) {
                    console.error('Errore durante logout Google:', error);
                    throw new Error(`Errore durante il logout Google: ${error.message || 'Errore sconosciuto'}`);
                }
            }

            async findOrCreateBackupFile() {
                try {
                    console.log('Ricerca file di backup in Google Drive...');

                    // Verifica se l'utente è autenticato e ottieni un token valido
                    const token = gapi.client.getToken();
                    if (!token || !token.access_token) {
                        console.log('Token non trovato, richiedo un nuovo token...');
                        await this.refreshToken();
                    }

                    // Verifica nuovamente il token dopo il refresh
                    if (!gapi.client.getToken() || !gapi.client.getToken().access_token) {
                        throw new Error('Impossibile ottenere un token valido');
                    }

                    console.log('Token valido trovato, procedo con la ricerca del file di backup');

                    // Cerca il file di backup esistente nella cartella principale di Drive (non in appDataFolder)
                    const response = await gapi.client.drive.files.list({
                        fields: 'files(id, name, modifiedTime)',
                        q: `name='${this.backupFileName}' and trashed=false`
                    });

                    const files = response.result.files;

                    if (files && files.length > 0) {
                        console.log('File di backup trovato:', files[0].id, 'Ultima modifica:', files[0].modifiedTime);
                        return files[0];
                    } else {
                        console.log('Nessun file di backup trovato, creazione di un nuovo file...');

                        // Crea un nuovo file nella cartella principale di Drive
                        console.log('Creazione nuovo file backup con nome:', this.backupFileName);
                        const fileMetadata = {
                            name: this.backupFileName,
                            // Non specifichiamo parents, così il file sarà salvato nella cartella principale
                            description: 'Backup dei dati di Ore PWS - Questo file contiene i tuoi dati di lavoro'
                        };

                        const emptyData = {
                            createdAt: new Date().toISOString(),
                            version: '1.0',
                            data: {}
                        };

                        // Crea il file con l'API Drive
                        const newFile = await gapi.client.drive.files.create({
                            resource: fileMetadata,
                            fields: 'id, name, modifiedTime'
                        });

                        // Aggiorna il contenuto del file
                        await gapi.client.request({
                            path: `/upload/drive/v3/files/${newFile.result.id}`,
                            method: 'PATCH',
                            params: {
                                uploadType: 'media'
                            },
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(emptyData)
                        });

                        console.log('Nuovo file di backup creato:', newFile.result.id);
                        return newFile.result;
                    }
                } catch (error) {
                    console.error('Errore nella ricerca/creazione del file di backup:', error);

                    // Se l'errore è di autenticazione, richiedi un nuovo token
                    if (error.status === 401 || error.message.includes('auth')) {
                        console.log('Token scaduto o problema di autenticazione, richiedo un nuovo token...');
                        try {
                            await this.refreshToken();
                            return this.findOrCreateBackupFile(); // Riprova dopo il refresh del token
                        } catch (refreshError) {
                            console.error('Errore durante il refresh del token:', refreshError);
                            throw new Error('Impossibile autenticarsi. Prova a effettuare nuovamente il login.');
                        }
                    }

                    throw new Error(`Errore nella gestione del file di backup: ${error.message || 'Errore sconosciuto'}`);
                }
            }

            // Metodo per aggiornare il token se scaduto
            async refreshToken() {
                return new Promise((resolve, reject) => {
                    console.log('Avvio procedura di refresh del token...');

                    // Salva il token corrente prima di tentare il refresh
                    const currentToken = gapi.client.getToken();

                    // Verifica se abbiamo un client di autenticazione Google
                    if (!window.googleAuthClient) {
                        console.error('Client di autenticazione Google non disponibile');

                        // Tenta di caricare il client di autenticazione Google
                        try {
                            // Verifica se il client è già stato caricato ma non è stato inizializzato correttamente
                            if (typeof google !== 'undefined' && google.accounts && google.accounts.oauth2) {
                                console.log('API Google Identity Services trovate, tentativo di inizializzazione...');

                                // Inizializza il client di autenticazione
                                initGoogleAuth().then(() => {
                                    console.log('Client di autenticazione Google inizializzato con successo');
                                    // Riprova il refresh dopo l'inizializzazione
                                    this.refreshToken().then(resolve).catch(reject);
                                }).catch(error => {
                                    console.error('Errore durante l\'inizializzazione del client di autenticazione:', error);
                                    this.handleRefreshFailure(currentToken, reject);
                                });

                                return; // Esci dalla funzione, il callback gestirà il resto
                            } else {
                                // Carica le API Google Identity Services
                                loadGoogleIdentityServices().then(() => {
                                    console.log('API Google Identity Services caricate con successo');
                                    // Inizializza il client di autenticazione
                                    return initGoogleAuth();
                                }).then(() => {
                                    console.log('Client di autenticazione Google inizializzato con successo');
                                    // Riprova il refresh dopo l'inizializzazione
                                    this.refreshToken().then(resolve).catch(reject);
                                }).catch(error => {
                                    console.error('Errore durante il caricamento delle API Google Identity Services:', error);
                                    this.handleRefreshFailure(currentToken, reject);
                                });

                                return; // Esci dalla funzione, il callback gestirà il resto
                            }
                        } catch (error) {
                            console.error('Errore durante il tentativo di caricamento delle API Google:', error);
                            this.handleRefreshFailure(currentToken, reject);
                            return;
                        }
                    }

                    // Verifica se il token è scaduto da più di 24 ore
                    // In questo caso è meglio richiedere un nuovo token completo
                    const tokenExpiry = localStorage.getItem('googleTokenExpiry');
                    const isTokenExpiredLong = tokenExpiry && (Date.now() - parseInt(tokenExpiry)) > 24 * 60 * 60 * 1000;

                    // Se il token è scaduto da molto tempo, richiedi un nuovo token completo
                    if (isTokenExpiredLong) {
                        console.log('Token scaduto da più di 24 ore, richiedo un nuovo token completo...');
                        // Pulisci il token salvato per evitare loop infiniti
                        localStorage.removeItem('googleAuthToken');
                        localStorage.removeItem('googleTokenExpiry');
                        // Reimposta lo stato di login
                        this.isLoggedIn = false;
                        // Mostra un messaggio all'utente
                        showToast("La sessione è scaduta. Per favore, effettua nuovamente l'accesso.", "warning", 10000);
                        // Aggiorna l'interfaccia utente
                        if (typeof updateCloudAccountUI === 'function') {
                            updateCloudAccountUI();
                        }
                        // Rifiuta la promessa per interrompere il ciclo
                        reject(new Error('Token scaduto, necessario nuovo login manuale'));
                        return;
                    }

                    // Configura il callback per il refresh del token
                    const originalCallback = window.googleAuthClient.callback;

                    // Imposta un timeout per gestire il caso in cui Google non risponda
                    let timeoutId = setTimeout(() => {
                        console.warn('Timeout durante il refresh del token');

                        // Ripristina il callback originale
                        window.googleAuthClient.callback = originalCallback;

                        // Pulisci il token salvato per evitare loop infiniti
                        localStorage.removeItem('googleAuthToken');
                        localStorage.removeItem('googleTokenExpiry');
                        // Reimposta lo stato di login
                        this.isLoggedIn = false;

                        // Mostra un messaggio all'utente
                        showToast("La sessione è scaduta. Per favore, effettua nuovamente l'accesso.", "warning", 10000);

                        // Aggiorna l'interfaccia utente
                        if (typeof updateCloudAccountUI === 'function') {
                            updateCloudAccountUI();
                        }

                        // Rifiuta la promessa per interrompere il ciclo
                        reject(new Error('Timeout durante il refresh del token, necessario nuovo login manuale'));
                    }, 30000); // 30 secondi di timeout

                    window.googleAuthClient.callback = (tokenResponse) => {
                        // Cancella il timeout
                        clearTimeout(timeoutId);

                        // Ripristina il callback originale
                        window.googleAuthClient.callback = originalCallback;

                        if (tokenResponse && tokenResponse.access_token) {
                            console.log('Token rinnovato con successo');

                            // Imposta il nuovo token
                            gapi.client.setToken(tokenResponse);

                            // Salva il token in localStorage
                            localStorage.setItem('googleAuthToken', JSON.stringify(tokenResponse));

                            // Salva la data di scadenza del token
                            const expiresIn = tokenResponse.expires_in || 3600;
                            const expiryTime = Date.now() + (expiresIn * 1000);
                            localStorage.setItem('googleTokenExpiry', expiryTime.toString());

                            // Imposta il timer per il prossimo rinnovo automatico
                            this.setupTokenRefresh(tokenResponse);

                            // Mantieni lo stato di login attivo
                            this.isLoggedIn = true;

                            resolve(tokenResponse);
                        } else {
                            console.warn('Nessun token ricevuto durante il refresh');

                            // Pulisci il token salvato per evitare loop infiniti
                            localStorage.removeItem('googleAuthToken');
                            localStorage.removeItem('googleTokenExpiry');

                          // Reimposta lo stato di login
                            this.isLoggedIn = false;

                              // Mostra un messaggio all'utente
                            showToast("La sessione è scaduta. Per favore, effettua nuovamente l'accesso.", "warning", 10000);

                            // Aggiorna l'interfaccia utente
                            if (typeof updateCloudAccountUI === 'function') {
                                updateCloudAccountUI();
                            }

                            // Rifiuta la promessa per interrompere il ciclo
                              reject(new Error('Refresh del token fallito, necessario nuovo login manuale'));
                        }
                    };

                    // Tenta il refresh silenzioso del token
                    try {
                        // Richiedi un nuovo token con prompt vuoto per tentare un refresh silenzioso
                        // Secondo la documentazione di Google, per ottenere un refresh token è necessario
                        // utilizzare access_type: 'offline' e prompt: 'consent'
                        // Ma per un refresh silenzioso, utilizziamo prompt: '' per evitare di mostrare la finestra di consenso
                        window.googleAuthClient.requestAccessToken({
                            prompt: '',
                            access_type: 'offline',
                            // Aggiungiamo un parametro login_hint se abbiamo informazioni sull'utente
                            // per aumentare le probabilità di successo del refresh silenzioso
                            ...(this.userData && this.userData.email ? { login_hint: this.userData.email } : {})
                        });
                    } catch (error) {
                        // Cancella il timeout in caso di errore
                        clearTimeout(timeoutId);

                        console.error('Errore durante la richiesta del token:', error);

                        // Invece di tentare un login completo, gestiamo direttamente il fallimento
                        console.log('Gestione fallimento refresh token dopo errore...');
                        this.handleRefreshFailure(currentToken, reject, error);
                    }
                });
            }

            // Gestisce il fallimento del refresh del token
            handleRefreshFailure(currentToken, reject, error = null) {
                console.error('Gestione fallimento refresh token:', error || 'Nessun token ricevuto');

                // Pulisci i token esistenti che potrebbero essere scaduti
                localStorage.removeItem('googleAuthToken');
                localStorage.removeItem('googleTokenExpiry');

                if (gapi && gapi.client) {
                    gapi.client.setToken(null);
                }

                // Imposta lo stato di login come false
                this.isLoggedIn = false;

                // Mostra un messaggio all'utente solo se è attivo sul sito
                if (document.visibilityState === 'visible') {
                    showToast("La sessione è scaduta. Effettua nuovamente l'accesso per continuare a utilizzare il backup su cloud.", "warning", 5000);
                }

                // Aggiorna l'interfaccia utente per mostrare lo stato di disconnessione
                if (typeof updateCloudAccountUI === 'function') {
                    updateCloudAccountUI();
                }

                reject(new Error('Impossibile rinnovare il token'));
            }

            async backup(data, showLoginPrompt = true) {
                try {
                    await this.ensureApiLoaded();

                    // Verifica se l'utente è autenticato
                    if (!this.isLoggedIn) {
                        // Prima di tutto, proviamo a verificare lo stato di autenticazione
                        // Potrebbe essere che l'utente sia autenticato ma lo stato non sia stato aggiornato
                        const authStatus = await this.checkAuthStatus();

                        // Se ancora non è autenticato e showLoginPrompt è true, informa l'utente
                        if (!authStatus && showLoginPrompt) {
                            console.log('Utente non autenticato, richiesto login manuale...');
                            // Non tentiamo più il login automatico, ma informiamo l'utente
                            showToast("Per sincronizzare con Google Drive, effettua l'accesso usando il pulsante dedicato.", "info", 5000);

                            // Evidenzia il pulsante di login se esiste
                            const loginButton = document.getElementById('googleLoginBtn');
                            if (loginButton) {
                                loginButton.style.display = 'block';
                                loginButton.classList.add('highlight-button');
                                setTimeout(() => {
                                    loginButton.classList.remove('highlight-button');
                                }, 3000);
                            }

                            throw new Error("Login richiesto. Utilizzare il pulsante di accesso.");
                        } else if (!authStatus) {
                            throw new Error("Utente non autenticato");
                        }
                    }

                    console.log('Avvio backup su Google Drive...');

                    // Prepara i dati con metadati
                    const backupData = {
                        data: data,
                        lastUpdated: new Date().toISOString(),
                        appVersion: '2.0',
                        deviceInfo: {
                            userAgent: navigator.userAgent,
                            platform: navigator.platform
                        }
                    };

                    // Trova o crea il file di backup
                    const backupFile = await this.findOrCreateBackupFile();

                    console.log('Aggiornamento del file di backup:', backupFile.id);

                    // Aggiorna il contenuto del file con l'API Drive
                    await gapi.client.request({
                        path: `/upload/drive/v3/files/${backupFile.id}`,
                        method: 'PATCH',
                        params: {
                            uploadType: 'media'
                        },
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(backupData)
                    });

                    console.log('Backup completato con successo:', backupFile.id);

                    // Mostra un messaggio all'utente che il file è visibile in Google Drive
                    showToast("Backup completato!!!.", "success", 6000);

                    return {
                        success: true,
                        timestamp: backupData.lastUpdated,
                        fileId: backupFile.id
                    };
                } catch (error) {
                    console.error('Errore durante il backup su Google Drive:', error);

                    // Se l'errore è di autenticazione, richiedi un nuovo token e riprova
                    if (error.status === 401) {
                        try {
                            console.log('Token scaduto, richiedo un nuovo token...');
                            await this.refreshToken();
                            return this.backup(data); // Riprova dopo il refresh del token
                        } catch (refreshError) {
                            throw new Error('Sessione scaduta. Effettua nuovamente il login.');
                        }
                    } else if (error.status === 403) {
                        throw new Error('Permessi insufficienti per eseguire il backup.');
                    } else if (error.status === 404) {
                        throw new Error('File di backup non trovato.');
                    } else {
                        throw new Error(`Errore durante il backup: ${error.message || 'Errore sconosciuto'}`);
                    }
                }
            }

            async restore() {
                try {
                    await this.ensureApiLoaded();

                    // Verifica se l'utente è autenticato
                    if (!this.isLoggedIn) {
                        // Prima di tutto, proviamo a verificare lo stato di autenticazione
                        const authStatus = await this.checkAuthStatus();

                        // Se ancora non è autenticato, lancia un errore
                        if (!authStatus) {
                            throw new Error("Utente non autenticato");
                        }
                    }

                    console.log('Avvio ripristino da Google Drive...');
                    console.log('Nome file cercato:', this.backupFileName);

                    // Prima prova: cerca il file specifico
                    console.log('Tentativo 1: Ricerca file specifico...');
                    let response = await gapi.client.drive.files.list({
                        fields: 'files(id, name, modifiedTime)',
                        q: `name='${this.backupFileName}' and trashed=false`
                    });

                    let files = response.result.files;
                    console.log('File trovati (ricerca specifica):', files);

                    // Se non trova nulla, prova una ricerca più ampia
                    if (!files || files.length === 0) {
                        console.log('Tentativo 2: Ricerca più ampia...');
                        response = await gapi.client.drive.files.list({
                            fields: 'files(id, name, modifiedTime)',
                            q: `name contains 'Ore PWS' and name contains 'Backup' and trashed=false`
                        });
                        files = response.result.files;
                        console.log('File trovati (ricerca ampia):', files);
                    }

                    // Se ancora non trova nulla, lista tutti i file JSON
                    if (!files || files.length === 0) {
                        console.log('Tentativo 3: Lista tutti i file JSON...');
                        response = await gapi.client.drive.files.list({
                            fields: 'files(id, name, modifiedTime)',
                            q: `name contains '.json' and trashed=false`
                        });
                        files = response.result.files;
                        console.log('Tutti i file JSON trovati:', files);

                        // Filtra manualmente per trovare il backup
                        files = files.filter(file =>
                            file.name.includes('Ore PWS') &&
                            file.name.includes('Backup')
                        );
                        console.log('File backup filtrati manualmente:', files);
                    }

                    if (!files || files.length === 0) {
                        console.warn('Nessun backup trovato su Google Drive dopo tutti i tentativi');
                        throw new Error("Nessun backup trovato");
                    }

                    // Ordina i file per data di modifica (più recente prima)
                    files.sort((a, b) => new Date(b.modifiedTime) - new Date(a.modifiedTime));

                    // Ottieni il contenuto del file più recente
                    const fileId = files[0].id;
                    console.log('Ripristino dal backup più recente:', fileId, 'Data:', files[0].modifiedTime);

                    // Ottieni il contenuto del file
                    const fileResponse = await gapi.client.drive.files.get({
                        fileId: fileId,
                        alt: 'media'
                    });

                    const backupData = fileResponse.result;

                    // Verifica che i dati siano validi
                    if (!backupData || !backupData.data) {
                        console.error('Backup danneggiato o in formato non valido');
                        throw new Error("Backup danneggiato o in formato non valido");
                    }

                    console.log('Ripristino completato con successo');

                    return {
                        success: true,
                        data: backupData.data,
                        timestamp: backupData.lastUpdated,
                        fileId: fileId
                    };
                } catch (error) {
                    console.error('Errore durante il ripristino da Google Drive:', error);

                    // Se l'errore è di autenticazione, richiedi un nuovo token e riprova
                    if (error.status === 401) {
                        try {
                            console.log('Token scaduto, richiedo un nuovo token...');
                            await this.refreshToken();
                            return this.restore(); // Riprova dopo il refresh del token
                        } catch (refreshError) {
                            throw new Error('Sessione scaduta. Effettua nuovamente il login.');
                        }
                    } else if (error.status === 403) {
                        throw new Error('Permessi insufficienti per accedere al backup.');
                    } else if (error.status === 404) {
                        throw new Error('File di backup non trovato.');
                    } else {
                        throw new Error(`Errore durante il ripristino: ${error.message || 'Errore sconosciuto'}`);
                    }
                }
            }
        }

        // Implementazione per Microsoft OneDrive (reale)
        class OneDriveProvider extends CloudProvider {
            constructor() {
                super("Microsoft OneDrive", "https://upload.wikimedia.org/wikipedia/commons/9/96/Microsoft_logo_%282012%29.svg");
                this.apiLoaded = false;
                this.msalInstance = null;
                this.backupFileName = 'ore_pws_backup.json';
            }

            async ensureApiLoaded() {
                if (!this.apiLoaded) {
                    try {
                        await loadMicrosoftApi();

                        // Inizializza MSAL
                        const msalConfig = {
                            auth: {
                                clientId: '12345678-abcd-efgh-ijkl-1234567890ab', // Sostituisci con il tuo Client ID
                                redirectUri: window.location.origin
                            }
                        };

                        this.msalInstance = new msal.PublicClientApplication(msalConfig);
                        this.apiLoaded = true;
                    } catch (error) {
                        console.error('Errore nel caricamento delle API Microsoft:', error);
                        throw error;
                    }
                }
            }

            async login() {
                try {
                    await this.ensureApiLoaded();

                    // Verifica se l'utente è già autenticato
                    const accounts = this.msalInstance.getAllAccounts();
                    if (accounts.length > 0) {
                        const account = accounts[0];

                        this.isLoggedIn = true;
                        this.userData = {
                            id: account.homeAccountId,
                            name: account.name,
                            email: account.username,
                            picture: null, // Microsoft non fornisce direttamente l'URL dell'immagine
                            provider: "microsoft"
                        };

                        localStorage.setItem('cloudUserData', JSON.stringify(this.userData));

                        return this.userData;
                    }

                    // Esegui il login con popup
                    const loginResponse = await this.msalInstance.loginPopup({
                        scopes: ['Files.ReadWrite.AppFolder']
                    });

                    this.isLoggedIn = true;
                    this.userData = {
                        id: loginResponse.account.homeAccountId,
                        name: loginResponse.account.name,
                        email: loginResponse.account.username,
                        picture: null,
                        provider: "microsoft"
                    };

                    localStorage.setItem('cloudUserData', JSON.stringify(this.userData));

                    return this.userData;
                } catch (error) {
                    console.error('Errore durante login Microsoft:', error);
                    throw error;
                }
            }

            async logout() {
                try {
                    await this.ensureApiLoaded();

                    await this.msalInstance.logout();

                    this.isLoggedIn = false;
                    this.userData = null;

                    localStorage.removeItem('cloudUserData');

                    return true;
                } catch (error) {
                    console.error('Errore durante logout Microsoft:', error);
                    throw error;
                }
            }

            async getAccessToken() {
                const accounts = this.msalInstance.getAllAccounts();
                if (accounts.length === 0) {
                    throw new Error("Utente non autenticato");
                }

                const silentRequest = {
                    scopes: ["Files.ReadWrite.AppFolder"],
                    account: accounts[0]
                };

                try {
                    const response = await this.msalInstance.acquireTokenSilent(silentRequest);
                    return response.accessToken;
                } catch (error) {
                    console.error('Errore nell\'acquisizione del token silenzioso:', error);

                    // Se il token è scaduto, richiedi un nuovo token interattivamente
                    const response = await this.msalInstance.acquireTokenPopup(silentRequest);
                    return response.accessToken;
                }
            }

            async backup(data) {
                if (!this.isLoggedIn) {
                    throw new Error("Utente non autenticato");
                }

                try {
                    await this.ensureApiLoaded();

                    const accessToken = await this.getAccessToken();

                    // Prepara i dati con metadati
                    const backupData = {
                        data: data,
                        lastUpdated: new Date().toISOString(),
                        appVersion: '2.0',
                        deviceInfo: {
                            userAgent: navigator.userAgent,
                            platform: navigator.platform
                        }
                    };

                    // In una implementazione reale, qui utilizzeresti Microsoft Graph API
                    // per caricare i dati su OneDrive
                    // Per ora, li salviamo in localStorage
                    localStorage.setItem('oneDriveBackup', JSON.stringify(backupData));

                    return {
                        success: true,
                        timestamp: backupData.lastUpdated
                    };
                } catch (error) {
                    console.error('Errore durante il backup su OneDrive:', error);
                    throw error;
                }
            }

            async restore() {
                if (!this.isLoggedIn) {
                    throw new Error("Utente non autenticato");
                }

                try {
                    await this.ensureApiLoaded();

                    const accessToken = await this.getAccessToken();

                    // In una implementazione reale, qui utilizzeresti Microsoft Graph API
                    // per scaricare i dati da OneDrive
                    // Per ora, li recuperiamo da localStorage
                    const backupJson = localStorage.getItem('oneDriveBackup');

                    if (!backupJson) {
                        throw new Error("Nessun backup trovato");
                    }

                    const backupData = JSON.parse(backupJson);

                    return {
                        success: true,
                        data: backupData.data,
                        timestamp: backupData.lastUpdated
                    };
                } catch (error) {
                    console.error('Errore durante il ripristino da OneDrive:', error);
                    throw error;
                }
            }
        }

        // Implementazione per Apple iCloud (reale)
        class AppleCloudProvider extends CloudProvider {
            constructor() {
                super("Apple iCloud", "https://upload.wikimedia.org/wikipedia/commons/f/fa/Apple_logo_black.svg");
                this.apiLoaded = false;
                this.backupFileName = 'ore_pws_backup.json';
            }

            async ensureApiLoaded() {
                if (!this.apiLoaded) {
                    try {
                        await loadAppleApi();
                        this.apiLoaded = true;
                    } catch (error) {
                        console.error('Errore nel caricamento delle API Apple:', error);
                        throw error;
                    }
                }
            }

            async login() {
                try {
                    await this.ensureApiLoaded();

                    // In una implementazione reale, qui utilizzeresti Sign in with Apple JS
                    // Per ora, utilizziamo un approccio OAuth2 generico

                    // Crea un popup per il login
                    const width = 600;
                    const height = 600;
                    const left = window.screen.width / 2 - width / 2;
                    const top = window.screen.height / 2 - height / 2;

                    const appleAuthUrl = `https://appleid.apple.com/auth/authorize?client_id=com.tuazienda.orepws&redirect_uri=${encodeURIComponent(window.location.origin)}&response_type=code&scope=name%20email&response_mode=form_post`;

                    const popup = window.open(appleAuthUrl, 'apple-auth', `width=${width},height=${height},left=${left},top=${top}`);

                    if (!popup) {
                        throw new Error("Popup bloccato dal browser. Abilita i popup per questo sito.");
                    }

                    // Simuliamo il login per scopi dimostrativi
                    // In una implementazione reale, dovresti gestire il callback da Apple
                    await new Promise(resolve => setTimeout(resolve, 1500));

                    this.isLoggedIn = true;
                    this.userData = {
                        id: "apple_" + Math.random().toString(36).substring(2, 15),
                        name: "Utente Apple",
                        email: "utente@icloud.com",
                        picture: "https://ui-avatars.com/api/?name=Utente+Apple&background=000000&color=fff",
                        provider: "apple"
                    };

                    localStorage.setItem('cloudUserData', JSON.stringify(this.userData));

                    return this.userData;
                } catch (error) {
                    console.error('Errore durante login Apple:', error);
                    throw error;
                }
            }

            async logout() {
                try {
                    await this.ensureApiLoaded();

                    // In una implementazione reale, qui gestiresti il logout da Apple

                    this.isLoggedIn = false;
                    this.userData = null;

                    localStorage.removeItem('cloudUserData');
                    localStorage.removeItem('iCloudBackup');

                    return true;
                } catch (error) {
                    console.error('Errore durante logout Apple:', error);
                    throw error;
                }
            }

            async backup(data) {
                if (!this.isLoggedIn) {
                    throw new Error("Utente non autenticato");
                }

                try {
                    await this.ensureApiLoaded();

                    // In una implementazione reale, qui utilizzeresti CloudKit JS
                    // per caricare i dati su iCloud
                    // Per ora, li salviamo in localStorage
                    const backupData = {
                        data: data,
                        timestamp: new Date().toISOString(),
                        appVersion: '2.0',
                        deviceInfo: {
                            userAgent: navigator.userAgent,
                            platform: navigator.platform
                        }
                    };

                    localStorage.setItem('iCloudBackup', JSON.stringify(backupData));

                    return {
                        success: true,
                        timestamp: backupData.timestamp
                    };
                } catch (error) {
                    console.error('Errore durante il backup su iCloud:', error);
                    throw error;
                }
            }

            async restore() {
                if (!this.isLoggedIn) {
                    throw new Error("Utente non autenticato");
                }

                try {
                    await this.ensureApiLoaded();

                    // In una implementazione reale, qui utilizzeresti CloudKit JS
                    // per scaricare i dati da iCloud
                    // Per ora, li recuperiamo da localStorage
                    const backupJson = localStorage.getItem('iCloudBackup');

                    if (!backupJson) {
                        throw new Error("Nessun backup trovato");
                    }

                    const backupData = JSON.parse(backupJson);

                    return {
                        success: true,
                        data: backupData.data,
                        timestamp: backupData.timestamp
                    };
                } catch (error) {
                    console.error('Errore durante il ripristino da iCloud:', error);
                    throw error;
                }
            }
        }

        // Gestore centralizzato dei provider cloud
        class CloudBackupManager {
            constructor() {
                this.providers = {
                    google: new GoogleDriveProvider()
                };

                this.currentProvider = null;
                this.selectedProvider = null;

                // Carica le preferenze dell'utente
                this.preferredProvider = localStorage.getItem('preferredCloudProvider') || null;

                // Carica i dati dell'utente se disponibili
                const userData = JSON.parse(localStorage.getItem('cloudUserData'));
                if (userData && userData.provider && this.providers[userData.provider]) {
                    const provider = this.providers[userData.provider];
                    provider.isLoggedIn = true;
                    provider.userData = userData;
                    this.currentProvider = userData.provider;
                    this.selectedProvider = userData.provider;
                }
            }

            // Ottieni la lista dei provider disponibili
            getAvailableProviders() {
                return Object.keys(this.providers).map(key => ({
                    id: key,
                    name: this.providers[key].name,
                    logoUrl: this.providers[key].logoUrl,
                    isPreferred: key === this.preferredProvider,
                    isLoggedIn: this.providers[key].isLoggedIn
                }));
            }

            // Imposta il provider selezionato
            setSelectedProvider(providerId) {
                if (this.providers[providerId]) {
                    this.selectedProvider = providerId;
                    return true;
                }
                return false;
            }

            // Ottieni il provider attualmente in uso
            getCurrentProvider() {
                return this.currentProvider;
            }

            // Ottieni il provider selezionato
            getSelectedProvider() {
                return this.selectedProvider;
            }

            // Ottieni l'istanza del provider
            getProvider(providerId) {
                return this.providers[providerId] || null;
            }

            // Login con il provider selezionato
            async login(manualTrigger = false) {
                if (!this.selectedProvider || !this.providers[this.selectedProvider]) {
                    throw new Error("Nessun provider selezionato");
                }

                try {
                    const provider = this.providers[this.selectedProvider];

                    // Mostra un messaggio di caricamento
                    showToast('Connessione in corso...', 'info');

                    // Esegui il login con il provider selezionato
                    // Questo aprirà una finestra di autenticazione del provider
                    // Passa il parametro manualTrigger al provider
                    const userData = await provider.login(manualTrigger);

                    // Se il login è fallito, esci
                    if (!userData) {
                        throw new Error("Login fallito. Riprova più tardi.");
                    }

                    // Imposta come provider corrente
                    this.currentProvider = this.selectedProvider;

                    // Salva come provider preferito
                    this.preferredProvider = this.selectedProvider;
                    localStorage.setItem('preferredCloudProvider', this.preferredProvider);

                    return userData;
                } catch (error) {
                    console.error(`Errore durante il login con ${this.selectedProvider}:`, error);

                    // Mostra un messaggio di errore specifico
                    if (error.message.includes('popup')) {
                        showToast('Il popup di login è stato bloccato. Abilita i popup per questo sito e riprova.', 'error', 5000);
                    } else if (error.message.includes('access_denied') || error.message.includes('cancelled')) {
                        showToast('Accesso negato o annullato dall\'utente.', 'warning');
                    } else if (error.message.includes('Failed to open popup')) {
                        showToast('Impossibile aprire la finestra di login. Clicca nuovamente sul pulsante di accesso.', 'error', 5000);
                    } else {
                        showToast(`Errore durante l'accesso: ${error.message}`, 'error');
                    }

                    throw error;
                }
            }

            // Logout dal provider corrente
            async logout() {
                if (!this.currentProvider || !this.providers[this.currentProvider]) {
                    return false;
                }

                try {
                    // Mostra un messaggio di caricamento
                    showToast('Disconnessione in corso...', 'info');

                    await this.providers[this.currentProvider].logout();
                    this.currentProvider = null;
                    return true;
                } catch (error) {
                    console.error('Errore durante il logout:', error);
                    showToast(`Errore durante la disconnessione: ${error.message}`, 'error');
                    throw error;
                }
            }

            // Esegui backup con il provider corrente
            async backup(data, silent = false, skipToasts = false) {
                if (!this.currentProvider || !this.providers[this.currentProvider]) {
                    throw new Error("Nessun provider cloud selezionato");
                }

                try {
                    // Mostra un messaggio di caricamento solo se non è in modalità silenziosa e non si devono saltare i toast
                    if (!silent && !skipToasts) {
                        showToast('Backup in corso...', 'info');
                    }

                    const result = await this.providers[this.currentProvider].backup(data);

                    // Mostra un messaggio di successo solo se non è in modalità silenziosa e non si devono saltare i toast
                    if (!silent && !skipToasts) {
                        showToast('Sei salvo!!', 'success');
                    }

                    return result;
                } catch (error) {
                    console.error('Errore durante il backup:', error);

                    // Mostra un messaggio di errore solo se non è in modalità silenziosa e non si devono saltare i toast
                    if (!silent && !skipToasts) {
                        showToast(`Errore durante il backup: ${error.message}`, 'error');
                    }

                    throw error;
                }
            }

            // Ripristina dal provider corrente
            async restore(skipToasts = false) {
                if (!this.currentProvider || !this.providers[this.currentProvider]) {
                    throw new Error("Nessun provider cloud selezionato");
                }

                try {
                    // Mostra un messaggio di caricamento solo se non si devono saltare i toast
                    if (!skipToasts) {
                        showToast('Ripristino in corso...', 'info');
                    }

                    const result = await this.providers[this.currentProvider].restore();

                    return result;
                } catch (error) {
                    console.error('Errore durante il ripristino:', error);

                    // Mostra un messaggio di errore solo se non si devono saltare i toast
                    if (!skipToasts) {
                        showToast(`Errore durante il ripristino: ${error.message}`, 'error');
                    }

                    throw error;
                }
            }

            // Ottieni informazioni sull'utente corrente
            getCurrentUserInfo() {
                if (!this.currentProvider || !this.providers[this.currentProvider]) {
                    return null;
                }

                return this.providers[this.currentProvider].getUserInfo();
            }

            // Verifica lo stato di autenticazione di tutti i provider
            async checkAuthStatus() {
                let anyLoggedIn = false;

                // Per ogni provider, verifica se l'utente è già autenticato
                for (const [providerId, provider] of Object.entries(this.providers)) {
                    try {
                        // Se il provider ha un metodo per verificare lo stato di autenticazione, usalo
                        if (provider.checkAuthStatus) {
                            const isLoggedIn = await provider.checkAuthStatus();

                            if (isLoggedIn) {
                                this.currentProvider = providerId;
                                this.selectedProvider = providerId;
                                this.preferredProvider = providerId;
                                localStorage.setItem('preferredCloudProvider', providerId);
                                anyLoggedIn = true;
                            }
                        }
                    } catch (error) {
                        console.warn(`Errore durante la verifica dello stato di autenticazione per ${providerId}:`, error);
                    }
                }

                return anyLoggedIn;
            }
        }

        // Inizializza il gestore dei backup cloud
        let cloudManager = null;

        // Funzione principale di inizializzazione
        async function initCloudBackup(skipAuthCheck = false) {
            // Crea il gestore se non esiste
            if (!cloudManager) {
                cloudManager = new CloudBackupManager();
                // Rendi disponibile globalmente
                window.cloudManager = cloudManager;

                // Verifica lo stato di autenticazione di tutti i provider solo se richiesto
                if (!skipAuthCheck) {
                    try {
                        // Verifica lo stato di autenticazione e restituisce true se almeno un provider è autenticato
                        const isLoggedIn = await cloudManager.checkAuthStatus();
                        console.log('Stato di autenticazione verificato:', isLoggedIn ? 'Autenticato' : 'Non autenticato');
                    } catch (error) {
                        console.warn('Errore durante la verifica dello stato di autenticazione:', error);
                    }
                }
            }

            // Aggiorna l'interfaccia utente
            updateProviderSelectionUI();
            updateCloudAccountUI();

            // Configura il backup automatico con le impostazioni salvate
            setupAutoBackup();

            // Aggiungi event listeners
            setupProviderSelectionListeners();
            setupBackupControlListeners();
        }

        // Aggiorna l'interfaccia di selezione provider
        function updateProviderSelectionUI() {
            const providers = cloudManager.getAvailableProviders();
            const currentProvider = cloudManager.getCurrentProvider();
            const selectedProvider = cloudManager.getSelectedProvider();

            // Aggiorna lo stato di ciascun provider
            providers.forEach(provider => {
                const providerElement = document.querySelector(`.provider-option[data-provider="${provider.id}"]`);
                const statusIndicator = document.getElementById(`${provider.id}Status`);

                if (providerElement && statusIndicator) {
                    // Rimuovi classi esistenti
                    providerElement.classList.remove('selected');
                    statusIndicator.classList.remove('logged-in', 'preferred');

                    // Aggiungi classi appropriate
                    if (provider.id === selectedProvider) {
                        providerElement.classList.add('selected');
                    }

                    if (provider.isLoggedIn) {
                        statusIndicator.classList.add('logged-in');
                    }

                    if (provider.isPreferred) {
                        statusIndicator.classList.add('preferred');
                    }

                    // Aggiorna l'icona se il provider ha proprietà iconClass e iconName
                    const providerInstance = cloudManager.getProvider(provider.id);
                    if (providerInstance && providerInstance.iconClass && providerInstance.iconName) {
                        const logoContainer = providerElement.querySelector('.provider-logo');
                        if (logoContainer) {
                            // Rimuovi eventuali elementi esistenti
                            logoContainer.innerHTML = '';

                            // Crea l'icona
                            const iconElement = document.createElement('span');
                            iconElement.className = providerInstance.iconClass;
                            iconElement.textContent = providerInstance.iconName;

                            // Applica lo stile
                            if (providerInstance.iconColor) {
                                iconElement.style.color = providerInstance.iconColor;
                            }
                            iconElement.style.fontSize = '28px';

                            // Aggiungi l'icona al container
                            logoContainer.appendChild(iconElement);
                        }
                    }
                }
            });

            // Aggiorna i pulsanti di login
            updateLoginButtons();
        }

        // Aggiorna i pulsanti di login in base al provider selezionato
        function updateLoginButtons() {
            const loginButtonsContainer = document.getElementById('loginButtonsContainer');
            const currentProvider = cloudManager.getCurrentProvider();
            const selectedProvider = cloudManager.getSelectedProvider();

            // Se l'utente è già loggato, non mostrare i pulsanti di login
            if (currentProvider && cloudManager.getProvider(currentProvider).isLoggedIn) {
                loginButtonsContainer.style.display = 'none';
                return;
            }

            // Altrimenti, mostra il pulsante appropriato
            loginButtonsContainer.style.display = 'flex';
            loginButtonsContainer.innerHTML = '';

            // Mostra sempre il pulsante Google Drive (provider predefinito)
            const providerToShow = selectedProvider || 'google';
            const provider = cloudManager.getProvider(providerToShow);

            if (provider) {
                const button = document.createElement('button');
                button.id = `${providerToShow}LoginBtn`;
                button.className = `cloud-login-btn ${providerToShow}-btn`;

               // Verifica se il provider ha proprietà iconClass e iconName
                if (provider.iconClass && provider.iconName) {
                    button.innerHTML = `
                        <span class="${provider.iconClass}" style="color: ${provider.iconColor || '#4285F4'}; margin-right: 8px;">${provider.iconName}</span>
                        Accedi con ${provider.name}
                    `;
                } else {
                    button.innerHTML = `
                        <span class="material-symbols-outlined" style="color: #4285F4; margin-right: 8px;">cloud</span>
                         Accedi con ${provider.name}
                    `;
                }

                // Se non c'è un provider selezionato, seleziona Google automaticamente
                if (!selectedProvider) {
                    button.addEventListener('click', async () => {
                        cloudManager.setSelectedProvider('google');
                        await loginWithSelectedProvider();
                    });
                } else {
                    button.addEventListener('click', loginWithSelectedProvider);
                }

                loginButtonsContainer.appendChild(button);
            } else {
                loginButtonsContainer.innerHTML = '<p>Seleziona un provider per accedere</p>';
            }
        }

        // Aggiorna l'interfaccia utente dell'account
        function updateCloudAccountUI() {
            const accountSection = document.getElementById('cloudAccountSection');
            const accountInfo = document.getElementById('cloudAccountInfo');
            const logoutBtn = document.getElementById('cloudLogoutBtn');
            const backupControls = document.getElementById('cloudBackupControls');

            const currentProvider = cloudManager.getCurrentProvider();
            const userData = currentProvider ? cloudManager.getProvider(currentProvider).getUserInfo() : null;

            if (userData) {
                // Utente loggato
                const provider = cloudManager.getProvider(currentProvider);

                accountInfo.innerHTML = `
                    <div class="user-profile">
                        ${userData.picture ?
                            `<img src="${userData.picture}" alt="${userData.name}" class="user-avatar">` :
                            `<span class="material-symbols-outlined user-avatar-icon" style="color: #4285F4; font-size: 36px; background-color: #E8F0FE; border-radius: 50%; padding: 8px;">account_circle</span>`
                        }
                        <div class="user-details">
                            <div class="user-name">${userData.name}</div>
                            <div class="user-email">${userData.email}</div>
                            <div class="user-provider">
                                ${provider.iconClass && provider.iconName ?
                                    `<span class="${provider.iconClass}" style="color: ${provider.iconColor || '#4285F4'}; margin-right: 4px; vertical-align: middle;">${provider.iconName}</span>` :
                                    `<span class="material-symbols-outlined" style="color: #4285F4; margin-right: 4px; vertical-align: middle;">cloud</span>`
                                }
                                Connesso con ${provider.name}
                            </div>
                        </div>
                    </div>
                `;

                logoutBtn.style.display = 'block';
                backupControls.style.display = 'block';

                // Aggiorna anche le informazioni sull'ultimo backup
                updateLastBackupInfo();
            } else {
                // Utente non loggato
                accountInfo.innerHTML = '<p>Seleziona un provider e accedi per abilitare il backup su cloud</p>';
                logoutBtn.style.display = 'none';
                backupControls.style.display = 'none';
            }
        }

        // Aggiorna le informazioni sull'ultimo backup
        function updateLastBackupInfo() {
            const currentProvider = cloudManager.getCurrentProvider();
            if (!currentProvider) return;

            const lastBackupTime = localStorage.getItem(`lastBackupTime_${currentProvider}`);
            const lastBackupElement = document.getElementById('lastBackupTime');

            if (lastBackupTime && lastBackupElement) {
                lastBackupElement.textContent = `Ultimo backup: ${new Date(lastBackupTime).toLocaleString()}`;
            } else if (lastBackupElement) {
                lastBackupElement.textContent = 'Mai eseguito';
            }
        }

        // Configura i listener per la selezione del provider
        function setupProviderSelectionListeners() {
            const providerOptions = document.querySelectorAll('.provider-option');

            providerOptions.forEach(option => {
                option.addEventListener('click', () => {
                    const providerId = option.dataset.provider;

                    // Imposta questo provider come selezionato
                    cloudManager.setSelectedProvider(providerId);

                    // Aggiorna l'UI
                    updateProviderSelectionUI();
                });
            });

            // Configura il pulsante di logout
            const logoutBtn = document.getElementById('cloudLogoutBtn');
            if (logoutBtn) {
                logoutBtn.addEventListener('click', async () => {
                    try {
                        await cloudManager.logout();
                        updateProviderSelectionUI();
                        updateCloudAccountUI();
                        showToast('Disconnesso dall\'account cloud', 'info');
                    } catch (error) {
                        console.error('Errore durante il logout:', error);
                        showToast('Errore durante la disconnessione: ' + error.message, 'error');
                    }
                });
            }
        }

        // Configura i listener per i controlli di backup
        function setupBackupControlListeners() {
            // Pulsante di backup manuale
            const manualBackupBtn = document.getElementById('manualBackupBtn');
            if (manualBackupBtn) {
                // Salva il testo originale per ripristinarlo dopo
                manualBackupBtn.setAttribute('data-original-text', manualBackupBtn.innerHTML);

                // Flag per prevenire clic multipli
                let isProcessing = false;

                manualBackupBtn.addEventListener('click', async () => {
                    // Previeni clic multipli
                    if (isProcessing) {
                        console.log('Operazione già in corso, ignoro il clic');
                        return;
                    }

                    isProcessing = true;

                    try {
                        // Mostra indicatore di caricamento
                        const originalText = manualBackupBtn.getAttribute('data-original-text') || manualBackupBtn.innerHTML;
                        manualBackupBtn.innerHTML = '<span class="spinner"></span> Backup in corso...';
                        manualBackupBtn.disabled = true;

                        // Ottieni i dati da salvare
                        const data = getDb(); // La tua funzione esistente

                        let result;
                        let isAuthenticated = false;

                        // Verifica prima se l'utente è autenticato
                        try {
                            isAuthenticated = await cloudManager.checkAuthStatus();
                        } catch (error) {
                            console.log('Errore durante la verifica dello stato di autenticazione:', error);
                            isAuthenticated = false;
                        }

                        // Se non è autenticato, mostra il pulsante di login
                        if (!isAuthenticated) {
                            showToast('Per eseguire il backup, effettua prima l\'accesso', 'info');

                            try {
                                // Prova a fare login esplicito
                                await loginWithSelectedProvider();

                                // Verifica nuovamente l'autenticazione
                                isAuthenticated = await cloudManager.checkAuthStatus();

                                if (!isAuthenticated) {
                                    throw new Error("Accesso non riuscito. Riprova più tardi.");
                                }
                            } catch (loginError) {
                                throw new Error(`Impossibile accedere: ${loginError.message}`);
                            }
                        }

                        // Ora che siamo sicuri che l'utente è autenticato, esegui il backup
                        // Passiamo true come terzo parametro per saltare i toast nel metodo backup
                        result = await cloudManager.backup(data, false, true);

                        // Aggiorna l'UI
                        const currentProvider = cloudManager.getCurrentProvider();
                        localStorage.setItem(`lastBackupTime_${currentProvider}`, result.timestamp);
                        updateLastBackupInfo();

                        // Mostriamo il toast di successo qui, una sola volta
                        showToast('Sei salvo!!!', 'success');
                    } catch (error) {
                        console.error('Errore durante il backup:', error);
                        showToast('Errore durante il backup: ' + error.message, 'error');
                    } finally {
                        // Ripristina il pulsante indipendentemente dal risultato
                        manualBackupBtn.innerHTML = manualBackupBtn.getAttribute('data-original-text') || 'Backup Manuale';
                        manualBackupBtn.disabled = false;
                        isProcessing = false;
                    }
                });
            }

            // Pulsante di ripristino
            const restoreBackupBtn = document.getElementById('restoreBackupBtn');
            if (restoreBackupBtn) {
                // Salva il testo originale per ripristinarlo dopo
                restoreBackupBtn.setAttribute('data-original-text', restoreBackupBtn.innerHTML);

                // Flag per prevenire clic multipli
                let isProcessing = false;

                restoreBackupBtn.addEventListener('click', async () => {
                    // Previeni clic multipli
                    if (isProcessing) {
                        console.log('Operazione già in corso, ignoro il clic');
                        return;
                    }

                    isProcessing = true;

                    try {
                        // Mostra indicatore di caricamento
                        const originalText = restoreBackupBtn.getAttribute('data-original-text') || restoreBackupBtn.innerHTML;
                        restoreBackupBtn.innerHTML = '<span class="spinner"></span> Ripristino in corso...';
                        restoreBackupBtn.disabled = true;

                        let result;
                        let isAuthenticated = false;

                        // Verifica prima se l'utente è autenticato
                        try {
                            isAuthenticated = await cloudManager.checkAuthStatus();
                        } catch (error) {
                            console.log('Errore durante la verifica dello stato di autenticazione:', error);
                            isAuthenticated = false;
                        }

                        // Se non è autenticato, mostra il pulsante di login
                        if (!isAuthenticated) {
                            showToast('Per ripristinare un backup, effettua prima l\'accesso', 'info');

                            try {
                                // Prova a fare login esplicito
                                await loginWithSelectedProvider();

                                // Verifica nuovamente l'autenticazione
                                isAuthenticated = await cloudManager.checkAuthStatus();

                                if (!isAuthenticated) {
                                    throw new Error("Accesso non riuscito. Riprova più tardi.");
                                }
                            } catch (loginError) {
                                throw new Error(`Impossibile accedere: ${loginError.message}`);
                            }
                        }

                        // Ora che siamo sicuri che l'utente è autenticato, esegui il ripristino
                        // Passiamo true per saltare i toast nel metodo restore
                        result = await cloudManager.restore(true);

                        // Chiedi conferma all'utente
                        const backupDate = new Date(result.timestamp).toLocaleString();
                        const hasLocalData = checkIfLocalDataExists();

                        let confirmMessage;
                        if (hasLocalData) {
                            confirmMessage = `⚠️ ATTENZIONE: Hai già dei dati salvati!\n\nRipristinare il backup del ${backupDate}?\n\n❌ I tuoi dati attuali verranno SOVRASCRITTI e persi definitivamente.\n\n✅ Consiglio: Fai prima un backup dei dati attuali.`;
                        } else {
                            confirmMessage = `Ripristinare i dati dal backup del ${backupDate}?`;
                        }

                        if (!confirm(confirmMessage)) {
                            // L'utente ha annullato
                            showToast('Ripristino annullato dall\'utente', 'info');
                            return;
                        }

                        // Ripristina i dati
                        saveDb(result.data);

                        // Aggiorna l'interfaccia utente
                        if (typeof loadTimeEntries === 'function') loadTimeEntries();
                        if (typeof loadCalendarData === 'function') loadCalendarData();
                        if (typeof populateVehicleDropdown === 'function') populateVehicleDropdown();
                        if (typeof loadVehiclesList === 'function') loadVehiclesList();

                        showToast('Dati ripristinati con successo', 'success');
                    } catch (error) {
                        console.error('Errore durante il ripristino:', error);
                        showToast('Errore durante il ripristino: ' + error.message, 'error');
                    } finally {
                        // Ripristina il pulsante indipendentemente dal risultato
                        restoreBackupBtn.innerHTML = restoreBackupBtn.getAttribute('data-original-text') || 'Ripristina Backup';
                        restoreBackupBtn.disabled = false;
                        isProcessing = false;
                    }
                });
            }

            // Toggle per backup automatico
            const autoBackupToggle = document.getElementById('autoBackupToggle');
            if (autoBackupToggle) {
                autoBackupToggle.addEventListener('change', (e) => {
                    localStorage.setItem('autoBackupEnabled', e.target.checked);
                    setupAutoBackup();
                });
            }


        }

        // Login con il provider selezionato
        async function loginWithSelectedProvider() {
            try {
                // Passiamo manualTrigger=true per indicare che è un'azione esplicita dell'utente
                const userData = await cloudManager.login(true);

                // Se il login è fallito, esci
                if (!userData) {
                    throw new Error("Login fallito. Riprova più tardi.");
                }

                updateProviderSelectionUI();
                updateCloudAccountUI();
                setupAutoBackup(); // Configura il backup automatico

                const provider = cloudManager.getProvider(cloudManager.getCurrentProvider());
                showToast(`Accesso effettuato con ${provider.name}`, 'success');

                return userData; // Restituisci i dati utente per consentire operazioni successive
            } catch (error) {
                console.error(`Errore durante il login:`, error);
                showToast('Errore durante l\'accesso: ' + error.message, 'error');
                throw error; // Propaga l'errore per gestirlo a livello superiore
            }
        }

        // Configura il backup automatico
        function setupAutoBackup() {
            // Leggi le preferenze dell'utente
            const autoBackupEnabled = localStorage.getItem('autoBackupEnabled') !== 'false'; // Default: true

            console.log('Configurazione backup automatico - Abilitato:', autoBackupEnabled);

            // Aggiorna UI
            const autoBackupToggle = document.getElementById('autoBackupToggle');
            if (autoBackupToggle) autoBackupToggle.checked = autoBackupEnabled;

            // Cancella eventuali timer esistenti
            if (window.autoBackupTimer) {
                clearInterval(window.autoBackupTimer);
                window.autoBackupTimer = null;
            }

            if (window.backupDebounceTimer) {
                clearTimeout(window.backupDebounceTimer);
                window.backupDebounceTimer = null;
            }

            // Se il backup automatico è disabilitato o nessun provider è attivo, esci
            if (!autoBackupEnabled || !cloudManager.getCurrentProvider()) {
                // Ripristina la funzione saveDb originale se il backup automatico è disabilitato
                if (window.originalSaveDb) {
                    window.saveDb = window.originalSaveDb;
                }
                return;
            }

            // Backup automatico ad ogni modifica
            // Salva la funzione originale se non è già stata salvata
            if (!window.originalSaveDb) {
                window.originalSaveDb = window.saveDb;
            }

            window.saveDb = function(data) {
                const result = window.originalSaveDb(data);

                // Pianifica backup con un leggero ritardo per evitare troppe chiamate
                if (window.backupDebounceTimer) {
                    clearTimeout(window.backupDebounceTimer);
                }

                window.backupDebounceTimer = setTimeout(async () => {
                    if (cloudManager.getCurrentProvider()) {
                        try {
                            console.log('Esecuzione backup automatico dopo modifica...');
                            const currentData = getDb();
                            const backupResult = await cloudManager.backup(currentData, true); // silent = true
                            if (backupResult.success) {
                                console.log('Backup automatico dopo modifica completato');
                                const currentProvider = cloudManager.getCurrentProvider();
                                localStorage.setItem(`lastBackupTime_${currentProvider}`, backupResult.timestamp);
                                updateLastBackupInfo();
                            }
                        } catch (error) {
                            console.error('Errore durante il backup automatico dopo modifica:', error);
                        }
                    }
                }, 2000); // Attendi 2 secondi dopo l'ultima modifica

                return result;
            };
        }

        // Funzione per controllare se esistono dati locali significativi
        function checkIfLocalDataExists() {
            try {
                // Controlla i dati principali del time tracker
                const timeTrackerData = localStorage.getItem('timeTrackerData');
                if (timeTrackerData) {
                    const data = JSON.parse(timeTrackerData);
                    // Controlla se ci sono entries (ore registrate)
                    if (data.entries && Object.keys(data.entries).length > 0) {
                        console.log('Trovate entries nel time tracker:', Object.keys(data.entries).length);
                        return true;
                    }
                    // Controlla se ci sono veicoli configurati
                    if (data.vehicles && data.vehicles.length > 0) {
                        console.log('Trovati veicoli configurati:', data.vehicles.length);
                        return true;
                    }
                    // Controlla se ci sono tariffe personalizzate
                    if (data.rates && (data.rates.normalHour > 0 || data.rates.nightHour > 0)) {
                        console.log('Trovate tariffe personalizzate');
                        return true;
                    }
                }

                // Controlla se c'è un nome utente configurato
                const userName = localStorage.getItem('userName');
                if (userName && userName.trim() !== '' && userName !== 'Utente') {
                    console.log('Trovato nome utente configurato:', userName);
                    return true;
                }

                // Controlla se ci sono file Excel salvati
                const excelFiles = localStorage.getItem('excelFiles');
                if (excelFiles) {
                    const files = JSON.parse(excelFiles);
                    if (files && files.length > 0) {
                        console.log('Trovati file Excel salvati:', files.length);
                        return true;
                    }
                }

                console.log('Nessun dato locale significativo trovato');
                return false;
            } catch (error) {
                console.error('Errore nel controllo dati locali:', error);
                return false; // In caso di errore, assumiamo che non ci siano dati
            }
        }

        // Aggiungi alla funzione di inizializzazione principale
        document.addEventListener('DOMContentLoaded', async () => {
            // Carica le API di Google
            try {
                await loadGoogleApi();

                // Inizializza il backup cloud
                await initCloudBackup();

                // Tenta di ripristinare automaticamente la sessione all'avvio
                const savedToken = localStorage.getItem('googleAuthToken');
                if (savedToken && cloudManager) {
                    try {
                        console.log('Trovato token salvato, ripristino sessione Google Drive...');
                        const provider = cloudManager.getProvider('google');
                        if (provider) {
                            await provider.checkAuthStatus();
                            console.log('Sessione ripristinata automaticamente');

                            // Aggiorna l'interfaccia utente
                            updateProviderSelectionUI();
                            updateCloudAccountUI();

                            // Ripristino automatico rimosso - l'utente deve farlo manualmente dalle impostazioni
                            console.log('Sessione Google Drive ripristinata - ripristino dati disponibile nelle impostazioni');
                        }
                    } catch (e) {
                        console.warn('Impossibile ripristinare automaticamente la sessione:', e);
                    }
                }

                console.log('Inizializzazione del backup cloud completata');
            } catch (error) {
                console.error('Errore durante l\'inizializzazione del backup cloud:', error);
            }

            // Inizializza il backup cloud quando la sezione impostazioni è attiva
            const settingsSection = document.getElementById('settings-section');
            if (settingsSection) {
                // Inizializza quando la sezione diventa visibile
                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
                            if (settingsSection.classList.contains('active')) {
                                // Inizializza senza verificare l'autenticazione automaticamente
                                initCloudBackup(true);

                                // La gestione del PIN Admin è stata spostata in uno script separato alla fine del file

                                // Reinizializza il PIN Admin quando la sezione impostazioni è attiva
                                // Questo assicura che i listener siano aggiornati
                                if (typeof initAdminPin === 'function') {
                                 initAdminPin();
                                   }

                                // La gestione del pulsante di blocco è inclusa nella funzione initAdminPin

                                // Inizializza il pulsante di aggiornamento forzato
                                const forceUpdateBtn = document.getElementById('forceUpdate');
                                if (forceUpdateBtn) {
                                    // Rimuovi eventuali listener precedenti
                                    forceUpdateBtn.replaceWith(forceUpdateBtn.cloneNode(true));
                                    const newForceUpdateBtn = document.getElementById('forceUpdate');

                                    newForceUpdateBtn.addEventListener('click', function() {
                                        showToast('Aggiornamento in corso...', 'info');

                                        // Forza l'aggiornamento del service worker
                                        if ('serviceWorker' in navigator) {
                                            navigator.serviceWorker.getRegistrations().then(function(registrations) {
                                                for (let registration of registrations) {
                                                    registration.unregister().then(function() {
                                                        console.log('Service Worker rimosso con successo');
                                                    });
                                                }

                                                // Svuota la cache
                                                caches.keys().then(function(cacheNames) {
                                                    return Promise.all(
                                                        cacheNames.map(function(cacheName) {
                                                            console.log('Eliminazione cache:', cacheName);
                                                            return caches.delete(cacheName);
                                                        })
                                                    );
                                                }).then(function() {
                                                    console.log('Cache svuotata con successo');
                                                    showToast('Aggiornamento completato! Ricarico la pagina...', 'success');

                                                    // Ricarica la pagina dopo un breve ritardo
                                                    setTimeout(function() {
                                                        window.location.reload(true);
                                                    }, 1500);
                                                });
                                            });
                                        } else {
                                            showToast('Service Worker non supportato', 'error');
                                        }
                                    });
                                }
                            }
                        }
                    });
                });

                observer.observe(settingsSection, { attributes: true });

                // Inizializza anche se la sezione è già attiva al caricamento
                if (settingsSection.classList.contains('active')) {
                    // Inizializza senza verificare l'autenticazione automaticamente
                    initCloudBackup(true);
                }
            }
        });
    </script>

    <script>
        // Script vuoto per mantenere la struttura del documento
        function setupVoiceRecognitionButton() {
            // Funzione disabilitata
            return;
            // Trova il placeholder per il pulsante vocale
            const placeholder = document.getElementById('voice-button-placeholder');
            if (!placeholder) {
                console.error("Placeholder per il pulsante vocale non trovato");
                return;
            }

            // Crea il contenitore per il pulsante centrale
            const centerButtonContainer = document.createElement('div');
            centerButtonContainer.className = 'voice-btn-container';

            // Crea il pulsante di riconoscimento vocale
            const voiceButton = document.createElement('button');
            voiceButton.id = 'voiceRecognitionBtn';
            voiceButton.className = 'voice-recognition-btn';
            voiceButton.innerHTML = '<span class="material-symbols-outlined">mic</span>';
            voiceButton.setAttribute('aria-label', 'Inserisci ore con voce');

            // Crea l'elemento onda per l'animazione
            const wave = document.createElement('div');
            wave.className = 'voice-recognition-wave';
            voiceButton.appendChild(wave);

            // Aggiungi il pulsante al contenitore
            centerButtonContainer.appendChild(voiceButton);

            // Inserisci il contenitore nel placeholder
            placeholder.appendChild(centerButtonContainer);

            // Aggiungi gli stili CSS per il pulsante
            const style = document.createElement('style');
            style.textContent = `
                /* Manteniamo la barra di navigazione fissa in basso */
                .bottom-nav {
                    position: fixed !important;
                    bottom: 0 !important;
                    left: 0 !important;
                    width: 100% !important;
                    z-index: 1000 !important;
                }

                /* Stile per il placeholder del pulsante vocale */
                #voice-button-placeholder {
                    position: relative;
                    width: 0;
                    height: 0;
                    overflow: visible;
                }

                .voice-btn-container {
                    position: absolute;
                    left: 50%;
                    top: -30px;
                    transform: translateX(-50%);
                    z-index: 100;
                }

                .voice-recognition-btn {
                    width: 56px;
                    height: 56px;
                    border-radius: 50%;
                    background-color: var(--md-sys-color-primary);
                    color: var(--md-sys-color-on-primary);
                    box-shadow: var(--elevation-3);
                    border: none;
                    cursor: pointer;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    transition: all 0.3s ease;
                    transform: scale(1);
                    position: relative;
                }

                .voice-recognition-btn .material-symbols-outlined {
                    font-size: 24px;
                }

                .voice-recognition-btn:hover {
                    box-shadow: var(--elevation-4);
                    transform: scale(1.05);
                }

                .voice-recognition-btn.listening {
                    animation: pulse-rainbow 2s infinite;
                }

                @keyframes pulse-rainbow {
                    0% {
                        box-shadow: 0 0 0 0 rgba(0, 106, 106, 0.7);
                        background-color: var(--md-sys-color-primary);
                    }
                    25% {
                        background-color: #9c27b0;
                    }
                    50% {
                        box-shadow: 0 0 0 15px rgba(0, 106, 106, 0);
                        background-color: #2196f3;
                    }
                    75% {
                        background-color: #4caf50;
                    }
                    100% {
                        box-shadow: 0 0 0 0 rgba(0, 106, 106, 0);
                        background-color: var(--md-sys-color-primary);
                    }
                }

                .voice-tooltip {
                    position: fixed;
                    bottom: 80px;
                    left: 50%;
                    transform: translateX(-50%);
                    background-color: var(--md-sys-color-surface-variant);
                    color: var(--md-sys-color-on-surface-variant);
                    padding: 15px 20px;
                    border-radius: var(--border-radius-medium);
                    box-shadow: var(--elevation-3);
                    z-index: 1000;
                    max-width: 80%;
                    text-align: center;
                    transition: all 0.3s ease;
                }

                .voice-tooltip.success {
                    background-color: var(--md-sys-color-primary-container);
                    color: var(--md-sys-color-on-primary-container);
                }

                .voice-tooltip.error {
                    background-color: var(--md-sys-color-error-container);
                    color: var(--md-sys-color-on-error-container);
                }

                .voice-recognition-wave {
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    width: 100px;
                    height: 100px;
                    border-radius: 50%;
                    background-color: rgba(255, 255, 255, 0.1);
                    z-index: -1;
                    opacity: 0;
                }

                .voice-recognition-btn.listening .voice-recognition-wave {
                    animation: wave-out 2s infinite;
                    opacity: 1;
                }

                /* Stile per indicare che Whisper AI è disponibile */
                .voice-recognition-btn[data-ai="true"]::after {
                    content: "AI";
                    position: absolute;
                    top: -5px;
                    right: -5px;
                    background-color: var(--md-sys-color-tertiary);
                    color: var(--md-sys-color-on-tertiary);
                    font-size: 10px;
                    font-weight: bold;
                    padding: 2px 4px;
                    border-radius: 8px;
                    box-shadow: var(--elevation-1);
                }

                @keyframes wave-out {
                    0% {
                        width: 56px;
                        height: 56px;
                        opacity: 0.7;
                    }
                    100% {
                        width: 200px;
                        height: 200px;
                        opacity: 0;
                    }
                }

                /* Stile per il pulsante di trasferta */
                .trasferta-button {
                    width: 100%;
                    padding: 0.875rem 1rem;
                    border: 1px solid var(--md-sys-color-outline);
                    border-radius: var(--border-radius-small);
                    background-color: var(--md-sys-color-surface);
                    color: var(--md-sys-color-on-surface);
                    font-size: 1rem;
                    font-family: var(--body-font-family);
                    cursor: pointer;
                    transition: all 0.3s ease;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    gap: 0.5rem;
                    height: 48px; /* Stessa altezza degli altri input */
                    text-transform: none;
                    letter-spacing: normal;
                    box-shadow: none;
                }

                .trasferta-button .material-symbols-outlined {
                    font-size: 1.2rem;
                }

                .trasferta-button.active {
                    background-color: var(--md-sys-color-primary);
                    color: var(--md-sys-color-on-primary);
                    border-color: var(--md-sys-color-primary);
                    font-weight: 500;
                    box-shadow: var(--elevation-2);
                }

                /* Aggiungiamo un indicatore visivo per lo stato attivo */
                .trasferta-button.active::before {
                    content: "✓";
                    margin-right: 5px;
                    font-weight: bold;
                }

                .trasferta-button:hover {
                    border-color: var(--md-sys-color-primary);
                    box-shadow: 0 0 0 1px var(--md-sys-color-primary-container);
                }
            `;
            document.head.appendChild(style);

            // Inizializza il riconoscimento vocale
            setupVoiceRecognition(voiceButton);
        }

        // Funzione per configurare il riconoscimento vocale
        function setupVoiceRecognition(voiceButton) {
            // Verifica il supporto del browser per il riconoscimento vocale nativo
            const hasNativeRecognition = ('webkitSpeechRecognition' in window) || ('SpeechRecognition' in window);

            if (!hasNativeRecognition) {
                console.warn("Il browser non supporta il riconoscimento vocale nativo");
            }

            // Inizializza Whisper AI in background
            // Riconoscimento vocale avanzato (Whisper) rimosso

            // Crea l'elemento onda per l'animazione
            const wave = document.createElement('div');
            wave.className = 'voice-recognition-wave';
            voiceButton.appendChild(wave);

            // Inizializza il riconoscimento vocale nativo (se supportato)
            let recognition = null;
            if (hasNativeRecognition) {
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                recognition.lang = 'it-IT';
                recognition.continuous = false;
                recognition.interimResults = true;
            }

            // Crea un elemento per mostrare il testo riconosciuto in tempo reale
            let tooltip = null;

            // Flag per tenere traccia della modalità di riconoscimento
            // let isUsingWhisper = false;

            // Gestisci il click sul pulsante
            voiceButton.addEventListener('click', async () => {
                if (voiceButton.classList.contains('listening')) {
                    if (recognition) recognition.stop();
                    return;
                }

                tooltip = document.createElement('div');
                tooltip.className = 'voice-tooltip';

                const startTimeField = document.getElementById('startTime');
                const endTimeField = document.getElementById('endTime');
                const hasData = startTimeField && startTimeField.value || endTimeField && endTimeField.value;

                if (hasData) {
                    tooltip.innerHTML = 'Sto ascoltando... <br><small>Puoi dire "salva" per salvare i dati già inseriti, oppure dettare nuovi dati</small>';
                } else {
                    tooltip.innerHTML = 'Sto ascoltando... <br><small>Prova a dire: "oggi inizio 7 pausa mezzora fine 17 descrizione pws punto ufficio"</small>';
                }

                document.body.appendChild(tooltip);
                voiceButton.classList.add('listening');
                playSound('start');

                if (recognition) {
                    recognition.start();
                } else {
                    tooltip.innerHTML = 'Riconoscimento vocale non supportato in questo browser';
                    tooltip.classList.add('error');
                    voiceButton.classList.remove('listening');
                    playSound('error');
                    setTimeout(() => {
                        if (tooltip && tooltip.parentNode) {
                            tooltip.remove();
                            tooltip = null;
                        }
                    }, 3000);
                }
            });

            // Configura gli eventi per il riconoscimento vocale nativo (se disponibile)
            if (recognition) {
                // Gestisci i risultati intermedi
                recognition.onresult = (event) => {
                    const transcript = Array.from(event.results)
                        .map(result => result[0].transcript)
                        .join('');

                    // Aggiorna il tooltip con il testo riconosciuto
                    if (tooltip) {
                        tooltip.innerHTML = `"${transcript}"`;
                    }

                    // Se è un risultato finale, elabora il testo
                    if (event.results[0].isFinal) {
                        processAdvancedVoiceInput(transcript);
                    }
                };

                // Quando il riconoscimento termina
                recognition.onend = () => {
                    // Ripristina l'aspetto del pulsante
                    voiceButton.classList.remove('listening');

                    // Rimuovi il tooltip dopo un breve ritardo
                    if (tooltip) {
                        setTimeout(() => {
                            if (tooltip && tooltip.parentNode) {
                                tooltip.remove();
                                tooltip = null;
                            }
                        }, 3000);
                    }
                };

                // Gestisci gli errori
                recognition.onerror = (event) => {
                    console.error('Errore nel riconoscimento vocale:', event.error);

                    if (tooltip) {
                        tooltip.innerHTML = `Errore: ${event.error === 'no-speech' ? 'Non ho sentito nulla' : 'Riprova per favore'}`;
                        tooltip.classList.add('error');
                    }

                    // Ripristina l'aspetto del pulsante
                    voiceButton.classList.remove('listening');

                    // Riproduci un suono di errore
                    playSound('error');
                };
            }
        }

        // Funzione per elaborare l'input vocale avanzato
        function processAdvancedVoiceInput(text) {
            console.log('Elaboro input vocale avanzato:', text);

            // Normalizza il testo (minuscolo) e correggi alcuni errori comuni di riconoscimento
            let normalizedText = text.toLowerCase();

            // Correzioni per numeri e parole comuni che potrebbero essere riconosciuti male
            normalizedText = normalizedText
                // Correzioni per numeri
                .replace(/un[oa]?(?=\s|$)/g, '1')
                .replace(/due/g, '2')
                .replace(/tre/g, '3')
                .replace(/quattro/g, '4')
                .replace(/cinque/g, '5')
                .replace(/sei/g, '6')
                .replace(/sette/g, '7')
                .replace(/otto/g, '8')
                .replace(/nove/g, '9')
                .replace(/dieci/g, '10')
                .replace(/undici/g, '11')
                .replace(/dodici/g, '12')
                .replace(/tredici/g, '13')
                .replace(/quattordici/g, '14')
                .replace(/quindici/g, '15')
                .replace(/sedici/g, '16')
                .replace(/diciassette/g, '17')
                .replace(/diciotto/g, '18')
                .replace(/diciannove/g, '19')
                .replace(/venti/g, '20')
                .replace(/ventuno/g, '21')
                .replace(/ventidue/g, '22')
                .replace(/ventitre/g, '23')
                .replace(/ventiquattro/g, '24')
                // Correzioni per orari
                .replace(/mezzogiorno/g, '12')
                .replace(/mezzanotte/g, '0')
                // Correzioni per frazioni di ora
                .replace(/un quarto/g, '15 minuti')
                .replace(/tre quarti/g, '45 minuti')
                .replace(/mezzo/g, 'mezza')
                // Correzioni per errori comuni
                .replace(/inizia/g, 'inizio')
                .replace(/finisco/g, 'fine')
                .replace(/finisce/g, 'fine')
                .replace(/finito/g, 'fine')
                .replace(/pausa di/g, 'pausa')
                .replace(/con pausa/g, 'pausa')
                .replace(/senza pausa/g, 'pausa 0');

            // Controlla se l'utente ha detto solo "salva" o simili (senza altri comandi)
            const saveOnlyCommand = normalizedText.match(/^(?:salva|conferma|invia|registra|ok)$/i);
            if (saveOnlyCommand) {
                console.log('Comando di solo salvataggio riconosciuto, salvo i dati inseriti manualmente...');

                // Prima di salvare, assicuriamoci che le ore totali siano calcolate
                if (typeof calculateTotalHours === 'function') {
                    calculateTotalHours();
                }

                // Trova il pulsante di invio e fai clic su di esso dopo un breve ritardo
                setTimeout(() => {
                    const submitButton = document.querySelector('#addEntryForm button[type="submit"]');
                    if (submitButton) {
                        submitButton.click();
                    }
                }, 200); // Piccolo ritardo per assicurarsi che il calcolo sia completato

                return; // Esci dalla funzione dopo aver salvato
            }

            // Controlla se l'utente ha detto "salva" come parte di un comando più lungo
            const saveCommand = normalizedText.match(/salva|conferma|invia|registra|ok/i);
            if (saveCommand) {
                // Prima di salvare, assicuriamoci che le ore totali siano calcolate
                if (typeof calculateTotalHours === 'function') {
                    calculateTotalHours();
                }

                // Trova il pulsante di invio e fai clic su di esso dopo un breve ritardo
                setTimeout(() => {
                    const submitButton = document.querySelector('#addEntryForm button[type="submit"]');
                    if (submitButton) {
                        console.log('Comando di salvataggio riconosciuto, invio il form...');
                        submitButton.click();
                    }
                }, 200); // Piccolo ritardo per assicurarsi che il calcolo sia completato

                return; // Esci dalla funzione dopo aver salvato
            }

            // Estrai la data con maggiore flessibilità
            let date = new Date();
            const datePatterns = [
                { pattern: /oggi|today/i, handler: () => new Date() },
                { pattern: /ieri|yesterday/i, handler: () => {
                    const d = new Date(); d.setDate(d.getDate() - 1); return d;
                }},
                { pattern: /domani|tomorrow/i, handler: () => {
                    const d = new Date(); d.setDate(d.getDate() + 1); return d;
                }},
                { pattern: /lunedì|lunedi/i, handler: () => getNextDayOfWeek(1) },
                { pattern: /martedì|martedi/i, handler: () => getNextDayOfWeek(2) },
                { pattern: /mercoledì|mercoledi/i, handler: () => getNextDayOfWeek(3) },
                { pattern: /giovedì|giovedi/i, handler: () => getNextDayOfWeek(4) },
                { pattern: /venerdì|venerdi/i, handler: () => getNextDayOfWeek(5) },
                { pattern: /sabato/i, handler: () => getNextDayOfWeek(6) },
                { pattern: /domenica/i, handler: () => getNextDayOfWeek(0) },
                // Riconosce anche date nel formato "il 15 maggio" o "15/5"
                { pattern: /il\s+(\d{1,2})\s+(\w+)/i, handler: (match) => {
                    const day = parseInt(match[1]);
                    const monthNames = ["gennaio", "febbraio", "marzo", "aprile", "maggio", "giugno",
                                       "luglio", "agosto", "settembre", "ottobre", "novembre", "dicembre"];
                    const monthIndex = monthNames.findIndex(m => match[2].startsWith(m));
                    if (monthIndex >= 0) {
                        const d = new Date();
                        d.setDate(day);
                        d.setMonth(monthIndex);
                        return d;
                    }
                    return new Date();
                }},
                { pattern: /(\d{1,2})[\/\-](\d{1,2})(?:[\/\-](\d{2,4}))?/i, handler: (match) => {
                    const day = parseInt(match[1]);
                    const month = parseInt(match[2]) - 1; // I mesi in JS sono 0-based
                    const year = match[3] ? parseInt(match[3]) : new Date().getFullYear();
                    // Gestisci anni a 2 cifre
                    const fullYear = year < 100 ? (year < 50 ? 2000 + year : 1900 + year) : year;
                    return new Date(fullYear, month, day);
                }}
            ];

            // Cerca una corrispondenza con i pattern di data
            for (const dateMatcher of datePatterns) {
                const match = normalizedText.match(dateMatcher.pattern);
                if (match) {
                    date = dateMatcher.handler(match);
                    break;
                }
            }

            // Estrai ora di inizio con maggiore flessibilità
            let startTime = null;
            const startPatterns = [
                // Formato "dalle 7 alle 17" o "da 7 a 17"
                { pattern: /da(?:lle)?\s+(\d+)(?:[.,:](\d+))?\s+(?:alle|a)\s+(\d+)(?:[.,:](\d+))?/i, handler: (match) => {
                    const hours = parseInt(match[1]);
                    const minutes = match[2] ? parseInt(match[2]) : 0;
                    return hours * 60 + minutes;
                }},
                // Formato "inizio 7" o "inizio alle 7" con vari separatori (: . ,)
                { pattern: /inizio\s+(?:alle\s+)?(\d+)(?:[.,:](\d+))?/i, handler: (match) => {
                    const hours = parseInt(match[1]);
                    const minutes = match[2] ? parseInt(match[2]) : 0;
                    return hours * 60 + minutes;
                }},
                // Formato "dalle 9" o "da 9:30" con vari separatori (ma non seguito da "alle" o "a")
                { pattern: /da(?:lle)?\s+(\d+)(?:[.,:](\d+))?(?!\s+(?:alle|a))/i, handler: (match) => {
                    const hours = parseInt(match[1]);
                    const minutes = match[2] ? parseInt(match[2]) : 0;
                    return hours * 60 + minutes;
                }},
                // Formato "ho iniziato alle 8" con vari separatori
                { pattern: /(?:ho\s+)?iniziato\s+(?:alle\s+)?(\d+)(?:[.,:](\d+))?/i, handler: (match) => {
                    const hours = parseInt(match[1]);
                    const minutes = match[2] ? parseInt(match[2]) : 0;
                    return hours * 60 + minutes;
                }},
                // Formato "entrato alle 8" o "sono entrato alle 8"
                { pattern: /(?:sono\s+)?entrat[oa]\s+(?:alle\s+)?(\d+)(?:[.,:](\d+))?/i, handler: (match) => {
                    const hours = parseInt(match[1]);
                    const minutes = match[2] ? parseInt(match[2]) : 0;
                    return hours * 60 + minutes;
                }},
                // Formato "arrivato alle 8" o "sono arrivato alle 8"
                { pattern: /(?:sono\s+)?arrivat[oa]\s+(?:alle\s+)?(\d+)(?:[.,:](\d+))?/i, handler: (match) => {
                    const hours = parseInt(match[1]);
                    const minutes = match[2] ? parseInt(match[2]) : 0;
                    return hours * 60 + minutes;
                }},
                // Formato "inizio 7 e mezza" o "inizio 7 e 30"
                { pattern: /inizio\s+(\d+)\s+e\s+(?:mezza|mezzo|30)/i, handler: (match) => {
                    const hours = parseInt(match[1]);
                    return hours * 60 + 30;
                }},
                // Formato "inizio 7 e un quarto" o "inizio 7 e 15"
                { pattern: /inizio\s+(\d+)\s+e\s+(?:un\s+quarto|15)/i, handler: (match) => {
                    const hours = parseInt(match[1]);
                    return hours * 60 + 15;
                }},
                // Formato "inizio 7 e tre quarti" o "inizio 7 e 45"
                { pattern: /inizio\s+(\d+)\s+e\s+(?:tre\s+quarti|45)/i, handler: (match) => {
                    const hours = parseInt(match[1]);
                    return hours * 60 + 45;
                }},
                // Formato "7-17" (orario completo) con vari separatori
                { pattern: /^.*?(\d+)(?:[.,:](\d+))?\s*(?:-|–|fino|a)\s*(\d+)(?:[.,:](\d+))?/i, handler: (match) => {
                    const hours = parseInt(match[1]);
                    const minutes = match[2] ? parseInt(match[2]) : 0;
                    return hours * 60 + minutes;
                }}
            ];

            // Cerca una corrispondenza con i pattern di ora di inizio
            for (const startMatcher of startPatterns) {
                const match = normalizedText.match(startMatcher.pattern);
                if (match) {
                    startTime = startMatcher.handler(match);
                    break;
                }
            }

            // Estrai ora di fine con maggiore flessibilità
            let endTime = null;
            const endPatterns = [
                // Formato "dalle 7 alle 17" o "da 7 a 17"
                { pattern: /da(?:lle)?\s+(\d+)(?:[.,:](\d+))?\s+(?:alle|a)\s+(\d+)(?:[.,:](\d+))?/i, handler: (match) => {
                    const hours = parseInt(match[3]);
                    const minutes = match[4] ? parseInt(match[4]) : 0;
                    return hours * 60 + minutes;
                }},
                // Formato "fine 17" o "fine alle 17" con vari separatori
                { pattern: /fine\s+(?:alle\s+)?(\d+)(?:[.,:](\d+))?/i, handler: (match) => {
                    const hours = parseInt(match[1]);
                    const minutes = match[2] ? parseInt(match[2]) : 0;
                    return hours * 60 + minutes;
                }},
                // Formato "alle 17" o "a 17:30" (dopo un pattern di inizio) con vari separatori
                { pattern: /(?:alle|a)\s+(\d+)(?:[.,:](\d+))?/i, handler: (match) => {
                    const hours = parseInt(match[1]);
                    const minutes = match[2] ? parseInt(match[2]) : 0;
                    return hours * 60 + minutes;
                }},
                // Formato "ho finito alle 18" con vari separatori
                { pattern: /(?:ho\s+)?finito\s+(?:alle\s+)?(\d+)(?:[.,:](\d+))?/i, handler: (match) => {
                    const hours = parseInt(match[1]);
                    const minutes = match[2] ? parseInt(match[2]) : 0;
                    return hours * 60 + minutes;
                }},
                // Formato "uscito alle 18" o "sono uscito alle 18"
                { pattern: /(?:sono\s+)?uscit[oa]\s+(?:alle\s+)?(\d+)(?:[.,:](\d+))?/i, handler: (match) => {
                    const hours = parseInt(match[1]);
                    const minutes = match[2] ? parseInt(match[2]) : 0;
                    return hours * 60 + minutes;
                }},
                // Formato "fine 17 e mezza" o "fine 17 e 30"
                { pattern: /fine\s+(\d+)\s+e\s+(?:mezza|mezzo|30)/i, handler: (match) => {
                    const hours = parseInt(match[1]);
                    return hours * 60 + 30;
                }},
                // Formato "fine 17 e un quarto" o "fine 17 e 15"
                { pattern: /fine\s+(\d+)\s+e\s+(?:un\s+quarto|15)/i, handler: (match) => {
                    const hours = parseInt(match[1]);
                    return hours * 60 + 15;
                }},
                // Formato "fine 17 e tre quarti" o "fine 17 e 45"
                { pattern: /fine\s+(\d+)\s+e\s+(?:tre\s+quarti|45)/i, handler: (match) => {
                    const hours = parseInt(match[1]);
                    return hours * 60 + 45;
                }},
                // Formato "7-17" (orario completo) con vari separatori
                { pattern: /(\d+)(?:[.,:](\d+))?\s*(?:-|–|fino|a)\s*(\d+)(?:[.,:](\d+))?/i, handler: (match) => {
                    const hours = parseInt(match[3]);
                    const minutes = match[4] ? parseInt(match[4]) : 0;
                    return hours * 60 + minutes;
                }}
            ];

            // Cerca una corrispondenza con i pattern di ora di fine
            for (const endMatcher of endPatterns) {
                const match = normalizedText.match(endMatcher.pattern);
                if (match) {
                    endTime = endMatcher.handler(match);
                    break;
                }
            }

            // Estrai pausa con maggiore flessibilità
            let pauseTime = 0;
            const pausePatterns = [
                // Formato "pausa 1:30" o "pausa 1" con vari separatori
                { pattern: /pausa\s+(?:di\s+)?(\d+)(?:[.,:](\d+))?/i, handler: (match) => {
                    const hours = parseInt(match[1]);
                    const minutes = match[2] ? parseInt(match[2]) : 0;
                    return hours * 60 + minutes;
                }},
                // Formato "pausa di un'ora" o "pausa 1 ora"
                { pattern: /pausa\s+(?:di\s+)?(?:un['']?ora|1\s+ora)/i, handler: () => 60 },
                // Formato "pausa di mezz'ora" o "pausa mezzora"
                { pattern: /pausa\s+(?:di\s+)?mez(?:z[''])?ora/i, handler: () => 30 },
                // Formato "pausa 2 ore"
                { pattern: /pausa\s+(?:di\s+)?(\d+)\s+(?:ore|ora)/i, handler: (match) => parseInt(match[1]) * 60 },
                // Formato "pausa 30 minuti"
                { pattern: /pausa\s+(?:di\s+)?(\d+)\s+minuti/i, handler: (match) => parseInt(match[1]) },
                // Formato "con pausa di 45 minuti"
                { pattern: /con\s+pausa\s+(?:di\s+)?(\d+)\s+minuti/i, handler: (match) => parseInt(match[1]) },
                // Formato "con pausa di un'ora"
                { pattern: /con\s+pausa\s+(?:di\s+)?(?:un['']?ora|1\s+ora)/i, handler: () => 60 },
                // Formato "con pausa di mezz'ora"
                { pattern: /con\s+pausa\s+(?:di\s+)?mez(?:z[''])?ora/i, handler: () => 30 },
                // Formato "pausa un quarto d'ora" o "pausa 15 minuti"
                { pattern: /pausa\s+(?:di\s+)?(?:un\s+quarto|quarto\s+d['']ora)/i, handler: () => 15 },
                // Formato "pausa tre quarti d'ora" o "pausa 45 minuti"
                { pattern: /pausa\s+(?:di\s+)?(?:tre\s+quarti|quarti\s+d['']ora)/i, handler: () => 45 },
                // Formato "pausa pranzo" (default 1 ora)
                { pattern: /pausa\s+pranzo/i, handler: () => 60 },
                // Formato "senza pausa" o "pausa zero"
                { pattern: /(?:senza|no)\s+pausa|pausa\s+(?:zero|0)/i, handler: () => 0 },
                // Formato "pausa 1 e mezza" (1 ora e 30 minuti)
                { pattern: /pausa\s+(\d+)\s+e\s+(?:mezza|mezzo|30)/i, handler: (match) => {
                    const hours = parseInt(match[1]);
                    return hours * 60 + 30;
                }}
            ];

            // Cerca una corrispondenza con i pattern di pausa
            for (const pauseMatcher of pausePatterns) {
                const match = normalizedText.match(pauseMatcher.pattern);
                if (match) {
                    pauseTime = pauseMatcher.handler(match);
                    break;
                }
            }

            // Estrai ore totali direttamente menzionate
            let directHours = 0;
            let directMinutes = 0;
            const hoursPatterns = [
                // Formato "8 ore" o "8 ore e 30 minuti"
                { pattern: /(\d+)\s+or[ae]/i, handler: (match) => parseInt(match[1]) },
                // Formato "8 ore e mezza" o "8 ore e mezzo"
                { pattern: /(\d+)\s+or[ae]\s+e\s+mezz[ao]/i, handler: (match) => {
                    directMinutes = 30;
                    return parseInt(match[1]);
                }},
                // Formato "8 ore e 30" o "8 e 30"
                { pattern: /(\d+)(?:\s+or[ae])?\s+e\s+(\d+)(?:\s+minuti)?/i, handler: (match) => {
                    directMinutes = parseInt(match[2]);
                    return parseInt(match[1]);
                }},
                // Formato "8.5 ore" o "8,5 ore"
                { pattern: /(\d+)[.,](\d+)\s+or[ae]/i, handler: (match) => {
                    directMinutes = parseInt(match[2]) * 6; // Converte decimali in minuti (es. 0.5 -> 30 min)
                    return parseInt(match[1]);
                }}
            ];

            // Cerca una corrispondenza con i pattern di ore dirette
            for (const hoursMatcher of hoursPatterns) {
                const match = normalizedText.match(hoursMatcher.pattern);
                if (match) {
                    directHours = hoursMatcher.handler(match);
                    break;
                }
            }

            // Calcola le ore totali
            let totalHours = 0;
            let totalMinutes = 0;

            if (directHours > 0 || directMinutes > 0) {
                // Se le ore sono state specificate direttamente, usa quelle
                totalHours = directHours;
                totalMinutes = directMinutes;
            } else if (startTime !== null && endTime !== null) {
                // Altrimenti, calcola in base a inizio e fine
                let totalMinutesWorked = endTime - startTime - pauseTime;

                // Gestisci il caso in cui l'ora di fine sia il giorno successivo
                if (totalMinutesWorked < 0) {
                    totalMinutesWorked += 24 * 60; // Aggiungi 24 ore in minuti
                }

                totalHours = Math.floor(totalMinutesWorked / 60);
                totalMinutes = totalMinutesWorked % 60;
            }

            // Estrai la descrizione con maggiore flessibilità
            let description = "";
            const descPatterns = [
                // Formato "descrizione xyz"
                { pattern: /descrizione\s+(.+?)(?:\s+(?:inizio|fine|pausa|ore)|$)/i, handler: (match) => match[1] },
                // Formato "per xyz" o "su xyz"
                { pattern: /(?:per|su|di)\s+(.+?)(?:\s+(?:inizio|fine|pausa|ore)|$)/i, handler: (match) => match[1] },
                // Formato "lavorato su xyz"
                { pattern: /lavorato\s+(?:su|per|al|con)\s+(.+?)(?:\s+(?:inizio|fine|pausa|ore)|$)/i, handler: (match) => match[1] },
                // Formato "progetto xyz"
                { pattern: /progetto\s+(.+?)(?:\s+(?:inizio|fine|pausa|ore)|$)/i, handler: (match) => match[1] },
                // Formato "attività xyz"
                { pattern: /attivit[àa]\s+(.+?)(?:\s+(?:inizio|fine|pausa|ore)|$)/i, handler: (match) => match[1] },
                // Formato "cliente xyz"
                { pattern: /cliente\s+(.+?)(?:\s+(?:inizio|fine|pausa|ore)|$)/i, handler: (match) => match[1] },
                // Formato "commessa xyz"
                { pattern: /commessa\s+(.+?)(?:\s+(?:inizio|fine|pausa|ore)|$)/i, handler: (match) => match[1] }
            ];

            // Cerca una corrispondenza con i pattern di descrizione
            for (const descMatcher of descPatterns) {
                const match = normalizedText.match(descMatcher.pattern);
                if (match) {
                    description = descMatcher.handler(match);
                    break;
                }
            }

            // Se non è stata trovata una descrizione esplicita, estrai il testo rimanente come descrizione
            if (!description) {
                // Crea una copia del testo normalizzato
                let remainingText = normalizedText;

                // Rimuovi le parti già riconosciute (data, orari, pausa)
                const partsToRemove = [
                    // Date
                    /oggi|ieri|domani|lunedì|lunedi|martedì|martedi|mercoledì|mercoledi|giovedì|giovedi|venerdì|venerdi|sabato|domenica/gi,
                    // Orari di inizio
                    /inizio\s+(?:alle\s+)?(\d+)(?:[.,:](\d+))?/gi,
                    /da(?:lle)?\s+(\d+)(?:[.,:](\d+))?/gi,
                    /(?:ho\s+)?iniziato\s+(?:alle\s+)?(\d+)(?:[.,:](\d+))?/gi,
                    /(?:sono\s+)?entrat[oa]\s+(?:alle\s+)?(\d+)(?:[.,:](\d+))?/gi,
                    /(?:sono\s+)?arrivat[oa]\s+(?:alle\s+)?(\d+)(?:[.,:](\d+))?/gi,
                    // Orari di fine
                    /fine\s+(?:alle\s+)?(\d+)(?:[.,:](\d+))?/gi,
                    /(?:alle|a)\s+(\d+)(?:[.,:](\d+))?/gi,
                    /(?:ho\s+)?finito\s+(?:alle\s+)?(\d+)(?:[.,:](\d+))?/gi,
                    /(?:sono\s+)?uscit[oa]\s+(?:alle\s+)?(\d+)(?:[.,:](\d+))?/gi,
                    // Formati orari completi
                    /(\d+)(?:[.,:](\d+))?\s*(?:-|–|fino|a)\s*(\d+)(?:[.,:](\d+))?/gi,
                    // Pause
                    /pausa\s+(?:di\s+)?(\d+)(?:[.,:](\d+))?/gi,
                    /pausa\s+(?:di\s+)?(?:un['']?ora|1\s+ora)/gi,
                    /pausa\s+(?:di\s+)?mez(?:z[''])?ora/gi,
                    /pausa\s+(?:di\s+)?(\d+)\s+(?:ore|ora)/gi,
                    /pausa\s+(?:di\s+)?(\d+)\s+minuti/gi,
                    /con\s+pausa\s+(?:di\s+)?(\d+)\s+minuti/gi,
                    /con\s+pausa\s+(?:di\s+)?(?:un['']?ora|1\s+ora)/gi,
                    /con\s+pausa\s+(?:di\s+)?mez(?:z[''])?ora/gi,
                    /pausa\s+(?:di\s+)?(?:un\s+quarto|quarto\s+d['']ora)/gi,
                    /pausa\s+(?:di\s+)?(?:tre\s+quarti|quarti\s+d['']ora)/gi,
                    /pausa\s+pranzo/gi,
                    /(?:senza|no)\s+pausa|pausa\s+(?:zero|0)/gi,
                    // Parole chiave da rimuovere
                    /salva|conferma|invia|registra|ok/gi,
                    // Rimuovi parole comuni e preposizioni isolate
                    /\b(e|con|il|la|lo|le|gli|i|di|a|da|in|su|per|tra|fra)\b/gi
                ];

                // Rimuovi tutte le parti riconosciute
                partsToRemove.forEach(pattern => {
                    remainingText = remainingText.replace(pattern, ' ');
                });

                // Pulisci il testo rimanente (rimuovi spazi multipli, spazi all'inizio e alla fine)
                remainingText = remainingText.replace(/\s+/g, ' ').trim();

                // Se c'è ancora del testo, usalo come descrizione
                if (remainingText) {
                    description = remainingText;
                }
            }

            // Sostituisci "punto" con "." nella descrizione
            description = description.replace(/\s+punto\s+/g, '.');

            // Formatta la data per il campo input
            const formattedDate = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;

            // Prepara i dati da inserire nel form
            const entryData = {
                date: formattedDate,
                hours: totalHours,
                minutes: totalMinutes,
                description: description,
                startTime: startTime !== null ? formatMinutesToTime(startTime) : "",
                endTime: endTime !== null ? formatMinutesToTime(endTime) : "",
                pauseTime: pauseTime > 0 ? formatPauseTime(pauseTime) : "0"
            };

            // Inserisci i dati nel form
            fillEntryForm(entryData);

            // Mostra un messaggio di conferma
            showConfirmationTooltip(entryData);

            // Riproduci un suono di successo
            playSound('success');
        }

        // Funzione per ottenere il prossimo giorno della settimana
        function getNextDayOfWeek(dayOfWeek) {
            const today = new Date();
            const todayDay = today.getDay(); // 0 = domenica, 1 = lunedì, ...

            let daysToAdd = dayOfWeek - todayDay;
            if (daysToAdd <= 0) {
                daysToAdd += 7; // Vai alla prossima settimana
            }

            const nextDay = new Date(today);
            nextDay.setDate(today.getDate() + daysToAdd);
            return nextDay;
        }

        // Funzione per formattare i minuti in formato orario (solo il numero, senza :00)
        function formatMinutesToTime(minutes) {
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;

            // Se i minuti sono 0, restituisci solo l'ora senza decimali
            if (mins === 0) {
                return String(hours);
            }
            // Se i minuti sono 30 (mezz'ora), restituisci formato decimale con .5
            else if (mins === 30) {
                return `${hours}.5`;
            }
            // Per altri valori di minuti, usa il formato con i due punti
            else {
                return `${hours}:${String(mins).padStart(2, '0')}`;
            }
        }

        // Funzione per formattare il tempo di pausa in formato decimale
        function formatPauseTime(pauseMinutes) {
            const hours = Math.floor(pauseMinutes / 60);
            const mins = pauseMinutes % 60;

            // Se è un'ora esatta
            if (mins === 0) {
                return String(hours);
            }
            // Se è mezz'ora o multipli di mezz'ora
            else if (mins === 30) {
                return `${hours}.5`;
            }
            // Per 15 minuti (0.25)
            else if (mins === 15) {
                return hours > 0 ? `${hours}.25` : "0.25";
            }
            // Per 45 minuti (0.75)
            else if (mins === 45) {
                return hours > 0 ? `${hours}.75` : "0.75";
            }
            // Per altri valori, arrotonda al più vicino 0.25
            else {
                const fraction = Math.round((mins / 60) * 4) / 4;
                if (fraction === 0) {
                    return String(hours);
                } else {
                    return `${hours + fraction}`.replace(/\.?0+$/, '');
                }
            }
        }

        // Funzione per compilare il form con i dati riconosciuti
        function fillEntryForm(data) {
            // Trova i campi del form
            const dateField = document.getElementById('date');
            const hoursField = document.getElementById('hours');
            const minutesField = document.getElementById('minutes');
            const descriptionField = document.getElementById('description');
            const startTimeField = document.getElementById('startTime');
            const endTimeField = document.getElementById('endTime');
            const pauseField = document.getElementById('pause');

            // Compila i campi se esistono
            if (dateField) dateField.value = data.date;
            if (hoursField) hoursField.value = data.hours;
            if (minutesField) minutesField.value = data.minutes;
            if (descriptionField) descriptionField.value = data.description;
            if (startTimeField) startTimeField.value = data.startTime;
            if (endTimeField) endTimeField.value = data.endTime;
            if (pauseField) pauseField.value = data.pauseTime;

            // Calcola automaticamente le ore totali dopo l'inserimento vocale
            // Cerca la funzione di calcolo ore e chiamala se esiste
            if (typeof calculateTotalHours === 'function') {
                setTimeout(() => {
                    calculateTotalHours();
                }, 100); // Piccolo ritardo per assicurarsi che i campi siano stati aggiornati
            }

            // Non facciamo più il click automatico, l'utente dovrà dire "salva" per salvare
            // o fare click manualmente sul pulsante di invio
        }

        // Funzione per mostrare un tooltip di conferma
        function showConfirmationTooltip(data) {
            const tooltip = document.createElement('div');
            tooltip.className = 'voice-tooltip success';

            let message = `<strong>Ho inserito:</strong><br>`;
            message += `Data: ${formatDateForDisplay(data.date)}<br>`;

            if (data.startTime && data.endTime) {
                message += `Orario: ${data.startTime} - ${data.endTime}`;
                if (data.pauseTime > 0) {
                    message += ` (pausa: ${data.pauseTime} ore)`;
                }
                message += `<br>`;
            }

            message += `Ore: ${data.hours}h ${data.minutes > 0 ? data.minutes + 'm' : ''}<br>`;

            if (data.description) {
                message += `Descrizione: ${data.description}`;
            }

            tooltip.innerHTML = message;
            document.body.appendChild(tooltip);

            // Rimuovi il tooltip dopo alcuni secondi
            setTimeout(() => {
                tooltip.style.opacity = '0';
                setTimeout(() => tooltip.remove(), 500);
            }, 5000);
        }

        // Funzione per formattare la data per la visualizzazione
        function formatDateForDisplay(dateString) {
            const date = new Date(dateString);
            const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
            return date.toLocaleDateString('it-IT', options);
        }

        // Funzione per riprodurre suoni di feedback
        function playSound(type) {
            // Crea suoni semplici con l'API Web Audio
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            switch(type) {
                case 'start':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(880, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(440, audioContext.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
                case 'success':
                    oscillator.type = 'sine';
                    oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(880, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
                case 'error':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(330, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(220, audioContext.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start();
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
            }
        }


    </script>

    <!-- Stile per le card trasparenti integrato -->
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Crea un elemento style per le card trasparenti
        const style = document.createElement('style');
        style.textContent = `
            /* Stile trasparente per le card */
            .card {
                background-color: rgba(218, 229, 228, 0.2) !important; /* Versione più trasparente per tema chiaro */
                color: var(--md-sys-color-on-surface-variant);
                backdrop-filter: blur(5px) !important; /* Effetto sfocatura per migliorare la leggibilità */
                -webkit-backdrop-filter: blur(5px) !important; /* Per Safari */
                transition: all 0.3s ease !important;
                border: 1px solid rgba(191, 201, 200, 0.5) !important; /* Bordo più trasparente */
            }

            /* Versione trasparente per tema scuro */
            .dark-theme .card {
                background-color: rgba(63, 73, 72, 0.2) !important; /* Versione più trasparente per tema scuro */
                border: 1px solid rgba(137, 147, 146, 0.5) !important; /* Bordo più trasparente per tema scuro */
            }

            /* Effetto hover per le card */
            .card:hover {
                backdrop-filter: blur(8px) !important;
                -webkit-backdrop-filter: blur(8px) !important;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1) !important;
            }

            /* Stile per i titoli nelle card */
            .card h2, .card h3 {
                text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1); /* Leggera ombra per migliorare la leggibilità */
            }
        `;
        document.head.appendChild(style);
        console.log('Stile card trasparenti integrato');
    });
    </script>

    <!-- PWS Particles Background -->
    <div id="pws-particles-container"></div>

    <!-- Librerie per le particelle PWS -->
    <script src="https://cdn.jsdelivr.net/npm/tsparticles-engine@2/tsparticles.engine.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tsparticles@2/tsparticles.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tsparticles-shape-text@2/tsparticles.shape.text.min.js"></script>

    <!-- Script per le particelle PWS - Stile Neon -->
    <script>
    // Configurazione delle particelle PWS
    document.addEventListener('DOMContentLoaded', function() {
        // Aggiungi lo stile per il contenitore delle particelle
        const style = document.createElement('style');
        style.textContent = `
            #pws-particles-container {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: -1;
                pointer-events: none;
            }
        `;
        document.head.appendChild(style);

        // Carica le particelle solo se sono abilitate
        const particlesEnabled = localStorage.getItem('pws-particles-enabled') !== 'false';

        // Inizializza il toggle nelle impostazioni
        const particlesToggle = document.getElementById('pwsParticlesToggle');
        if (particlesToggle) {
            particlesToggle.checked = particlesEnabled;

            particlesToggle.addEventListener('change', function() {
                localStorage.setItem('pws-particles-enabled', this.checked);

                if (this.checked) {
                    // Se non esiste già il container delle particelle, inizializza
                    if (!tsParticles.domItem(0)) {
                        initParticles();
                    } else {
                        document.getElementById('pws-particles-container').style.display = 'block';
                    }
                } else {
                    // Nascondi le particelle senza distruggerle
                    document.getElementById('pws-particles-container').style.display = 'none';
                }

                // Mostra un toast di conferma
                if (typeof showToast === 'function') {
                    showToast(this.checked ? 'Sfondo animato PWS attivato' : 'Sfondo animato PWS disattivato', 'info');
                }
            });
        }

        // Inizializza il controllo delle particelle
        initParticleControls();

        if (particlesEnabled) {
            initParticles();
        }
    });

    // Funzione per caricare le impostazioni delle particelle
    function loadParticleSettings() {
        const defaultSettings = {
            count: null, // Usa i valori predefiniti basati sul dispositivo
            size: null,
            shape: ["circle"],
            colors: ["#00ffff", "#ff00ff"],
            opacity: 0.8,
            linkDistance: null,
            linkColor: "#ffffff",
            linkOpacity: 0.3,
            speed: null,
            hoverEffect: "grab",
            clickEffect: "push",
            image: null
        };

        try {
            const savedSettings = JSON.parse(localStorage.getItem('pws-particles-settings'));
            return savedSettings ? { ...defaultSettings, ...savedSettings } : defaultSettings;
        } catch (e) {
            console.error("Errore nel caricamento delle impostazioni particelle:", e);
            return defaultSettings;
        }
    }

    // Funzione per salvare le impostazioni delle particelle
    function saveParticleSettings(settings) {
        try {
            localStorage.setItem('pws-particles-settings', JSON.stringify(settings));
            return true;
        } catch (e) {
            console.error("Errore nel salvataggio delle impostazioni particelle:", e);
            return false;
        }
    }

    // Funzione per inizializzare i controlli delle particelle
    function initParticleControls() {
        const toggleBtn = document.getElementById('toggleParticleControls');
        const controlPanel = document.getElementById('particleControlPanel');
        const particleShape = document.getElementById('particleShape');
        const particleImageContainer = document.getElementById('particleImageContainer');
        const particleImage = document.getElementById('particleImage');
        const particleImagePreview = document.getElementById('particleImagePreview');
        const addColorBtn = document.getElementById('addColorBtn');
        const extraColorsContainer = document.getElementById('extraColorsContainer');
        const resetBtn = document.getElementById('resetParticleSettings');
        const applyBtn = document.getElementById('applyParticleSettings');

        // Carica le impostazioni salvate
        const settings = loadParticleSettings();

        // Mostra la nota per dispositivi mobili se necessario
        if (isMobile()) {
            const mobileNote = document.querySelector('.mobile-note');
            if (mobileNote) {
                mobileNote.style.display = 'block';
            }
        }

        // Inizializza i valori dei controlli
        if (document.getElementById('particleCount')) {
            document.getElementById('particleCount').value = settings.count || (isMobile() ? 20 : 50);
            document.getElementById('particleCountValue').textContent = document.getElementById('particleCount').value;

            // Aggiorna il valore visualizzato quando cambia lo slider
            document.getElementById('particleCount').addEventListener('input', function() {
                document.getElementById('particleCountValue').textContent = this.value;
            });
        }

        if (particleShape) {
            particleShape.value = Array.isArray(settings.shape) ? settings.shape[0] : "circle";

            // Mostra/nascondi il selettore di immagine in base alla forma selezionata
            particleShape.addEventListener('change', function() {
                particleImageContainer.style.display = this.value === 'image' ? 'block' : 'none';
            });

            // Inizializza la visibilità del selettore di immagine
            particleImageContainer.style.display = particleShape.value === 'image' ? 'block' : 'none';
        }

        // Gestione dell'immagine personalizzata
        if (particleImage) {
            particleImage.addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        const img = document.createElement('img');
                        img.src = event.target.result;
                        img.style.maxWidth = '100%';
                        img.style.maxHeight = '100%';
                        particleImagePreview.innerHTML = '';
                        particleImagePreview.appendChild(img);
                    };
                    reader.readAsDataURL(file);
                }
            });

            // Mostra l'immagine salvata se presente
            if (settings.image) {
                const img = document.createElement('img');
                img.src = settings.image;
                img.style.maxWidth = '100%';
                img.style.maxHeight = '100%';
                particleImagePreview.innerHTML = '';
                particleImagePreview.appendChild(img);
            }
        }

        // Inizializza i colori
        if (document.getElementById('particleColor1') && document.getElementById('particleColor2')) {
            if (settings.colors && settings.colors.length > 0) {
                document.getElementById('particleColor1').value = settings.colors[0];
                if (settings.colors.length > 1) {
                    document.getElementById('particleColor2').value = settings.colors[1];
                }

                // Aggiungi colori extra se presenti
                if (settings.colors.length > 2) {
                    for (let i = 2; i < settings.colors.length; i++) {
                        addExtraColorPicker(settings.colors[i]);
                    }
                }
            }
        }

        // Funzione per aggiungere un selettore di colore extra
        function addExtraColorPicker(color = "#ffffff") {
            const colorId = `particleColor${extraColorsContainer.children.length + 3}`;
            const colorContainer = document.createElement('div');
            colorContainer.className = 'color-picker-container';
            colorContainer.style.marginTop = '5px';

            const colorInput = document.createElement('input');
            colorInput.type = 'color';
            colorInput.id = colorId;
            colorInput.value = color;

            const removeBtn = document.createElement('button');
            removeBtn.className = 'small-btn';
            removeBtn.innerHTML = '<span class="material-symbols-outlined">remove</span>';
            removeBtn.onclick = function() {
                extraColorsContainer.removeChild(colorContainer);
            };

            colorContainer.appendChild(colorInput);
            colorContainer.appendChild(removeBtn);
            extraColorsContainer.appendChild(colorContainer);
        }

        // Gestione del pulsante per aggiungere colori
        if (addColorBtn) {
            addColorBtn.addEventListener('click', function() {
                if (extraColorsContainer.children.length < 4) { // Limita a 6 colori totali (2 predefiniti + 4 extra)
                    addExtraColorPicker();
                } else {
                    alert("Hai raggiunto il numero massimo di colori (6)");
                }
            });
        }

        // Inizializza gli altri controlli
        if (document.getElementById('particleOpacity')) {
            document.getElementById('particleOpacity').value = settings.opacity || 0.8;
            document.getElementById('particleOpacityValue').textContent = document.getElementById('particleOpacity').value;

            // Aggiorna il valore visualizzato quando cambia lo slider
            document.getElementById('particleOpacity').addEventListener('input', function() {
                document.getElementById('particleOpacityValue').textContent = this.value;
            });
        }

        if (document.getElementById('particleSizeMin') && document.getElementById('particleSizeMax')) {
            const size = settings.size || { min: 3, max: 7 };
            document.getElementById('particleSizeMin').value = size.min;
            document.getElementById('particleSizeMax').value = size.max;
        }

        if (document.getElementById('particleSpeed')) {
            document.getElementById('particleSpeed').value = settings.speed || 2;
            document.getElementById('particleSpeedValue').textContent = document.getElementById('particleSpeed').value;

            // Aggiorna il valore visualizzato quando cambia lo slider
            document.getElementById('particleSpeed').addEventListener('input', function() {
                document.getElementById('particleSpeedValue').textContent = this.value;
            });
        }

        if (document.getElementById('linkDistance')) {
            document.getElementById('linkDistance').value = settings.linkDistance || 120;
            document.getElementById('linkDistanceValue').textContent = document.getElementById('linkDistance').value;

            // Aggiorna il valore visualizzato quando cambia lo slider
            document.getElementById('linkDistance').addEventListener('input', function() {
                document.getElementById('linkDistanceValue').textContent = this.value;
            });
        }

        if (document.getElementById('linkColor')) {
            document.getElementById('linkColor').value = settings.linkColor || "#ffffff";
        }

        if (document.getElementById('linkOpacity')) {
            document.getElementById('linkOpacity').value = settings.linkOpacity || 0.3;
            document.getElementById('linkOpacityValue').textContent = document.getElementById('linkOpacity').value;

            // Aggiorna il valore visualizzato quando cambia lo slider
            document.getElementById('linkOpacity').addEventListener('input', function() {
                document.getElementById('linkOpacityValue').textContent = this.value;
            });
        }

        if (document.getElementById('hoverEffect')) {
            document.getElementById('hoverEffect').value = settings.hoverEffect || "grab";
        }

        if (document.getElementById('clickEffect')) {
            document.getElementById('clickEffect').value = settings.clickEffect || "push";
        }

        // Gestione del pulsante per mostrare/nascondere il pannello di controllo
        if (toggleBtn && controlPanel) {
            toggleBtn.addEventListener('click', function() {
                const isVisible = controlPanel.style.display !== 'none';
                controlPanel.style.display = isVisible ? 'none' : 'block';
                this.querySelector('.toggle-text').textContent = isVisible ? 'Configura' : 'Chiudi';
                this.querySelector('.material-symbols-outlined').textContent = isVisible ? 'tune' : 'close';

                // Feedback sonoro
                playSound('click');
            });
        }

        // Gestione del pulsante per ripristinare le impostazioni predefinite
        if (resetBtn) {
            resetBtn.addEventListener('click', function() {
                if (confirm("Sei sicuro di voler ripristinare le impostazioni predefinite delle particelle?")) {
                    localStorage.removeItem('pws-particles-settings');

                    // Feedback sonoro
                    playSound('click');

                    // Ricarica la pagina per applicare le impostazioni predefinite
                    location.reload();
                }
            });
        }

        // Gestione del pulsante per applicare le impostazioni
        if (applyBtn) {
            applyBtn.addEventListener('click', function() {
                // Raccogli tutti i valori dai controlli
                const newSettings = {
                    count: parseInt(document.getElementById('particleCount').value),
                    shape: [document.getElementById('particleShape').value],
                    colors: [
                        document.getElementById('particleColor1').value,
                        document.getElementById('particleColor2').value
                    ],
                    opacity: parseFloat(document.getElementById('particleOpacity').value),
                    size: {
                        min: parseInt(document.getElementById('particleSizeMin').value),
                        max: parseInt(document.getElementById('particleSizeMax').value)
                    },
                    speed: parseFloat(document.getElementById('particleSpeed').value),
                    linkDistance: parseInt(document.getElementById('linkDistance').value),
                    linkColor: document.getElementById('linkColor').value,
                    linkOpacity: parseFloat(document.getElementById('linkOpacity').value),
                    hoverEffect: document.getElementById('hoverEffect').value,
                    clickEffect: document.getElementById('clickEffect').value
                };

                // Aggiungi colori extra se presenti
                const extraColors = extraColorsContainer.querySelectorAll('input[type="color"]');
                extraColors.forEach(color => {
                    newSettings.colors.push(color.value);
                });

                // Gestione dell'immagine personalizzata
                if (newSettings.shape[0] === 'image' && particleImagePreview.querySelector('img')) {
                    newSettings.image = particleImagePreview.querySelector('img').src;
                } else {
                    newSettings.image = null;
                }

                // Salva le impostazioni
                if (saveParticleSettings(newSettings)) {
                    // Ricarica le particelle con le nuove impostazioni
                    // Ottieni l'istanza delle particelle e distruggila
                    const container = tsParticles.domItem(0);
                    if (container) {
                        container.destroy();
                    } else {
                        // Alternativa: distruggi tutte le istanze
                        tsParticles.destroyAll();
                    }

                    // Inizializza nuovamente le particelle
                    setTimeout(() => {
                        initParticles();
                    }, 100);

                    // Feedback sonoro
                    playSound('success');

                    // Notifica l'utente
                    alert("Impostazioni particelle applicate con successo!");
                } else {
                    alert("Errore nel salvataggio delle impostazioni. Riprova.");
                }
            });
        }

        // Funzione per rilevare se è un dispositivo mobile
        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }
    }

    // Funzione per inizializzare le particelle - Ottimizzata per prestazioni
    async function initParticles() {
        // Rileva se è un dispositivo mobile
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        // Carica le impostazioni personalizzate o usa i valori predefiniti
        const particleSettings = loadParticleSettings();

        // Configurazione ottimizzata con supporto per impostazioni personalizzate
        const particleCount = particleSettings.count || (isMobile ? 20 : 50);
        const particleSize = particleSettings.size || (isMobile ? { min: 2, max: 5 } : { min: 3, max: 7 });
        const linkDistance = particleSettings.linkDistance || (isMobile ? 80 : 120);
        const moveSpeed = particleSettings.speed || (isMobile ? 1 : 2);
        const fpsLimit = isMobile ? 30 : 60; // Limitato FPS su mobile
        const particleShape = particleSettings.shape || ["circle"];
        const particleColors = particleSettings.colors || ["#00ffff", "#ff00ff"];
        const particleOpacity = particleSettings.opacity || 0.8;
        const linkColor = particleSettings.linkColor || "#ffffff";
        const linkOpacity = particleSettings.linkOpacity || 0.3;
        const hoverEffect = particleSettings.hoverEffect || "grab";
        const clickEffect = particleSettings.clickEffect || "push";
        const particleImage = particleSettings.image || null;

        // Configurazione per forme personalizzate
        const shapeOptions = {};
        if (particleShape.includes("image") && particleImage) {
            shapeOptions.image = {
                src: particleImage,
                width: 32,
                height: 32
            };
        }

        await tsParticles.load("pws-particles-container", {
            fullScreen: {
                enable: false
            },
            fpsLimit: fpsLimit,
            particles: {
                number: {
                    value: particleCount,
                    density: {
                        enable: true,
                        value_area: 1200 // Aumentato per ridurre la densità
                    }
                },
                color: {
                    value: particleColors
                },
                shape: {
                    type: particleShape,
                    options: shapeOptions
                },
                opacity: {
                    value: particleOpacity,
                    random: false,
                    anim: {
                        enable: !isMobile, // Disabilitata su mobile
                        speed: 0.8,
                        opacity_min: particleOpacity * 0.6,
                        sync: false
                    }
                },
                size: {
                    value: particleSize,
                    random: true,
                    anim: {
                        enable: !isMobile, // Disabilitata su mobile
                        speed: 0.8,
                        size_min: particleSize.min * 0.5,
                        sync: false
                    }
                },
                links: {
                    enable: true,
                    distance: linkDistance,
                    color: linkColor,
                    opacity: linkOpacity,
                    width: 1,
                    shadow: {
                        enable: !isMobile, // Disabilitata su mobile
                        color: particleColors[0],
                        blur: 3 // Ridotto il blur
                    }
                },
                move: {
                    enable: true,
                    speed: moveSpeed,
                    direction: "none",
                    random: true,
                    straight: false,
                    out_mode: "out",
                    bounce: false,
                    attract: {
                        enable: false,
                        rotateX: 600,
                        rotateY: 1200
                    }
                }
            },
            interactivity: {
                detect_on: "window", // Cambiato da "canvas" a "window" per migliorare la rilevazione
                events: {
                    onhover: {
                        enable: hoverEffect !== "none", // Abilitata anche su mobile se l'effetto non è "none"
                        mode: hoverEffect
                    },
                    onclick: {
                        enable: clickEffect !== "none",
                        mode: clickEffect
                    },
                    ontap: { // Aggiunto supporto specifico per il tocco
                        enable: isMobile && clickEffect !== "none",
                        mode: clickEffect
                    },
                    resize: true
                },
                modes: {
                    grab: {
                        distance: linkDistance, // Usa la stessa distanza dei collegamenti
                        links: {
                            opacity: linkOpacity * 2 > 1 ? 1 : linkOpacity * 2, // Aumenta l'opacità ma max 1
                            color: particleColors[0] // Usa il primo colore delle particelle
                        }
                    },
                    bubble: {
                        distance: isMobile ? 100 : 150, // Ridotta per mobile
                        size: particleSize.max * 1.5, // Dimensione proporzionale
                        duration: isMobile ? 1 : 2, // Ridotta per mobile
                        opacity: particleOpacity,
                        speed: moveSpeed
                    },
                    repulse: {
                        distance: isMobile ? 150 : 200, // Ridotta per mobile
                        duration: isMobile ? 0.6 : 0.4 // Aumentata per mobile per un effetto più lungo
                    },
                    push: {
                        particles_nb: isMobile ? 3 : 4 // Aumentato per mobile per un effetto più visibile
                    },
                    remove: {
                        particles_nb: isMobile ? 2 : 1 // Aumentato per mobile per un effetto più visibile
                    },
                    // Aggiungiamo una modalità "connect" per dispositivi touch
                    connect: {
                        distance: linkDistance * 1.5,
                        links: {
                            opacity: linkOpacity * 3 > 1 ? 1 : linkOpacity * 3,
                            color: particleColors[0]
                        },
                        radius: 120
                    }
                }
            },
            retina_detect: !isMobile, // Disabilitato su mobile
            pauseOnBlur: true
        });

        // Aggiorna i colori quando cambia il tema
        document.addEventListener('themeChange', updateParticlesColors);

        // Aggiungi un controllo per fermare le particelle quando la pagina non è visibile
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                const container = tsParticles.domItem(0);
                if (container) container.pause();
            } else {
                const container = tsParticles.domItem(0);
                if (container) container.play();
            }
        });
    }

    // Funzione per aggiornare i colori delle particelle in base al tema
    function updateParticlesColors() {
        // Per lo stile neon, non aggiorniamo i colori in base al tema
        // I colori neon sono fissi per mantenere l'effetto desiderato
        console.log("Stile neon attivo: colori fissi mantenuti");
    }
    </script>

    <!-- Script per applicare la trasparenza al calendario -->
    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Funzione per applicare gli stili di trasparenza
        function applyTransparentStyles() {
            // Seleziona tutti gli elementi del calendario che devono essere trasparenti
            var elements = document.querySelectorAll(
                '.flatpickr-calendar, .flatpickr-months, .flatpickr-month, .flatpickr-weekdays, ' +
                '.flatpickr-weekdaycontainer, .dayContainer, .flatpickr-days, ' +
                '.flatpickr-innerContainer, .flatpickr-rContainer, .flatpickr-time, ' +
                '.flatpickr-prev-month, .flatpickr-next-month, .flatpickr-monthDropdown-months, ' +
                '.numInputWrapper, .flatpickr-current-month, .flatpickr-weekday, ' +
                '.numInput, .cur-year, .flatpickr-time input, .flatpickr-time .numInputWrapper, ' +
                '.flatpickr-time .flatpickr-am-pm, .calendar-header'
            );

            // Applica lo stile di trasparenza a tutti gli elementi
            elements.forEach(function(el) {
                el.style.backgroundColor = 'transparent';
            });

            // Applica stili specifici per alcuni elementi
            var monthElements = document.querySelectorAll('.flatpickr-months .flatpickr-month');
            monthElements.forEach(function(el) {
                el.style.backgroundColor = 'transparent';
                el.style.color = getComputedStyle(document.documentElement).getPropertyValue('--md-sys-color-on-surface');
                el.style.fill = getComputedStyle(document.documentElement).getPropertyValue('--md-sys-color-on-surface');
            });

            var navButtons = document.querySelectorAll('.flatpickr-prev-month, .flatpickr-next-month');
            navButtons.forEach(function(el) {
                el.style.backgroundColor = 'transparent';
                el.style.fill = getComputedStyle(document.documentElement).getPropertyValue('--md-sys-color-on-surface');
            });

            var dropdowns = document.querySelectorAll('.flatpickr-monthDropdown-months, .numInput, .cur-year');
            dropdowns.forEach(function(el) {
                el.style.backgroundColor = 'transparent';
                el.style.color = getComputedStyle(document.documentElement).getPropertyValue('--md-sys-color-on-surface');
            });

            // Applica stili specifici per il calendar-header
            var calendarHeaders = document.querySelectorAll('.calendar-header');
            var isDarkTheme = document.body.classList.contains('dark-theme');

            calendarHeaders.forEach(function(el) {
                if (isDarkTheme) {
                    el.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                    el.style.border = '1px solid rgba(255, 255, 255, 0.1)';
                    el.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.2)';
                } else {
                    el.style.backgroundColor = 'rgba(0, 0, 0, 0.2)';
                    el.style.border = '1px solid rgba(255, 255, 255, 0.15)';
                    el.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';
                }
                el.style.color = 'white';
                el.style.backdropFilter = 'blur(8px)';
            });

            // Applica stili specifici per i pulsanti nel calendar-header
            var calendarHeaderButtons = document.querySelectorAll('.calendar-header button');
            calendarHeaderButtons.forEach(function(el) {
                el.style.color = 'white';
                el.style.textShadow = '0 1px 2px rgba(0, 0, 0, 0.2)';
            });

            // Applica stili specifici per il titolo del calendario
            var calendarMonths = document.querySelectorAll('.calendar-month');
            calendarMonths.forEach(function(el) {
                el.style.color = 'white';
                el.style.fontWeight = '600';
                el.style.textShadow = '0 1px 2px rgba(0, 0, 0, 0.2)';
            });

            var calendarYears = document.querySelectorAll('.calendar-year');
            calendarYears.forEach(function(el) {
                el.style.color = 'white';
                el.style.opacity = '0.9';
                el.style.textShadow = '0 1px 2px rgba(0, 0, 0, 0.2)';
            });

            // Applica stili specifici solo per i giorni vuoti del calendario
            var emptyDays = document.querySelectorAll('.calendar-day.empty');
            emptyDays.forEach(function(el) {
                el.style.backgroundColor = 'var(--md-sys-color-surface-variant)';
                el.style.opacity = '0.5';
            });
        }

        // Applica gli stili immediatamente
        applyTransparentStyles();

        // Applica gli stili anche dopo un breve ritardo per assicurarsi che il calendario sia completamente caricato
        setTimeout(applyTransparentStyles, 500);

        // Osserva le modifiche al DOM per applicare gli stili anche quando il calendario viene aperto dinamicamente
        var observer = new MutationObserver(function(mutations) {
            mutations.forEach(function(mutation) {
                if (mutation.addedNodes.length) {
                    applyTransparentStyles();

                    // Applica gli stili anche dopo un breve ritardo per assicurarsi che tutti gli elementi siano caricati
                    setTimeout(applyTransparentStyles, 100);
                }
            });
        });

        observer.observe(document.body, { childList: true, subtree: true });
    });
    </script>

    <!-- PWA Service Worker Registration -->
    <script>
        // Configurazione per diversi ambienti di deploy
        const REPO_NAME = 'ore-pws';

        // Funzione per ottenere il percorso corretto in base all'ambiente
        function getPath(path) {
            // Rimuovi il punto iniziale se presente
            if (path.startsWith('./')) {
                path = path.substring(2);
            } else if (path.startsWith('/')) {
                path = path.substring(1);
            }

            // In ambiente di sviluppo locale
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                return './' + path;
            }

            // Su Vercel (hostname contiene .vercel.app) o dominio personalizzato
            if (window.location.hostname.includes('.vercel.app') ||
                window.location.hostname.includes('ore-pws.meme')) {
                return '/' + path;
            }

            // Su GitHub Pages (fallback)
            return '/' + REPO_NAME + '/' + path;
        }

        // Ottimizzazione dei meta tag PWA
        console.log('Ottimizzazione meta tag PWA');

        // Aggiungi il manifest con il percorso corretto
        const manifestLink = document.createElement('link');
        manifestLink.rel = 'manifest';
        manifestLink.href = getPath('manifest.json');
        document.head.appendChild(manifestLink);

        // Funzione ottimizzata per aggiungere le icone appropriate in base al dispositivo
        function addDeviceSpecificIcons() {
            // Rimuovi eventuali icone e meta tag esistenti per evitare duplicazioni
            document.querySelectorAll('link[rel="icon"], link[rel="apple-touch-icon"], link[rel="shortcut icon"], meta[name="theme-color"], meta[name="apple-mobile-web-app-capable"], meta[name="apple-mobile-web-app-status-bar-style"], meta[name="mobile-web-app-capable"]').forEach(el => el.remove());

            // Percorso base per le icone
            const iconBasePath = getPath('icons/');

            // Rileva il tipo di dispositivo
            const isAndroid = /Android/.test(navigator.userAgent);
            const isIOSDevice = isIOS();

            console.log('Rilevamento dispositivo:', isAndroid ? 'Android' : (isIOSDevice ? 'iOS' : 'Desktop/Altro'));

            // Favicon standard per tutti i browser (solo una dimensione per risparmiare risorse)
            const favicon = document.createElement('link');
            favicon.rel = 'icon';
            favicon.type = 'image/png';
            favicon.sizes = '32x32';
            favicon.href = iconBasePath + 'icon-72x72.png'; // Usiamo l'icona più piccola per il favicon
            document.head.appendChild(favicon);

            // Per Android, aggiungiamo solo le icone essenziali
            if (isAndroid) {
                console.log('Dispositivo Android rilevato, aggiungendo icone specifiche');

                // Solo l'icona principale per Android
                const androidIcon = document.createElement('link');
                androidIcon.rel = 'icon';
                androidIcon.type = 'image/png';
                androidIcon.sizes = '192x192';
                androidIcon.href = iconBasePath + 'icon-192x192.png';
                document.head.appendChild(androidIcon);

                // Aggiungi meta tag per il tema
                const themeMeta = document.createElement('meta');
                themeMeta.name = 'theme-color';
                themeMeta.content = '#006A6A'; // Colore primario dell'app
                document.head.appendChild(themeMeta);
            }

            // Icone per iOS con dimensioni specifiche (solo le essenziali)
            if (isIOSDevice) {
                console.log('Dispositivo iOS rilevato, aggiungendo icone specifiche');

                // Icona principale per iOS (utilizzata nella schermata home)
                const appleIcon = document.createElement('link');
                appleIcon.rel = 'apple-touch-icon';
                appleIcon.href = iconBasePath + 'icon-192x192.png';
                document.head.appendChild(appleIcon);

                // Solo le icone essenziali per iOS
                const appleSizes = [
                    { size: '152x152', device: 'iPad', icon: 'icon-152x152.png' },
                    { size: '180x180', device: 'iPhone', icon: 'icon-192x192.png' }
                ];

                appleSizes.forEach(item => {
                    const sizeIcon = document.createElement('link');
                    sizeIcon.rel = 'apple-touch-icon';
                    sizeIcon.sizes = item.size;
                    sizeIcon.href = iconBasePath + item.icon;
                    document.head.appendChild(sizeIcon);
                });

                // Configura il viewport per iOS (una sola volta)
                const viewportMeta = document.querySelector('meta[name="viewport"]');
                if (viewportMeta) {
                    viewportMeta.content = 'width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no';
                }

                // Aggiungi meta tag per la modalità standalone (una sola volta)
                const appleMobileWebAppCapable = document.createElement('meta');
                appleMobileWebAppCapable.name = 'apple-mobile-web-app-capable';
                appleMobileWebAppCapable.content = 'yes';
                document.head.appendChild(appleMobileWebAppCapable);

                // Aggiungi meta tag per la barra di stato
                const statusBarStyle = document.createElement('meta');
                statusBarStyle.name = 'apple-mobile-web-app-status-bar-style';
                statusBarStyle.content = 'black-translucent';
                document.head.appendChild(statusBarStyle);
            }
        }

        // Esegui la funzione per aggiungere le icone
        addDeviceSpecificIcons();

        // Variabili per l'installazione della PWA
        let deferredPrompt;
        const installButton = document.getElementById('installPwa');
        const pwaStatus = document.getElementById('pwaStatus');
        const iosInstructions = document.getElementById('iosInstructions');

        // Funzione per rilevare iOS
        function isIOS() {
            return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        }

        // Funzione per rilevare Safari su iOS
        function isIOSSafari() {
            return isIOS() && /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent);
        }

        // Gestione dell'evento beforeinstallprompt (non supportato su iOS)
        window.addEventListener('beforeinstallprompt', (e) => {
            console.log('BeforeInstallPrompt è stato attivato!');
            // Impedisci al browser di mostrare automaticamente il prompt
            e.preventDefault();
            // Salva l'evento per poterlo attivare più tardi
            deferredPrompt = e;
            // Mostra il pulsante di installazione se il prompt è disponibile
            const installButtons = document.querySelectorAll('.install-button');
            installButtons.forEach(button => {
                button.style.display = 'flex';
                button.disabled = false;
            });

            // Aggiorna l'interfaccia utente per mostrare il pulsante di installazione
            if (installButton && pwaStatus) {
                installButton.style.display = 'inline-flex';
                pwaStatus.textContent = 'L\'app è pronta per essere installata';
                pwaStatus.style.color = 'var(--md-sys-color-primary)';
            }

            // Nascondi le istruzioni per iOS
            if (iosInstructions) {
                iosInstructions.style.display = 'none';
            }
        });

        // Gestione dell'evento appinstalled
        window.addEventListener('appinstalled', () => {
            // L'app è stata installata con successo
            if (installButton && pwaStatus) {
                installButton.style.display = 'none';
                pwaStatus.textContent = 'App installata con successo!';
                pwaStatus.style.color = 'var(--md-sys-color-primary)';
            }

            // Nascondi le istruzioni per iOS
            if (iosInstructions) {
                iosInstructions.style.display = 'none';
            }

            // Pulisci la variabile deferredPrompt
            deferredPrompt = null;

            // Registra l'evento di installazione
            console.log('PWA installata con successo');
        });

        // Aggiungi l'event listener al pulsante di installazione
        document.addEventListener('DOMContentLoaded', () => {
            // Gestione del pulsante principale di installazione
            const installBtn = document.getElementById('installPwa');
            const installCardPrompt = document.getElementById('installCardPrompt');

            // Funzione per mostrare il prompt di installazione
            const showInstallPrompt = async () => {
                if (!deferredPrompt) {
                    // Se non c'è un prompt di installazione disponibile
                    console.log('Nessun prompt di installazione disponibile');
                    return;
                }

                // Mostra il prompt di installazione
                deferredPrompt.prompt();

                try {
                    // Attendi che l'utente risponda al prompt
                    const { outcome } = await deferredPrompt.userChoice;

                    // Registra il risultato
                    console.log(`Scelta dell'utente: ${outcome}`);

                    if (outcome === 'accepted') {
                        // L'utente ha accettato l'installazione
                        console.log('Utente ha accettato l\'installazione');

                        // Nascondi tutti i pulsanti di installazione
                        const allInstallButtons = document.querySelectorAll('.install-button');
                        allInstallButtons.forEach(button => {
                            button.style.display = 'none';
                        });

                        // Nascondi il card prompt
                        if (installCardPrompt) {
                            installCardPrompt.style.display = 'none';
                        }

                        // Aggiorna lo stato
                        if (pwaStatus) {
                            pwaStatus.textContent = 'App in fase di installazione...';
                        }
                    } else {
                        // L'utente ha rifiutato l'installazione
                        console.log('Utente ha rifiutato l\'installazione');
                        if (pwaStatus) {
                            pwaStatus.textContent = 'Installazione rifiutata. Riprova più tardi.';
                        }
                    }

                    // Pulisci la variabile deferredPrompt
                    deferredPrompt = null;
                } catch (error) {
                    console.error('Errore durante l\'installazione:', error);
                }
            };

            // Aggiungi event listener al pulsante principale
            if (installBtn) {
                installBtn.addEventListener('click', showInstallPrompt);
            }

            // Aggiungi event listener a tutti i pulsanti con classe install-button
            const allInstallButtons = document.querySelectorAll('.install-button');
            allInstallButtons.forEach(button => {
                button.addEventListener('click', showInstallPrompt);
            });

            // Mostra il card prompt se disponibile
            if (installCardPrompt && deferredPrompt) {
                setTimeout(() => {
                    installCardPrompt.style.display = 'block';
                }, 3000); // Mostra dopo 3 secondi
            }

            // Gestione specifica per iOS
            if (isIOS()) {
                console.log('Dispositivo iOS rilevato');

                // Controlla se l'app è già installata su iOS
                if (window.navigator.standalone === true) {
                    // L'app è già installata come PWA su iOS
                    if (pwaStatus) {
                        pwaStatus.textContent = 'App già installata';
                        pwaStatus.style.color = 'var(--md-sys-color-primary)';
                    }

                    // Nascondi le istruzioni per iOS
                    if (iosInstructions) {
                        iosInstructions.style.display = 'none';
                    }
                } else {
                    // L'app non è installata su iOS
                    if (pwaStatus) {
                        if (isIOSSafari()) {
                            pwaStatus.textContent = 'Segui le istruzioni sotto per installare l\'app';
                            pwaStatus.style.color = 'var(--md-sys-color-primary)';
                        } else {
                            pwaStatus.textContent = 'Apri questa pagina in Safari per installare l\'app';
                        }
                    }

                    // Mostra le istruzioni per iOS
                    if (iosInstructions) {
                        iosInstructions.style.display = 'block';
                    }

                    // Nascondi il pulsante di installazione (non funziona su iOS)
                    if (installButton) {
                        installButton.style.display = 'none';
                    }
                }
            } else {
                // Non è iOS, controlla se l'app è già installata
                if (window.matchMedia('(display-mode: standalone)').matches) {
                    // L'app è già installata
                    if (installButton && pwaStatus) {
                        installButton.style.display = 'none';
                        pwaStatus.textContent = 'App già installata';
                        pwaStatus.style.color = 'var(--md-sys-color-primary)';
                    }
                } else {
                    // L'app non è installata, ma potrebbe non essere disponibile per l'installazione
                    if (pwaStatus && !deferredPrompt) {
                        pwaStatus.textContent = 'Installazione non disponibile in questo momento';
                    }
                }

                // Nascondi le istruzioni per iOS su dispositivi non iOS
                if (iosInstructions) {
                    iosInstructions.style.display = 'none';
                }
            }
        });

        // Disabilita il service worker per lo sviluppo
        if ('serviceWorker' in navigator) {
            // Rimuovi tutti i service worker esistenti
            navigator.serviceWorker.getRegistrations().then(function(registrations) {
                for (let registration of registrations) {
                    registration.unregister().then(function() {
                        console.log('Service Worker rimosso con successo');
                    });
                }
            });

            // Svuota tutte le cache
            if ('caches' in window) {
                caches.keys().then(function(cacheNames) {
                    return Promise.all(
                        cacheNames.map(function(cacheName) {
                            console.log('Eliminazione cache:', cacheName);
                            return caches.delete(cacheName);
                        })
                    );
                }).then(function() {
                    console.log('Tutte le cache sono state eliminate');
                });
            }

            console.log('Service Worker disabilitato per lo sviluppo');

            // Aggiungi un listener per il reload della pagina
            window.addEventListener('focus', function() {
                // Controlla se la pagina è stata modificata
                fetch('index.html', {
                    method: 'HEAD',
                    headers: {
                        'Cache-Control': 'no-cache',
                        'Pragma': 'no-cache'
                    }
                }).then(function(response) {
                    const lastModified = response.headers.get('Last-Modified');
                    const cachedLastModified = localStorage.getItem('lastModified');

                    if (lastModified && cachedLastModified && lastModified !== cachedLastModified) {
                        console.log('Pagina modificata, ricarico...');
                        localStorage.setItem('lastModified', lastModified);
                        window.location.reload(true);
                    } else if (lastModified) {
                        localStorage.setItem('lastModified', lastModified);
                    }
                }).catch(function(error) {
                    console.error('Errore durante il controllo degli aggiornamenti:', error);
                });
            });

            // Verifica se l'app è già installata
            const isStandalone = window.matchMedia('(display-mode: standalone)').matches ||
                                window.navigator.standalone === true;

            console.log('App in modalità standalone:', isStandalone);
            console.log('deferredPrompt disponibile:', !!deferredPrompt);

            // Aggiorna lo stato della PWA
            if (pwaStatus) {
                if (isStandalone) {
                    pwaStatus.textContent = 'App già installata';
                } else if (deferredPrompt) {
                    pwaStatus.textContent = 'L\'app è pronta per essere installata';
                } else if (isIOS()) {
                    pwaStatus.textContent = 'Usa "Aggiungi alla schermata Home" per installare l\'app';
                } else {
                    pwaStatus.textContent = 'Visita il sito in un browser compatibile per installare l\'app';
                }
            }
        } else {
            // Service Worker non supportato
            if (pwaStatus) {
                pwaStatus.textContent = 'Il tuo browser non supporta l\'installazione dell\'app';
            }
        }
    </script>

    <!-- Script per la gestione dei contatti -->
    <script>
        // Funzione per inizializzare la gestione dei contatti
        function initContactsManager() {
            // Elementi DOM
            const addContactBtn = document.getElementById('addContactBtn');
            const addContactModal = document.getElementById('addContactModal');
            const closeContactModal = document.getElementById('closeContactModal');
            const cancelAddContact = document.getElementById('cancelAddContact');
            const addContactForm = document.getElementById('addContactForm');
            const contactsContainer = document.querySelector('.contacts-container');

            // Verifica se gli elementi esistono
            if (!addContactBtn || !addContactModal || !closeContactModal || !addContactForm || !contactsContainer) {
                console.error('Elementi DOM per la gestione contatti non trovati');
                return;
            }

            // Funzione per aprire il modal
            function openModal() {
                addContactModal.classList.add('show');
                setTimeout(() => {
                    document.getElementById('contactDepartment').focus();
                }, 300);
            }

            // Funzione per chiudere il modal
            function closeModal() {
                addContactModal.classList.remove('show');
                addContactForm.reset();
            }

            // Funzione per creare un nuovo contatto
            function createContact(department, name, email, phone) {
                // Crea un nuovo gruppo di contatti se non esiste già
                let contactGroup = Array.from(contactsContainer.querySelectorAll('.contact-group')).find(
                    group => group.querySelector('h3').textContent.trim() === department
                );

                if (!contactGroup) {
                    contactGroup = document.createElement('div');
                    contactGroup.className = 'contact-group';
                    contactGroup.innerHTML = `<h3>${department}</h3>`;

                    // Inserisci il nuovo gruppo prima del pulsante "Aggiungi Contatto"
                    const addContactContainer = contactsContainer.querySelector('.add-contact-container');
                    contactsContainer.insertBefore(contactGroup, addContactContainer);
                }

                // Crea la card del contatto
                const contactCard = document.createElement('div');
                contactCard.className = 'contact-card';

                // Costruisci l'HTML della card
                let contactHTML = `
                    <div class="contact-name">${name}</div>
                    <div class="contact-info">
                `;

                // Aggiungi email (obbligatoria)
                contactHTML += `
                    <div class="contact-item">
                        <span class="material-symbols-outlined">mail</span>
                        <a href="mailto:${email}">${email}</a>
                    </div>
                `;

                // Aggiungi telefono (se presente)
                if (phone && phone.trim() !== '') {
                    contactHTML += `
                        <div class="contact-item">
                            <span class="material-symbols-outlined">call</span>
                            <a href="tel:${phone}">${phone}</a>
                        </div>
                    `;
                }

                contactHTML += `</div>`;
                contactCard.innerHTML = contactHTML;

                // Aggiungi la card al gruppo
                contactGroup.appendChild(contactCard);

                // Mostra un messaggio di conferma
                showToast(`Contatto ${name} aggiunto con successo`, 'success');

                // Salva i contatti nel localStorage
                saveContacts();
            }

            // Funzione per salvare i contatti nel localStorage
            function saveContacts() {
                const contacts = [];
                const contactGroups = contactsContainer.querySelectorAll('.contact-group');

                contactGroups.forEach(group => {
                    const department = group.querySelector('h3').textContent.trim();
                    const cards = group.querySelectorAll('.contact-card');

                    cards.forEach(card => {
                        const name = card.querySelector('.contact-name').textContent.trim();
                        const emailElement = card.querySelector('.contact-item a[href^="mailto:"]');
                        const phoneElement = card.querySelector('.contact-item a[href^="tel:"]');

                        const email = emailElement ? emailElement.textContent.trim() : '';
                        const phone = phoneElement ? phoneElement.textContent.trim() : '';

                        contacts.push({ department, name, email, phone });
                    });
                });

                localStorage.setItem('pwsContacts', JSON.stringify(contacts));
            }

            // Funzione per caricare i contatti dal localStorage
            function loadContacts() {
                const savedContacts = localStorage.getItem('pwsContacts');
                if (!savedContacts) return;

                try {
                    const contacts = JSON.parse(savedContacts);
                    contacts.forEach(contact => {
                        createContact(contact.department, contact.name, contact.email, contact.phone);
                    });
                } catch (error) {
                    console.error('Errore nel caricamento dei contatti:', error);
                }
            }

            // Event listeners
            addContactBtn.addEventListener('click', openModal);
            closeContactModal.addEventListener('click', closeModal);
            cancelAddContact.addEventListener('click', closeModal);

            // Chiudi il modal se si clicca fuori dal contenuto
            addContactModal.addEventListener('click', function(event) {
                if (event.target === addContactModal) {
                    closeModal();
                }
            });

            // Gestisci l'invio del form
            addContactForm.addEventListener('submit', function(event) {
                event.preventDefault();

                const department = document.getElementById('contactDepartment').value.trim();
                const name = document.getElementById('contactName').value.trim();
                const email = document.getElementById('contactEmail').value.trim();
                const phone = document.getElementById('contactPhone').value.trim();

                createContact(department, name, email, phone);
                closeModal();
            });

            // Funzione per mostrare un toast di notifica
            function showToast(message, type = 'info') {
                // Verifica se esiste già una funzione showToast globale
                if (window.showToast && typeof window.showToast === 'function') {
                    window.showToast(message, type);
                } else {
                    // Implementazione semplice di fallback
                    alert(message);
                }
            }
        }

        // Inizializza il gestore contatti quando il DOM è pronto
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initContactsManager);
        } else {
            initContactsManager();
        }
    </script>

    <!-- Script di ottimizzazione per Safari iOS e altri browser -->
    <script>
    (function() {
        // Verifica se il browser è Safari su iOS
        const isIOSSafari = /iPad|iPhone|iPod/.test(navigator.userAgent) &&
                            !window.MSStream &&
                            /WebKit/.test(navigator.userAgent) &&
                            !/Chrome/.test(navigator.userAgent);

        if (isIOSSafari) {
            console.log("Rilevato Safari su iOS: applicazione ottimizzazioni...");

            // 1. Ottimizzazione delle animazioni
            document.documentElement.classList.add('ios-safari');

            // 2. Limitazione delle animazioni per migliorare le prestazioni
            const limitAnimations = function() {
                // Aggiungi will-change solo agli elementi che ne hanno bisogno
                const animatedElements = document.querySelectorAll('.bouncing-logo, .nav-item.active');
                animatedElements.forEach(el => {
                    el.style.willChange = 'transform';
                });

                // Rimuovi will-change dagli elementi che non sono più visibili
                const cleanup = function() {
                    document.querySelectorAll('[style*="will-change"]').forEach(el => {
                        if (!isElementInViewport(el)) {
                            el.style.willChange = 'auto';
                        }
                    });
                };

                // Controlla se un elemento è nel viewport
                function isElementInViewport(el) {
                    const rect = el.getBoundingClientRect();
                    return (
                        rect.top >= 0 &&
                        rect.left >= 0 &&
                        rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
                        rect.left <= (window.innerWidth || document.documentElement.clientWidth)
                    );
                }

                // Esegui cleanup periodicamente
                setInterval(cleanup, 2000);
            };

            // 3. Ottimizzazione localStorage
            const optimizeStorage = function() {
                // Funzione per comprimere i dati prima di salvarli
                const originalSetItem = localStorage.setItem;
                localStorage.setItem = function(key, value) {
                    // Non comprimere valori piccoli
                    if (typeof value === 'string' && value.length > 1000) {
                        try {
                            // Rimuovi spazi bianchi non necessari per JSON
                            const parsedValue = JSON.parse(value);
                            const compressedValue = JSON.stringify(parsedValue);
                            originalSetItem.call(localStorage, key, compressedValue);
                        } catch (e) {
                            // Se non è JSON valido, salva normalmente
                            originalSetItem.call(localStorage, key, value);
                        }
                    } else {
                        originalSetItem.call(localStorage, key, value);
                    }
                };

                // Gestione errori di quota
                window.addEventListener('error', function(e) {
                    if (e.message && e.message.includes('QuotaExceededError')) {
                        console.warn('Quota localStorage superata, pulizia cache...');
                        // Rimuovi dati meno importanti
                        const keysToPreserve = ['timeTrackerData', 'userName'];
                        for (let i = 0; i < localStorage.length; i++) {
                            const key = localStorage.key(i);
                            if (!keysToPreserve.includes(key)) {
                                localStorage.removeItem(key);
                            }
                        }
                    }
                });
            };

            // 4. Prevenzione memory leak
            const preventMemoryLeaks = function() {
                // Rimuovi i listener non necessari quando gli elementi vengono rimossi
                const originalRemoveChild = Element.prototype.removeChild;
                Element.prototype.removeChild = function(child) {
                    if (child.nodeName !== '#text') {
                        // Clona e sostituisci per rimuovere event listeners
                        const clone = child.cloneNode(true);
                        this.replaceChild(clone, child);
                        return clone;
                    }
                    return originalRemoveChild.call(this, child);
                };

                // Limita il numero di elementi nel DOM
                const checkDOMSize = function() {
                    const domSize = document.querySelectorAll('*').length;
                    if (domSize > 2000) {
                        console.warn('DOM troppo grande:', domSize, 'elementi');
                    }
                };

                // Controlla periodicamente
                setInterval(checkDOMSize, 10000);
            };

            // 5. Ottimizzazione scroll
            const optimizeScroll = function() {
                // Usa passive listeners per migliorare lo scrolling
                document.addEventListener('touchstart', function(){}, {passive: true});
                document.addEventListener('touchmove', function(){}, {passive: true});

                // Disabilita temporaneamente le animazioni durante lo scroll
                let scrollTimeout;
                window.addEventListener('scroll', function() {
                    document.body.classList.add('disable-animations');
                    clearTimeout(scrollTimeout);
                    scrollTimeout = setTimeout(function() {
                        document.body.classList.remove('disable-animations');
                    }, 200);
                }, {passive: true});
            };

            // 6. Gestione eventi touch migliorata
            const optimizeTouchEvents = function() {
                // Rimuovi il delay di 300ms sui click
                document.documentElement.style.touchAction = 'manipulation';

                // Previeni zoom involontario su doppio tap
                let lastTouchEnd = 0;
                document.addEventListener('touchend', function(e) {
                    const now = Date.now();
                    if (now - lastTouchEnd < 300) {
                        e.preventDefault();
                    }
                    lastTouchEnd = now;
                }, false);
            };

            // Esegui tutte le ottimizzazioni quando il DOM è pronto
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', function() {
                    limitAnimations();
                    optimizeStorage();
                    preventMemoryLeaks();
                    optimizeScroll();
                    optimizeTouchEvents();
                    console.log("Ottimizzazioni Safari iOS applicate");
                });
            } else {
                limitAnimations();
                optimizeStorage();
                preventMemoryLeaks();
                optimizeScroll();
                optimizeTouchEvents();
                console.log("Ottimizzazioni Safari iOS applicate");
            }
        }

        // Ottimizzazioni generali per tutti i browser
        document.addEventListener('DOMContentLoaded', function() {
            // 1. Ottimizzazione delle immagini
            const lazyLoadImages = function() {
                const images = document.querySelectorAll('img[data-src]');
                if (images.length > 0) {
                    const imageObserver = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                const img = entry.target;
                                img.src = img.dataset.src;
                                img.removeAttribute('data-src');
                                imageObserver.unobserve(img);
                            }
                        });
                    });

                    images.forEach(img => imageObserver.observe(img));
                }
            };

            // 2. Ottimizzazione degli event listener
            const optimizeEventListeners = function() {
                // Usa la delegazione degli eventi per ridurre il numero di listener
                document.body.addEventListener('click', function(e) {
                    // Gestisci i click sui pulsanti
                    if (e.target.matches('button, .btn, [role="button"]') ||
                        e.target.closest('button, .btn, [role="button"]')) {
                        // Aggiungi feedback tattile
                        if ('vibrate' in navigator) {
                            navigator.vibrate(5);
                        }
                    }
                });
            };

            // 3. Ottimizzazione del rendering
            const optimizeRendering = function() {
                // Riduci il reflow e repaint
                const heavyElements = document.querySelectorAll('.time-entries-list, .monthly-report-container');
                heavyElements.forEach(el => {
                    el.style.willChange = 'transform';
                    el.style.transform = 'translateZ(0)';
                });
            };

            // Esegui le ottimizzazioni
            lazyLoadImages();
            optimizeEventListeners();
            optimizeRendering();

            console.log("Ottimizzazioni generali applicate");
        });
    })();
    </script>

    <!-- Script per gestire il PIN Admin -->
    <script>
        // Funzione per gestire il PIN Admin
        function initAdminPin() {
            console.log("Inizializzazione PIN Admin...");

            // Elementi DOM
            const adminPinInput = document.getElementById('adminPin');
            const unlockAdminBtn = document.getElementById('unlockAdminFeatures');
            const lockAdminBtn = document.getElementById('lockAdminFeatures');
            const cashNavItem = document.getElementById('cash-nav-item');

            // PIN Admin corretto (hardcoded per funzionare anche con GitHub Pages)
            const CORRECT_PIN = "1235789";
            console.log("PIN configurato:", CORRECT_PIN);

            // Controlla se il PIN è già stato inserito correttamente
            const isAdminUnlocked = localStorage.getItem('adminUnlocked') === 'true';

            // Aggiorna l'interfaccia in base allo stato
            if (isAdminUnlocked && cashNavItem) {
                cashNavItem.style.display = 'flex';
                if (lockAdminBtn) lockAdminBtn.style.display = 'block';
                if (unlockAdminBtn) unlockAdminBtn.style.display = 'none';
                console.log("Funzionalità admin già sbloccate");
            } else {
                if (cashNavItem) cashNavItem.style.display = 'none';
                if (lockAdminBtn) lockAdminBtn.style.display = 'none';
                if (unlockAdminBtn) unlockAdminBtn.style.display = 'block';
                console.log("Funzionalità admin bloccate");
            }

            // Gestione del pulsante di sblocco
            if (unlockAdminBtn && adminPinInput) {
                unlockAdminBtn.onclick = function() {
                    console.log("Pulsante sblocco cliccato");
                    const enteredPin = adminPinInput.value;

                    console.log("PIN inserito:", enteredPin);
                    console.log("PIN corretto:", CORRECT_PIN);
                    console.log("Confronto:", enteredPin === CORRECT_PIN);

                    // Confronto più flessibile per evitare problemi con spazi o caratteri invisibili
                    // Accetta solo il PIN "1235789" (con o senza spazi)
                    if (enteredPin.trim() === CORRECT_PIN ||
                        enteredPin === "1235789" ||
                        enteredPin.trim() === "1235789") {
                        console.log("PIN corretto!");
                        // PIN corretto
                        showToast('Funzionalità admin sbloccate!', 'success', 3000);

                        // Mostra la sezione Cash nella barra di navigazione
                        if (cashNavItem) {
                            cashNavItem.style.display = 'flex';
                        }

                        // Salva lo stato di sblocco
                        localStorage.setItem('adminUnlocked', 'true');

                        // Pulisci il campo PIN
                        adminPinInput.value = '';

                        // Mostra il pulsante di blocco e nascondi quello di sblocco
                        if (lockAdminBtn) lockAdminBtn.style.display = 'block';
                        unlockAdminBtn.style.display = 'none';
                    } else {
                        console.log("PIN errato!");
                        // PIN errato
                        showToast('PIN non valido!', 'error', 3000);

                        // Effetto di vibrazione per feedback tattile
                        if ('vibrate' in navigator) {
                            navigator.vibrate(200);
                        }

                        // Pulisci il campo PIN
                        adminPinInput.value = '';
                    }
                };
            }

            // Gestione del pulsante di blocco
            if (lockAdminBtn) {
                lockAdminBtn.onclick = function() {
                    console.log("Pulsante blocco cliccato");
                    // Nascondi la sezione Cash
                    if (cashNavItem) {
                        cashNavItem.style.display = 'none';
                    }

                    // Rimuovi lo stato di sblocco
                    localStorage.removeItem('adminUnlocked');

                    // Mostra il pulsante di sblocco e nascondi quello di blocco
                    if (unlockAdminBtn) unlockAdminBtn.style.display = 'block';
                    lockAdminBtn.style.display = 'none';

                    // Notifica l'utente
                    showToast('Funzionalità admin bloccate!', 'info', 3000);
                };
            }
        }

        // Inizializza il PIN Admin quando il documento è pronto
        document.addEventListener('DOMContentLoaded', initAdminPin);
    </script>

    <!-- Import Preview Modal -->
    <div id="importPreviewModal" class="import-preview-modal">
        <div class="import-preview-content">
            <div class="import-preview-header">
                <h3 class="import-preview-title">Anteprima Importazione Ore</h3>
                <button class="import-close-btn" onclick="closeImportPreviewModal()">
                    <span class="material-symbols-outlined">close</span>
                </button>
            </div>
            <div class="import-preview-body">
                <div class="import-summary" id="importSummary">
                    <!-- Summary will be populated by JS -->
                </div>
                <div class="import-entries-list" id="importEntriesList">
                    <!-- Entries will be populated by JS -->
                </div>
            </div>
            <div class="import-preview-actions">
                <button class="import-action-btn import-btn-cancel" onclick="closeImportPreviewModal()">
                    Annulla
                </button>
                <button class="import-action-btn import-btn-replace" onclick="importWorkHours('replace')" id="importReplaceBtn">
                    Sostituisci
                </button>
                <button class="import-action-btn import-btn-merge" onclick="importWorkHours('merge')" id="importMergeBtn">
                    Aggiungi
                </button>
            </div>
        </div>
    </div>

    <!-- Finestra di Benvenuto e Sicurezza -->
    <div id="welcomeModal" class="welcome-modal" style="display: none;">
        <div class="welcome-modal-content">
            <div class="welcome-header">
                <span class="material-symbols-outlined" style="font-size: 48px; color: var(--md-sys-color-primary);">cloud_sync</span>
                <h2>Benvenuto in Ore PWS Group!</h2>
            </div>

            <div class="welcome-body">
                <div class="welcome-section">
                    <h3>🔒 Importante: Salva i tuoi dati!</h3>
                    <p>Per non perdere mai le tue ore di lavoro, è <strong>fondamentale</strong> creare un backup cloud. I tuoi dati saranno al sicuro e sincronizzati su tutti i dispositivi.</p>
                </div>

                <div class="welcome-section">
                    <h3>⚠️ Avviso di Sicurezza Google</h3>
                    <p>Durante il login con Google, potresti vedere questo messaggio:</p>
                    <div class="warning-box">
                        <strong>"Google non ha verificato questa app"</strong>
                    </div>
                    <p><strong>Non preoccuparti!</strong> Questo è normale perché:</p>
                    <ul>
                        <li>✅ L'app è stata creata da <strong>Leonid Lyakhu</strong></li>
                        <li>✅ È sicura al 100%, ma non ancora verificata ufficialmente da Google</li>
                        <li>✅ Il processo di verifica Google richiede tempo</li>
                    </ul>
                </div>

                <div class="welcome-section">
                    <h3>📝 Come procedere:</h3>
                    <ol>
                        <li>Clicca su <strong>"Avanzate"</strong></li>
                        <li>Poi clicca su <strong>"Apri ore-pws.meme (non sicura)"</strong></li>
                        <li>Autorizza l'accesso a Google Drive</li>
                        <li>I tuoi dati saranno al sicuro! 🛡️</li>
                    </ol>
                </div>

                <div class="welcome-section">
                    <h3>🎯 Cosa puoi fare ora:</h3>
                    <p><strong>Opzione 1:</strong> Accedi subito per configurare il backup automatico<br>
                    <strong>Opzione 2:</strong> Continua senza backup (potrai farlo dopo dalle Impostazioni)</p>
                </div>
            </div>

            <div class="welcome-footer">
                <button id="welcomeLaterBtn" class="btn-secondary">
                    <span class="material-symbols-outlined">schedule</span>
                    OK, dopo
                </button>
                <button id="welcomeLoginBtn" class="btn-primary">
                    <span class="material-symbols-outlined">cloud_upload</span>
                    Accedi ora
                </button>
            </div>
        </div>
    </div>

    <style>
        .welcome-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 10000;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }

        .welcome-modal-content {
            background-color: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
            border-radius: var(--border-radius-large);
            padding: 2rem;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: var(--elevation-5);
            border: 1px solid var(--md-sys-color-outline-variant);
            margin: 1rem;
        }

        .welcome-header {
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .welcome-header h2 {
            color: var(--md-sys-color-primary);
            margin: 0.5rem 0 0 0;
            font-size: 1.5rem;
        }

        .welcome-section {
            margin-bottom: 1.5rem;
        }

        .welcome-section h3 {
            color: var(--md-sys-color-primary);
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }

        .welcome-section p {
            line-height: 1.6;
            margin-bottom: 0.5rem;
        }

        .welcome-section ul, .welcome-section ol {
            margin-left: 1.5rem;
            line-height: 1.6;
        }

        .warning-box {
            background-color: var(--md-sys-color-error-container);
            color: var(--md-sys-color-on-error-container);
            padding: 0.75rem;
            border-radius: var(--border-radius-small);
            margin: 0.5rem 0;
            text-align: center;
            border-left: 4px solid var(--md-sys-color-error);
        }

        .welcome-footer {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 2rem;
            flex-wrap: wrap;
        }

        .welcome-footer button {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: var(--border-radius-full);
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 140px;
            justify-content: center;
        }

        .btn-primary {
            background-color: var(--md-sys-color-primary);
            color: var(--md-sys-color-on-primary);
        }

        .btn-primary:hover {
            background-color: var(--md-sys-color-primary);
            box-shadow: var(--elevation-2);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background-color: var(--md-sys-color-secondary-container);
            color: var(--md-sys-color-on-secondary-container);
        }

        .btn-secondary:hover {
            background-color: var(--md-sys-color-secondary-container);
            box-shadow: var(--elevation-1);
        }

        @media (max-width: 768px) {
            .welcome-modal-content {
                margin: 0.5rem;
                padding: 1.5rem;
                max-height: 95vh;
            }

            .welcome-footer {
                flex-direction: column;
            }

            .welcome-footer button {
                width: 100%;
            }
        }
    </style>

    <script>
        // Gestione finestra di benvenuto
        document.addEventListener('DOMContentLoaded', function() {
            const welcomeModal = document.getElementById('welcomeModal');
            const welcomeLaterBtn = document.getElementById('welcomeLaterBtn');
            const welcomeLoginBtn = document.getElementById('welcomeLoginBtn');

            // Controlla se è la prima visita
            const hasSeenWelcome = localStorage.getItem('hasSeenWelcome');

            if (!hasSeenWelcome) {
                // Mostra la finestra dopo un breve delay
                setTimeout(() => {
                    welcomeModal.style.display = 'flex';
                }, 1000);
            }

            // Pulsante "OK, dopo"
            welcomeLaterBtn.addEventListener('click', function() {
                welcomeModal.style.display = 'none';
                localStorage.setItem('hasSeenWelcome', 'true');
                showToast("Potrai configurare il backup cloud dalle Impostazioni quando vuoi!", "info", 4000);
            });

            // Pulsante "Accedi ora"
            welcomeLoginBtn.addEventListener('click', async function() {
                welcomeModal.style.display = 'none';
                localStorage.setItem('hasSeenWelcome', 'true');

                // Mostra messaggio di caricamento
                showToast("Avvio login Google Drive...", "info", 2000);

                // Attendi un momento per far vedere il toast
                setTimeout(async () => {
                    try {
                        // Assicurati che cloudManager sia inizializzato
                        if (!window.cloudManager) {
                            await initCloudBackup(true); // Inizializza senza controllo auth
                        }

                        // Seleziona Google Drive come provider
                        if (window.cloudManager) {
                            const success = window.cloudManager.setSelectedProvider('google');
                            console.log('Provider Google selezionato:', success);
                        }

                        // Usa direttamente il provider Google (più affidabile)
                        if (window.cloudManager && window.cloudManager.providers.google) {
                            console.log('Avvio login diretto con Google Provider...');
                            const googleProvider = window.cloudManager.providers.google;

                            showToast("Apertura popup Google Drive...", "info", 2000);
                            const userData = await googleProvider.login(true);

                            if (userData) {
                                // Imposta il provider come corrente dopo il login riuscito
                                window.cloudManager.setSelectedProvider('google');
                                window.cloudManager.currentProvider = 'google';

                                // Aggiorna l'UI
                                if (typeof updateProviderSelectionUI === 'function') {
                                    updateProviderSelectionUI();
                                }
                                if (typeof updateCloudAccountUI === 'function') {
                                    updateCloudAccountUI();
                                }

                                        showToast("🎉 Login Google Drive completato! I tuoi dati sono ora al sicuro.", "success", 5000);
                            } else {
                                throw new Error("Login fallito - nessun dato utente ricevuto");
                            }
                        } else {
                            // Se cloudManager non è disponibile, mostra errore
                            console.error('CloudManager o provider Google non disponibile');
                            showToast("Errore: Sistema di backup non disponibile. Ricarica la pagina.", "error", 5000);
                        }
                    } catch (error) {
                        console.error('Errore durante il login:', error);
                        showToast("Errore durante il login: " + error.message, "error", 5000);
                    }
                }, 500);
            });
        });
    </script>

</body>
</html>